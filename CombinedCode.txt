【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/App.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml;
using OneLauncher.Core;
using OneLauncher.Views;
using System;
using System.Diagnostics;

namespace OneLauncher;

public partial class App : Application
{
    public override void Initialize() =>
        AvaloniaXamlLoader.Load(this);

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = new MainWindow();
        }
        base.OnFrameworkInitializationCompleted();
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/App.axaml
【代码拼接器】文件内容开始
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:themes="clr-namespace:Avalonia.Styling;assembly=Avalonia.Base"
             xmlns:views="using:OneLauncher.Views"
             xmlns:diagnostics="using:Avalonia.Diagnostics"
			 xmlns:vm="clr-namespace:OneLauncher.Views.ViewModels;assembly=OneLauncher"
             x:Class="OneLauncher.App"
             RequestedThemeVariant="Default">
	<Application.Resources>
		<ResourceDictionary>
			<vm:ModEnumToStringConverter x:Key="ModEnumConverter"/>
			<ResourceDictionary.ThemeDictionaries>
				<ResourceDictionary x:Key="Light">
					<SolidColorBrush x:Key="MainWindowBackground" Color="#99FFFFFF"/>
					<SolidColorBrush x:Key="PageBackground" Color="#FFFFFF"/>
					<SolidColorBrush x:Key="ListBoxItemBackgound" Color="#F4F4F5" />
					<SolidColorBrush x:Key="PaneBackgound" Color="#EAEAEA" />
				</ResourceDictionary>
				<ResourceDictionary x:Key="Dark">
					<SolidColorBrush x:Key="MainWindowBackground" Color="#99181820"/>
					<SolidColorBrush x:Key="PageBackground" Color="#212121"/>
					<SolidColorBrush x:Key="ListBoxItemBackgound" Color="#24252A" />
					<SolidColorBrush x:Key="PaneBackgound" Color="#171717" />
				</ResourceDictionary>
			</ResourceDictionary.ThemeDictionaries>
		</ResourceDictionary>
	</Application.Resources>

	<Application.Styles>
		<FluentTheme />
	</Application.Styles>
</Application>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Codes/LaunchGame.cs
【代码拼接器】文件内容开始
using Avalonia.Controls.Documents;
using Avalonia.Data;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Launcher;
using OneLauncher.Core.Minecraft;
using OneLauncher.Views.Windows;
using OneLauncher.Views.Windows.WindowViewModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Codes;
internal class Game
{
    public event Action? GameStartedEvent;
    public event Action? GameClosedEvent;
    public event Action<string>? GamePutEvent;
    public async Task LaunchGame(
        GameData gameData,
        ServerInfo? serverInfo = null,
        bool useRootLaunch = false)
    {
        #region 初始化基本游戏构建类
        var Builder = new LaunchCommandBuilder
                        (
                            Init.GameRootPath,
                            gameData,
                            serverInfo
                        );
        #endregion
        
        try
        {
            string launchArgumentsPath = Path.GetTempFileName();
            await File.WriteAllTextAsync(
                launchArgumentsPath,
                (
                string.Join(" " ,await Builder.BuildCommand(
                     Init.ConfigManger.Data.OlanSettings.MinecraftJvmArguments.ToString(Builder.versionInfo.GetJavaVersion()),useRootLaunch)))
#if WINDOWS
                // 避免微软万年屎山导致的找不到路径问题
                .Replace("\\",@"\\")
#endif
                );
            using (Process process = new Process())
            {
                process.StartInfo = new ProcessStartInfo()
                {
                    Arguments =
                    // 如果你想自定义标题，可以从Github下载OneLauncher.Agent.jar，然后把路径输入到这里，后面的就是新标题
                    //"-javaagent:\"F:\\OneLauncherAgent.jar\"=\"Hello World by OneLauncher\"" +
                    $"@{launchArgumentsPath}",
                    FileName = Builder.GetJavaPath(),
                    WorkingDirectory = Init.GameRootPath,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    StandardOutputEncoding = Encoding.UTF8,
                    StandardErrorEncoding = Encoding.UTF8
                };
                process.OutputDataReceived += async (sender, e) =>
                {
                    if (string.IsNullOrEmpty(e.Data)) return;
                    Debug.WriteLine(e.Data);
                    GamePutEvent?.Invoke($"[STDOUT] {e.Data}{Environment.NewLine}");
                    if (e.Data.Contains("Backend library: LWJGL version"))
                        GameStartedEvent?.Invoke();
                };
                process.ErrorDataReceived += async (sender, e) =>
                {
                    if (string.IsNullOrEmpty(e.Data)) return;
                    Debug.WriteLine(e.Data);
                    GamePutEvent?.Invoke($"[ERROR] {e.Data}{Environment.NewLine}");
                    if (e.Data.Contains("java.lang.ClassNotFoundException")) 
                        await OlanExceptionWorker.ForOlanException(
                        new OlanException("启动失败","Jvm无法找到主类，请尝试重新安装游戏",OlanExceptionAction.Error),
                        () => _=LaunchGame(
                                gameData));
                };
                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();
                await process.WaitForExitAsync();
                if(process.ExitCode != 0)
                    await OlanExceptionWorker.ForOlanException(
                        new OlanException("启动失败", "未知错误，请尝试以调试模式启动游戏以查找出错原因", OlanExceptionAction.Error),
                        () => _=LaunchGame(
                                gameData));
            }
            GameClosedEvent?.Invoke();
            File.Delete(launchArgumentsPath);
        }
        catch(FileNotFoundException fex)
        {
            await OlanExceptionWorker.ForOlanException(
                        new OlanException("启动失败", $"无法找到启动所需的文件{Environment.NewLine}{fex}", OlanExceptionAction.Error, fex));
        }
        catch (DirectoryNotFoundException fex)
        {
            await OlanExceptionWorker.ForOlanException(
                        new OlanException("启动失败", $"无法找到启动所需的文件夹{Environment.NewLine}{fex}", OlanExceptionAction.Error,fex));
        }
        catch(Exception ex)
        {
            await OlanExceptionWorker.ForOlanException(
                        new OlanException("启动失败", $"系统未安装Java或系统错误{Environment.NewLine}{ex}", OlanExceptionAction.Error,ex));
        }
    }
}


【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Codes/OlanExceptionWorker.cs
【代码拼接器】文件内容开始
using Avalonia.Threading;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Core.Global;
using OneLauncher.Views;
using OneLauncher.Views.Windows;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Codes;

internal class OlanExceptionWorker
{
    public static Task ForOlanException(OlanException exception, Action TryAgainFunction = null)
    {
        if(TryAgainFunction != null)
            exception.TryAgainFunction = TryAgainFunction;
        return Dispatcher.UIThread.InvokeAsync(async () => 
        {
            if (exception.Action == OlanExceptionAction.Warning)
                WeakReferenceMessenger.Default.Send(new MainWindowShowFlyoutMessage(exception.Message,true));
            if (exception.Action == OlanExceptionAction.Error)
                await new ExceptionTip(exception).ShowDialog(MainWindow.mainwindow);
            if (exception.Action == OlanExceptionAction.FatalError)
            {
                await new ExceptionTip(exception).ShowDialog(MainWindow.mainwindow);
                Environment.Exit(1);
            }
        });
    }
    public static Task ForUnknowException(Exception exception, Action TryAgainFunction = null)
    {
        return Dispatcher.UIThread.InvokeAsync(async () =>
        {
            await new ExceptionTip(new OlanException("出现未知错误",exception.ToString(),OlanExceptionAction.Error)).ShowDialog(MainWindow.mainwindow);
        });
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/account.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core;
using System.Diagnostics;
using OneLauncher.Views;
using Avalonia.Interactivity;
using System.Threading.Tasks;
using System;
using OneLauncher.Codes;
using OneLauncher.Views.ViewModels;
using System.Linq;
using OneLauncher.Core.Net.msa;
using OneLauncher.Core.Helper;
namespace OneLauncher.Views;
public partial class account : UserControl
{
    public account()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/download.axaml.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using OneLauncher.Codes;
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Minecraft;
using OneLauncher.Views;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;


namespace OneLauncher.Views;

public partial class download : UserControl
{
    public download()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/gamedata.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;
using Microsoft.Extensions.DependencyInjection;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace OneLauncher.Views;

public partial class gamedata : UserControl
{
    public gamedata()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Home.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using Avalonia.Threading;
using OneLauncher.Codes;
using OneLauncher.Core;
using OneLauncher.Views;
using OneLauncher.Views.ViewModels;
using System;
using System.Diagnostics;
using System.Threading.Tasks;
namespace OneLauncher;

public partial class Home : UserControl
{
    public Home()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/MainWindow.axaml.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Media;
using Avalonia.Platform;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.Messaging;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Views.Panes;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.Panes.PaneViewModels.Factories;
using OneLauncher.Views.ViewModels;
using System;
using System.Diagnostics;
using System.Threading.Tasks;

namespace OneLauncher.Views;
internal class ApplicationClosingMessage { }
internal class MainWindowShowFlyoutMessage
{
    public readonly string Context;
    public readonly bool IsWarn;
    public MainWindowShowFlyoutMessage(string context,bool isWarn = false)
    {
        this.Context = context;
        this.IsWarn = isWarn;
    }
}
public partial class MainWindow : Window
{
    public Home HomePage;
    public version versionPage;
    public download downloadPage;
    public settings settingsPage;
    public account accountPage;
    public ModsBrowser modsBrowserPage;
    public gamedata gamedataPage;
    public static MainWindow mainwindow;
    bool IsError;
    IServiceCollection servises;
    public readonly IServiceProvider provider;
    public MainWindow()
    {
        InitializeComponent();
        mainwindow = this;
        try
        {
            // 等待基本组件初始化完成，并在后续注册ViewModel
            servises = Init.InitTask.GetAwaiter().GetResult();

            servises.AddSingleton<AccountPageViewModel>();
            servises.AddSingleton<DownloadPageViewModel>();
            servises.AddSingleton<GameDataPageViewModel>();
            servises.AddSingleton<HomePageViewModel>();
            servises.AddSingleton<ModsBrowserViewModel>();
            servises.AddSingleton<SettingsPageViewModel>();
            servises.AddSingleton<VersionPageViewModel>();

            servises.AddTransient<NewGameDataPaneViewModel>();
            // Pane ViewModel本身是单例的，但工厂模式可以保证每次获取都是新的实例
            servises.AddSingleton<DownloadPaneViewModelFactory>();
            servises.AddSingleton<EditGameDataPaneViewModelFactory>();
            servises.AddSingleton<PowerPlayPaneViewModelFactory>();
            servises.AddSingleton<InstallModPaneViewModelFactory>();

            provider = servises.BuildServiceProvider();
            PageContent.Content = new Home();
            // 注册消息
            WeakReferenceMessenger.Default.Register<MainWindowShowFlyoutMessage>(this, (re, message) => ShowFlyout(message.Context, message.IsWarn));
        }
        catch(OlanException e)
        {
            IsError = true;
            OlanExceptionWorker.ForOlanException(e);
        }
    }
    protected override void OnOpened(EventArgs e)
    {
        base.OnOpened(e);
        if (!IsError)
        {
            try
            {
                HomePage = new Home()
                { DataContext = provider.GetRequiredService<HomePageViewModel>()};
                versionPage = new version() 
                { DataContext = provider.GetRequiredService<VersionPageViewModel>() }; 
                accountPage = new account()
                { DataContext = provider.GetRequiredService<AccountPageViewModel>() };
                modsBrowserPage = new ModsBrowser()
                { DataContext = provider.GetRequiredService<ModsBrowserViewModel>() };
                downloadPage = new download()
                { DataContext = provider.GetRequiredService<DownloadPageViewModel>() };
                settingsPage = new settings()
                { DataContext = provider.GetRequiredService<SettingsPageViewModel>() };
                gamedataPage = new gamedata()
                { DataContext = provider.GetRequiredService<GameDataPageViewModel>() };
            }
            catch (OlanException ex)
            {
                OlanExceptionWorker.ForOlanException(ex);
            }
        }
    }
    protected override async void OnClosing(WindowClosingEventArgs e)
    {
        base.OnClosing(e);
        Debug.WriteLine("释放残余资源...");
        foreach(var dis in Init.OnApplicationClosingReleaseSourcesList)
            dis.Dispose();
        // 发送关闭消息
        WeakReferenceMessenger.Default.Send(new ApplicationClosingMessage());
    }
    /// <summary>
    /// 在右下角显示提示信息
    /// </summary>
    /// <param ID="text">提示信息内容</param>
    public void ShowFlyout(string text,bool IsWarning = false) =>
    Dispatcher.UIThread.Post(async() =>
    {
        FytFkA.Text = text;
        if (IsWarning)
            FytB.Background = new SolidColorBrush(Colors.Red);
        else
            FytB.Background = new SolidColorBrush(Colors.LightBlue);
        FytB.IsVisible = true;
        await Task.Delay(3000);
        FytB.IsVisible = false;
    });
    
    // 统一事件方法
    private void ListBox_SelectionChanged(object? sender, Avalonia.Controls.SelectionChangedEventArgs e)
    {
        var listBox = sender as ListBox;
        if (listBox == null) return;

        var selectedItem = listBox.SelectedItem as ListBoxItem;
        if (selectedItem == null) return;

        switch (selectedItem.Tag)
        {
            case "Home":
                PageContent.Content = HomePage;
                break;
            case "Version":
                PageContent.Content = versionPage;
                break;
            case "Account":
                PageContent.Content = accountPage;
                break;
            case "ModsBrowser":
                PageContent.Content = modsBrowserPage;
                break;
            case "Download":
                PageContent.Content = downloadPage;
                break;
            case "GameData":
                PageContent.Content = gamedataPage;
                break;
            case "Settings":
                PageContent.Content = settingsPage;
                break;
        }
        
    }
    // 切换侧边栏展开/折叠
    private void MangePaneOpenAndClose(bool IsOpen)
    {
        HomeText.IsVisible = IsOpen;
        VersionText.IsVisible = IsOpen;
        AccountText.IsVisible = IsOpen;
        DownloadText.IsVisible = IsOpen;
        SettingsText.IsVisible = IsOpen;
        //ServerText.IsVisible = IsOpen;
        ModsBrowserText.IsVisible = IsOpen;
        SidebarSplitView.IsPaneOpen = IsOpen;
    }
    // 鼠标进入事件
    private void Sb_in(object? sender, Avalonia.Input.PointerEventArgs e) => MangePaneOpenAndClose(true);
    // 鼠标离开事件
    private void Sb_out(object? sender, Avalonia.Input.PointerEventArgs e) => MangePaneOpenAndClose(false);
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ModsBrowser.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Views.ViewModels;

namespace OneLauncher.Views;

public partial class ModsBrowser : UserControl
{
    public ModsBrowser()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/settings.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.Primitives;
using Avalonia.Markup.Xaml;
using Avalonia.Media;
using OneLauncher.Views.ViewModels;
namespace OneLauncher.Views;

public partial class settings : UserControl
{
    public settings()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/version.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft;
using OneLauncher.Views.ViewModels;
using OneLauncher.Views.Windows;
using OneLauncher.Views.Windows.WindowViewModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http.Headers;
using System.Threading.Tasks;
namespace OneLauncher.Views;

public partial class version : UserControl
{
    public version()
    {
        InitializeComponent();
    }
    /// <summary>
    /// 真·一键启动游戏函数
    /// </summary>
    /// <returns>异步任务Task</returns>
    public static async Task<Task> EasyGameLauncher(
        GameData gameData,
        bool UseGameTasker = false,
        ServerInfo? serverInfo = null
        )
    {
        if (gameData.InstanceId == null)
            return Task.CompletedTask;
        // 用多线程而不是异步，否则某些特定版本会阻塞
        var optionsPath = Path.Combine(gameData.InstancePath, "options.txt");
        if (!File.Exists(optionsPath))
            await File.WriteAllTextAsync(optionsPath, $"lang:zh_CN");
        if (UseGameTasker)
            await Dispatcher.UIThread.InvokeAsync(() =>
            {
                var gameTasker = new GameTasker();
                gameTasker.Show();
            });

        MainWindow.mainwindow.ShowFlyout("正在启动游戏...");
        var game = new Game();
        if(UseGameTasker)
            game.GamePutEvent += (string Message) => WeakReferenceMessenger.Default.Send(new GameMessage(Message));
        game.GameStartedEvent += () => MainWindow.mainwindow.ShowFlyout("游戏已启动！");
        game.GameClosedEvent += () => MainWindow.mainwindow.ShowFlyout("游戏已关闭！");

       return Task.Run(() => game.LaunchGame(
            gameData,serverInfo));
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/account.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="818" d:DesignHeight="530"
             x:Class="OneLauncher.Views.account"
			 xmlns:vm="using:OneLauncher.Views.ViewModels"
			 x:CompileBindings="True"
			 x:DataType="vm:AccountPageViewModel"
			 >
	<SplitView IsPaneOpen="{Binding IsPaneShow,Mode=TwoWay}"
               DisplayMode="Overlay"
               OpenPaneLength="650"
               PanePlacement="Right">
		<SplitView.Pane>
			<TransitioningContentControl Background="{DynamicResource PaneBackgound}" Content="{Binding AccountPane}"/>
		</SplitView.Pane>
		<Grid RowDefinitions="52,Auto,*" Margin="24">
		<StackPanel Margin="16,0,0,0" Orientation="Horizontal" Grid.Row="0" Spacing="28" >
			<TextBlock Grid.Row="0" Text="管理用户登入验证模型" FontSize="36"/>
			<Button Command="{Binding NewUserModelCommand}">
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/add.png" Width="20" Height="20"/>
					<TextBlock Text="新建"/>
				</StackPanel>
			</Button>
			<Button Command="{Binding RefreshCommand}">
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/refresh.png" Width="20" Height="20"/>
					<TextBlock Text="刷新"/>
				</StackPanel>
			</Button>
		</StackPanel>
		<TextBlock Margin="16,0,0,0" Text="*由于第三方API限制正版皮肤显示可能有延迟" FontStyle="Italic" Grid.Row="1"/>
		<ListBox x:Name="navVL" Grid.Row="2" ItemsSource="{Binding UserModelList}" Background="Transparent" SelectionMode="Multiple">
			<ListBox.ItemTemplate>
				<DataTemplate x:DataType="vm:UserItem">
					<Border CornerRadius="5" Padding="5">
						<Grid ColumnDefinitions="Auto,*,Auto" VerticalAlignment="Center">
							<Border Grid.Column="0" CornerRadius="6" ClipToBounds="True">
								<Image Width="64" Height="64" Source="{Binding HeadImg}"/>
							</Border>

							<StackPanel Grid.Column="1" Margin="15,0" VerticalAlignment="Center">
								<TextBlock FontSize="24" Margin="0,-6,0,0" FontWeight="SemiBold" Text="{Binding um.Name}"/>

								<StackPanel Orientation="Horizontal" Spacing="10" Margin="0,5,0,0">
									<TextBlock FontSize="12" Foreground="Gray">
										<Run Text="类型:"/>
										<Run Text="{Binding um}"/>
									</TextBlock>
									<TextBlock FontSize="12" Foreground="Gray">
										<Run Text="UUID:"/>
										<Run Text="{Binding um.uuid}"/>
									</TextBlock>
								</StackPanel>
							</StackPanel>

							<StackPanel Grid.Column="2" Spacing="8" Orientation="Horizontal" VerticalAlignment="Bottom" Margin="6">

								<Border IsVisible="{Binding IsDefault}"
										Background="#EBF5FB" CornerRadius="4" Padding="8,4" VerticalAlignment="Center">
									<TextBlock Text="默认" FontWeight="Bold" Foreground="#3498DB" FontSize="12"/>
								</Border>
								<Button IsVisible="{Binding IsNotDefault}"
										Command="{Binding $parent[ListBox].DataContext.SetDefaultCommand}"
										CommandParameter="{Binding}">
									<StackPanel Orientation="Horizontal" Spacing="6">
										<Image Source="/Assets/icos/pin.png" Width="16" Height="16"/>
										<TextBlock Text="设为默认"/>
									</StackPanel>
								</Button>
								
								<Button IsVisible="{Binding um.IsMsaUser}"
										Command="{Binding $parent[ListBox].DataContext.SkinMangerCommand}"
										CommandParameter="{Binding um}">
									<StackPanel Orientation="Horizontal" Spacing="6">
										<Image Source="/Assets/icos/skin.png" Width="16" Height="16"/>
										<TextBlock Text="皮肤管理"/>
									</StackPanel>
								</Button>							

								<Button Classes="Danger"
										Command="{Binding $parent[ListBox].DataContext.DeleteUserCommand}"
										CommandParameter="{Binding um}">
									<StackPanel Orientation="Horizontal" Spacing="6">
										<Image Source="/Assets/icos/del.png" Width="16" Height="16"/>
										<TextBlock Text="移除" />
									</StackPanel>
								</Button>
							</StackPanel>
						</Grid>
					</Border>
				</DataTemplate>
			</ListBox.ItemTemplate>
			<ListBox.Styles>
				<Style Selector="ListBoxItem">
					<Setter Property="Background" Value="Transparent"/>
					<Setter Property="Padding" Value="5"/>
					<Setter Property="Transitions">
						<Transitions>
							<BrushTransition Property="Background" Duration="0:0:0.23"/>
							<BrushTransition Property="Background" Duration="0:0:0.3" Easing="QuadraticEaseInOut"/>
						</Transitions>
					</Setter>
				</Style>
				<Style Selector="ListBoxItem:pointerover /template/ ContentPresenter">
					<Setter Property="Background" Value="Transparent"/>
					<Setter Property="Opacity" Value="0.95"/>
					<Setter Property="RenderTransform">
						<ScaleTransform ScaleX="1.02" ScaleY="1.02"/>
					</Setter>
				</Style>
				<Style Selector="ListBoxItem:pressed /template/ ContentPresenter">
					<Setter Property="Background" Value="Transparent"/>
				</Style>
				<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
					<Setter Property="Background" Value="Transparent"/>
				</Style>
				<!-- 阴影样式 -->
				<Style Selector="ListBoxItem > Border">
					<Setter Property="ClipToBounds" Value="False"/>
					<Setter Property="Margin" Value="4"/>
					<Setter Property="BoxShadow" Value="0 0 4 1 #22000000"/>
					<Setter Property="Background" Value="{DynamicResource ListBoxItemBackgound}" />
				</Style>
				<Style Selector="ListBoxItem:pointerover > Border">
					<Setter Property="BoxShadow" Value="2 2 8 2 #33000000"/>
				</Style>
				<Style Selector="ListBoxItem:pressed > Border">
					<Setter Property="BoxShadow" Value="1 1 4 1 #22000000"/>
				</Style>
				<!-- 确保内容不被裁剪 -->
				<Style Selector="ListBoxItem > Border">
					<Setter Property="ClipToBounds" Value="False"/>
					<Setter Property="Margin" Value="10"/>
				</Style>
			</ListBox.Styles>
		</ListBox>
	</Grid>
	</SplitView>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/download.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="818" d:DesignHeight="530"
             x:Class="OneLauncher.Views.download"
			 xmlns:vm="using:OneLauncher.Views.ViewModels"
			 xmlns:models="using:OneLauncher.Core.Helper.Models"
			 x:CompileBindings="True"
			 x:DataType="vm:DownloadPageViewModel"
			 >
	<SplitView IsPaneOpen="{Binding IsPaneShow,Mode=TwoWay}"
               DisplayMode="Overlay"
               OpenPaneLength="650"
               PanePlacement="Right"
			   >
		<SplitView.Pane>
			<TransitioningContentControl
				Background="{DynamicResource PaneBackgound}"
					Content="{Binding DownloadPaneContent}">
			</TransitioningContentControl>
		</SplitView.Pane>
		<!-- 版本列表 -->
		<Panel IsEnabled="{Binding IsLoaded}">
			<ScrollViewer>
				<StackPanel 
							Margin="48"
							HorizontalAlignment="Left"
							VerticalAlignment="Center"
							Spacing="4">
					<TextBlock FontSize="42" Text="选择下载版本"/>
					<AutoCompleteBox
						Watermark="搜索版本..."
						Width="300"
						CornerRadius="6"
						ItemsSource="{Binding ReleaseItems}"
						SelectedItem="{Binding SelectedItem}">
						<AutoCompleteBox.ItemTemplate>
							<DataTemplate x:DataType="models:VersionBasicInfo">
								<TextBlock Text="{Binding ID}"/>
							</DataTemplate>
						</AutoCompleteBox.ItemTemplate>
					</AutoCompleteBox>
					<ListBox ItemsSource="{Binding ReleaseItems}" MaxHeight="350" >
						<ListBox.ItemTemplate>
							<DataTemplate x:DataType="models:VersionBasicInfo">
								<Grid ColumnDefinitions="*,Auto" >
									<TextBlock Text="{Binding ID}" Grid.Column="0"/>
									<Button Grid.Column="1" Margin="8,0,8,0" HorizontalAlignment="Right" Content="下载" Command="{Binding $parent[ListBox].DataContext.ToDownloadCommand}" CommandParameter="{Binding}"/>
								</Grid>
							</DataTemplate>
						</ListBox.ItemTemplate>
					</ListBox>
				</StackPanel>
			</ScrollViewer>
		</Panel>
	</SplitView>
</UserControl>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/gamedata.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="OneLauncher.Views.gamedata"
			 xmlns:vm="using:OneLauncher.Views.ViewModels"
			 xmlns:lo="clr-namespace:OneLauncher.Core.Helper.Models;assembly=OneLauncher.Core"
			 xmlns:i="using:Avalonia.Xaml.Interactivity"
             xmlns:ia="using:Avalonia.Xaml.Interactions.Core"
			 x:CompileBindings="True"
			 x:DataType="vm:GameDataPageViewModel">
	<i:Interaction.Behaviors>
		<ia:EventTriggerBehavior EventName="Loaded">
			<ia:InvokeCommandAction Command="{Binding PageLoadedCommand}" />
		</ia:EventTriggerBehavior>
	</i:Interaction.Behaviors>
	<SplitView IsPaneOpen="{Binding IsPaneShow,Mode=TwoWay}"
				 DisplayMode="Overlay"
				 OpenPaneLength="650"
				 PanePlacement="Right">
		<SplitView.Pane>
			<TransitioningContentControl Background="{DynamicResource PaneBackgound}" Content="{Binding PaneContent}"/>
		</SplitView.Pane>
		<Grid RowDefinitions="52,Auto,*" Margin="24">
			<StackPanel Margin="16,0,0,0" Orientation="Horizontal" Grid.Row="0" Spacing="28" >
				<TextBlock Grid.Row="0" Text="游戏数据管理器" FontSize="36"/>
				<Button Command="{Binding NewGameDataCommand}">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/add.png" Width="20" Height="20"/>
						<TextBlock Text="新建"/>
					</StackPanel>
				</Button>
				<Button Margin="-14,0,0,0" Command="{Binding ImportCommand}">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/download.png" Width="20" Height="20"/>
						<TextBlock Text="导入整合包"/>
					</StackPanel>
				</Button>
				<Button Margin="-14,0,0,0" Command="{Binding PowerPlayCommand}">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/internet.png" Width="20" Height="20"/>
						<TextBlock Text="联机"/>
					</StackPanel>
				</Button>
				<Button Margin="-14,0,0,0">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/settings1.png" Width="20" Height="20"/>
						<TextBlock Text="排序"/>
					</StackPanel>
					<Button.Flyout>
						<Flyout>
							<StackPanel>
								<Button Content="按时间排序（旧）"
										Command="{Binding SortingCommand}"
										CommandParameter="{x:Static lo:SortingType.AnTime_OldFront}"/>
								<Button Content="按时间排序（新）"
										Command="{Binding SortingCommand}"
										CommandParameter="{x:Static lo:SortingType.AnTime_NewFront}"/>
								<Button Content="按版本排序（旧）"
										Command="{Binding SortingCommand}"
										CommandParameter="{x:Static lo:SortingType.AnVersion_OldFront}"/>
								<Button Content="按版本排序（新）"
										Command="{Binding SortingCommand}"
										CommandParameter="{x:Static lo:SortingType.AnVersion_NewFront}"/>
							</StackPanel>
						</Flyout>
					</Button.Flyout>
				</Button>
			</StackPanel>
			<ListBox Grid.Row="2" ItemsSource="{Binding GameDataList}" Background="Transparent" SelectionMode="Multiple">
				<ListBox.ItemTemplate>
					<DataTemplate x:DataType="vm:GameDataItem">
						<Border CornerRadius="5">
							<Grid ColumnDefinitions="Auto,*,Auto" VerticalAlignment="Center">
								<Border Grid.Column="0" CornerRadius="6" ClipToBounds="True">
									<Image Width="64" Height="64" Source="{Binding Icon}"/>
								</Border>
								<StackPanel Grid.Column="1" Margin="15,0" VerticalAlignment="Center">
									<TextBlock FontSize="18" FontWeight="SemiBold" Text="{Binding data.Name}"/>

									<StackPanel Orientation="Horizontal" Spacing="10" Margin="0,5,0,0">
										<TextBlock FontSize="12" Foreground="Gray">
											<Run Text="版本:"/>
											<Run Text="{Binding data.VersionId}"/>
										</TextBlock>
										<TextBlock FontSize="12" Foreground="Gray">
											<Run Text="加载器:"/>
											<Run Text="{Binding data.ModLoader}"/>
										</TextBlock>
									</StackPanel>
								</StackPanel>

								<StackPanel Grid.Column="2" Spacing="8" Orientation="Horizontal" VerticalAlignment="Bottom" Margin="6">

									<Border IsVisible="{Binding IsDefault}"
											Background="#FFFBE5" CornerRadius="4" Padding="8,4" VerticalAlignment="Center">
										<TextBlock Text="默认" FontWeight="Bold" Foreground="#D4AC0D" FontSize="12"/>
									</Border>

									<Button IsVisible="{Binding !IsDefault}"
											Command="{Binding $parent[UserControl].DataContext.SetAsDefaultInstanceCommand}"
											CommandParameter="{Binding data}">
										<StackPanel Orientation="Horizontal" Spacing="6">
											<Image Source="/Assets/icos/pin.png" Width="16" Height="16"/>
											<TextBlock Text="设为默认"/>
										</StackPanel>
									</Button>

									<Button Command="{Binding $parent[UserControl].DataContext.ShowEditPaneCommand}" CommandParameter="{Binding data}">
										<StackPanel Orientation="Horizontal" Spacing="6">
											<Image Source="/Assets/icos/edit.png" Width="16" Height="16"/>
											<TextBlock Text="编辑"/>
										</StackPanel>
									</Button>
									<SplitButton Classes="Accent" Command="{Binding LaunchCommand}" CommandParameter="{Binding data}">
										<StackPanel Orientation="Horizontal" Spacing="6">
											<Image Source="/Assets/icos/launch.png" Width="16" Height="16"/>
											<TextBlock Text="启动"/>
										</StackPanel>
										<SplitButton.Flyout>
											<Flyout>
												<CheckBox IsChecked="{Binding IsUseDebugModLaunch}" Content="调试模式启动"/>
											</Flyout>
										</SplitButton.Flyout>
									</SplitButton>
								</StackPanel>
							</Grid>
						</Border>
					</DataTemplate>
				</ListBox.ItemTemplate>
				<ListBox.Styles>
					<Style Selector="ListBoxItem">
						<Setter Property="Background" Value="Transparent"/>
						<Setter Property="Padding" Value="5"/>
						<Setter Property="Transitions">
							<Transitions>
								<BrushTransition Property="Background" Duration="0:0:0.23"/>
								<BrushTransition Property="Background" Duration="0:0:0.3" Easing="QuadraticEaseInOut"/>
							</Transitions>
						</Setter>
					</Style>
					<Style Selector="ListBoxItem:pointerover /template/ ContentPresenter">
						<Setter Property="Background" Value="Transparent"/>
						<Setter Property="Opacity" Value="0.95"/>
						<Setter Property="RenderTransform">
							<ScaleTransform ScaleX="1.02" ScaleY="1.02"/>
						</Setter>
					</Style>
					<Style Selector="ListBoxItem:pressed /template/ ContentPresenter">
						<Setter Property="Background" Value="Transparent"/>
					</Style>
					<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
						<Setter Property="Background" Value="Transparent"/>
					</Style>
					<!-- 阴影样式 -->
					<Style Selector="ListBoxItem > Border">
						<Setter Property="ClipToBounds" Value="False"/>
						<Setter Property="Margin" Value="4"/>
						<Setter Property="BoxShadow" Value="0 0 4 1 #22000000"/>
						<Setter Property="Background" Value="{DynamicResource ListBoxItemBackgound}" />
					</Style>
					<Style Selector="ListBoxItem:pointerover > Border">
						<Setter Property="BoxShadow" Value="2 2 8 2 #33000000"/>
					</Style>
					<Style Selector="ListBoxItem:pressed > Border">
						<Setter Property="BoxShadow" Value="1 1 4 1 #22000000"/>
					</Style>
					<!-- 确保内容不被裁剪 -->
					<Style Selector="ListBoxItem > Border">
						<Setter Property="ClipToBounds" Value="False"/>
						<Setter Property="Margin" Value="10"/>
					</Style>
				</ListBox.Styles>
			</ListBox>
		</Grid>
	</SplitView>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Home.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:OneLauncher.Views.ViewModels"
             xmlns:lo="using:OneLauncher.Core.Helper.Models" mc:Ignorable="d" d:DesignWidth="818" d:DesignHeight="530"
             x:Class="OneLauncher.Home"
             x:DataType="vm:HomePageViewModel"
             x:CompileBindings="True">

	<Grid ColumnDefinitions="*, 300">
		<Panel Grid.Column="1" Background="{DynamicResource PaneBackgound}">
			<StackPanel VerticalAlignment="Center" HorizontalAlignment="Center" Spacing="6">
				<Image Source="/Assets/Imgs/basic.png" Height="128" Width="128"/>

				<ComboBox ItemsSource="{Binding LaunchItems}" SelectedItem="{Binding SelectedGameData}" PlaceholderText="选择启动实例">
					<ComboBox.ItemTemplate>
						<DataTemplate x:DataType="lo:GameData">
							<TextBlock Text="{Binding Name}"/>
						</DataTemplate>
					</ComboBox.ItemTemplate>
				</ComboBox>

				<Button Command="{Binding Launch}" Width="128">
					<StackPanel Orientation="Horizontal" HorizontalAlignment="Center">
						<Image Source="/Assets/icos/launch.png" Width="20" Height="20"/>
						<TextBlock Text="快速游戏"/>
					</StackPanel>
				</Button>
			</StackPanel>
			<Grid VerticalAlignment="Bottom" HorizontalAlignment="Center">
				<ToggleSwitch IsChecked="{Binding IsShowServerOption}">
					<ToggleSwitch.OnContent>
						<TextBlock Text="显示服务端设置"/>
					</ToggleSwitch.OnContent>
					<ToggleSwitch.OffContent>
						<TextBlock Text="不显示服务端设置"/>
					</ToggleSwitch.OffContent>
				</ToggleSwitch>
			</Grid>
		</Panel>
	</Grid>
</UserControl>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/MainWindow.axaml
【代码拼接器】文件内容开始
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:easing="using:Avalonia.Animation.Easings"
        mc:Ignorable="d" d:DesignWidth="860" d:DesignHeight="560"
        x:Class="OneLauncher.Views.MainWindow"
        Icon="/Assets/window-logo.ico"
        Title="OneLauncher"
        TransparencyLevelHint="AcrylicBlur"
        Background="{DynamicResource MainWindowBackground}"
        ExtendClientAreaToDecorationsHint="True"
        Width="880"
        Height="560"
        x:Name="MainWindowLabel">
	<SplitView x:Name="SidebarSplitView"
               IsPaneOpen="False"
               DisplayMode="CompactInline"
               OpenPaneLength="152"
               CompactPaneLength="62"
               PaneBackground="Transparent">
		<SplitView.Pane>
			<Grid Background="Transparent"
                  PointerEntered="Sb_in"
                  PointerExited="Sb_out">
				<ScrollViewer>
					<StackPanel x:Name="SidebarStackPanel"
                                Spacing="20"
                                Margin="-6,24,0,0"
                                HorizontalAlignment="Center"
                                VerticalAlignment="Top">
						<ListBox x:Name="SplitListBox" Background="Transparent" SelectionChanged="ListBox_SelectionChanged">
							<ListBoxItem x:Name="HomeListBoxItem" Tag="Home">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/home.png" Width="32" Height="32"/>
									<TextBlock x:Name="HomeText"
                                               Text="开始菜单"
                                               VerticalAlignment="Center"
                                               FontSize="16"
                                               IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBoxItem x:Name="VersionListBoxItem" Tag="Version">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/version.png" Width="32" Height="32"/>
									<TextBlock x:Name="VersionText"
                                               Text="版本管理"
                                               VerticalAlignment="Center"
                                               FontSize="16"
                                               IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBoxItem x:Name="GameDataListBoxItem" Tag="GameData">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/game.png" Width="32" Height="32"/>
									<TextBlock x:Name="GameDataText"
										 Text="游戏数据"
										 VerticalAlignment="Center"
										 FontSize="16"
										 IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBoxItem x:Name="DownloadListBoxItem" Tag="Download">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/download.png" Width="32" Height="32"/>
									<TextBlock x:Name="DownloadText"
                                               Text="下载管理"
                                               VerticalAlignment="Center"
                                               FontSize="16"
                                               IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBoxItem x:Name="ModsBrowserListBoxItem" Tag="ModsBrowser">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/browser.png" Width="32" Height="32"/>
									<TextBlock x:Name="ModsBrowserText"
                                               Text="模组浏览"
                                               VerticalAlignment="Center"
                                               FontSize="16"
                                               IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBoxItem x:Name="AccountListBoxItem" Tag="Account">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/account.png" Width="32" Height="32"/>
									<TextBlock x:Name="AccountText"
                                               Text="账户管理"
                                               VerticalAlignment="Center"
                                               FontSize="16"
                                               IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBoxItem x:Name="SettingsListBoxItem" Tag="Settings">
								<StackPanel Orientation="Horizontal" Spacing="8">
									<Image Source="/Assets/icos/settings1.png" Width="32" Height="32"/>
									<TextBlock x:Name="SettingsText"
                                               Text="设置选项"
                                               VerticalAlignment="Center"
                                               FontSize="16"
                                               IsVisible="{Binding IsPaneOpen, ElementName=SidebarSplitView}"/>
								</StackPanel>
							</ListBoxItem>
							<ListBox.Styles>
								<Style Selector="ListBox /template/ ContentPresenter">
									<Setter Property="Background" Value="Transparent"/>
									<Setter Property="CornerRadius" Value="16"/>
								</Style>
								<Style Selector="ListBoxItem:pointerover /template/ ContentPresenter">
									<Setter Property="Background" Value="#777777"/>
									<Setter Property="CornerRadius" Value="16"/>
								</Style>
								<Style Selector="ListBoxItem:pressed /template/ ContentPresenter">
									<Setter Property="Background" Value="#666666"/>
									<Setter Property="CornerRadius" Value="16"/>
								</Style>
								<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
									<Setter Property="Background" Value="#555555"/>
									<Setter Property="CornerRadius" Value="24"/>
								</Style>
								<Style Selector="ListBoxItem /template/ ContentPresenter">
									<Setter Property="Margin" Value="8"/>
									<Setter Property="Background" Value="Transparent"/>
									<Setter Property="CornerRadius" Value="16"/>
								</Style>
							</ListBox.Styles>
						</ListBox>
					</StackPanel>
				</ScrollViewer>
			</Grid>
		</SplitView.Pane>

		<Grid RowDefinitions="30,*">
			<Border Grid.Row="0">
				<TextBlock Text="One Launcher"
                           HorizontalAlignment="Left"
                           VerticalAlignment="Center"
                           FontWeight="Bold"
                           Margin="12,0,0,0"/>
			</Border>
			<Panel Grid.Row="1" Margin="0,0,0,0">
				<TransitioningContentControl
                    x:Name="PageContent" Background="{DynamicResource PageBackground}">
					<TransitioningContentControl.PageTransition>
						<PageSlide Orientation="Vertical" Duration="0:00:00.15">
							<PageSlide.SlideInEasing>
								<CubicEaseIn />
							</PageSlide.SlideInEasing>
							<PageSlide.SlideOutEasing>
								<CubicEaseOut />
							</PageSlide.SlideOutEasing>
						</PageSlide>
					</TransitioningContentControl.PageTransition>
				</TransitioningContentControl>
				<Border x:Name="FytB"
                        IsVisible="False"
                        Margin="16"
                        Background="LightBlue"
                        HorizontalAlignment="Right"
                        VerticalAlignment="Bottom"
                        CornerRadius="5" >
					<TextBlock Margin="6" x:Name="FytFkA"/>
				</Border>
			</Panel>
		</Grid>
	</SplitView>
</Window>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ModsBrowser.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="OneLauncher.Views.ModsBrowser"
			 xmlns:asyncImageLoader="clr-namespace:AsyncImageLoader;assembly=AsyncImageLoader.Avalonia"
			 xmlns:vm="using:OneLauncher.Views.ViewModels"
			 x:CompileBindings="True"
			 x:DataType="vm:ModsBrowserViewModel"
			 >
	<SplitView IsPaneOpen="{Binding IsPaneShow,Mode=TwoWay}"
               DisplayMode="Overlay"
               OpenPaneLength="650"
               PanePlacement="Right">
		<SplitView.Pane>
			<TransitioningContentControl
				Background="{DynamicResource PaneBackgound}"
					Content="{Binding InstallModPaneContent}">
			</TransitioningContentControl>
		</SplitView.Pane>
		<ScrollViewer>
			<StackPanel>
				<StackPanel Margin="12" Orientation="Horizontal" VerticalAlignment="Top" Spacing="8">
					<TextBox Watermark="搜索模组..." Width="300" 
							 Text="{Binding SearchContent}">
						<TextBox.KeyBindings>
							<KeyBinding Gesture="Enter" Command="{Binding ToSearchCommand}" />
						</TextBox.KeyBindings>
					</TextBox>
					<Button Command="{Binding ToSearchCommand}">
						<StackPanel Orientation="Horizontal">
							<Image Source="/Assets/icos/search.png" Width="20" Height="20"/>
							<TextBlock Text="搜索"/>
						</StackPanel>
					</Button>
				</StackPanel>
				<ListBox ItemsSource="{Binding SearchItems}" Background="Transparent">
					<ListBox.ItemTemplate>
						<DataTemplate x:DataType="vm:ModItem">
							<Border CornerRadius="5">
								<Grid RowDefinitions="*,*" ColumnDefinitions="100,*,Auto" >
									<Border Grid.Column="0" Grid.RowSpan="2" VerticalAlignment="Center" >
										<Image Width="72" Height="72" asyncImageLoader:ImageLoader.Source="{Binding IconUrl}"/>
									</Border>
									<TextBlock TextWrapping="Wrap" Grid.Row="0" Margin="6" Grid.Column="1" FontSize="18" Text="{Binding Title}" FontWeight="Bold"/>
									<TextBlock TextWrapping="Wrap" Margin="4,8,0,0" Grid.Row="1" Grid.Column="1"  Text="{Binding Description}"/>
									<Button Grid.Row="1" Grid.Column="2" HorizontalAlignment="Right" Command="{Binding $parent[ListBox].DataContext.ToInstallModCommand}" CommandParameter="{Binding}">
										<StackPanel Orientation="Horizontal">
											<TextBlock Text="安装"/>
										</StackPanel>
									</Button>
								</Grid>
							</Border>
						</DataTemplate>
					</ListBox.ItemTemplate>
					<ListBox.Styles>
						<Style Selector="ListBoxItem">
							<Setter Property="Background" Value="Transparent"/>
							<Setter Property="Padding" Value="5"/>
							<Setter Property="Transitions">
								<Transitions>
									<BrushTransition Property="Background" Duration="0:0:0.23"/>
									<BrushTransition Property="Background" Duration="0:0:0.3" Easing="QuadraticEaseInOut"/>
								</Transitions>
							</Setter>
						</Style>
						<Style Selector="ListBoxItem:pointerover /template/ ContentPresenter">
							<Setter Property="Background" Value="Transparent"/>
							<Setter Property="Opacity" Value="0.95"/>
							<Setter Property="RenderTransform">
								<ScaleTransform ScaleX="1.02" ScaleY="1.02"/>
							</Setter>
						</Style>
						<Style Selector="ListBoxItem:pressed /template/ ContentPresenter">
							<Setter Property="Background" Value="Transparent"/>
						</Style>
						<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
							<Setter Property="Background" Value="Transparent"/>
						</Style>
						<!-- 阴影样式 -->
						<Style Selector="ListBoxItem > Border">
							<Setter Property="ClipToBounds" Value="False"/>
							<Setter Property="Margin" Value="4"/>
							<Setter Property="BoxShadow" Value="0 0 4 1 #22000000"/>
							<Setter Property="Background" Value="{DynamicResource ListBoxItemBackgound}" />
						</Style>
						<Style Selector="ListBoxItem:pointerover > Border">
							<Setter Property="BoxShadow" Value="2 2 8 2 #33000000"/>
						</Style>
						<Style Selector="ListBoxItem:pressed > Border">
							<Setter Property="BoxShadow" Value="1 1 4 1 #22000000"/>
						</Style>
						<!-- 确保内容不被裁剪 -->
						<Style Selector="ListBoxItem > Border">
							<Setter Property="ClipToBounds" Value="False"/>
							<Setter Property="Margin" Value="10"/>
						</Style>
					</ListBox.Styles>
				</ListBox>
			</StackPanel>
		</ScrollViewer>
	</SplitView>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/settings.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="818" d:DesignHeight="530"
			 xmlns:vm="using:OneLauncher.Views.ViewModels"
			 x:DataType="vm:SettingsPageViewModel"
			 x:CompileBindings="True"
             x:Class="OneLauncher.Views.settings">
  <ScrollViewer>
	  <StackPanel Margin="64" Spacing="36">
		  <!-- 游戏启动选项 -->
		  <StackPanel Spacing="8" HorizontalAlignment="Left">
			  <TextBlock FontSize="24" FontWeight="Bold" Text="游戏启动选项"/>
			  <Separator Margin="-4,0,0,0"/>
			  <StackPanel Margin="0,6,0,0">
				  <TextBlock Text="Jvm参数优化选项"/>
				  
				  <RadioButton IsChecked="{Binding IsM1}" Margin="0,4,0,0" GroupName="JvmMode" Content="保守模式"/>
				  <RadioButton IsChecked="{Binding IsM2}" GroupName="JvmMode" Content="标准模式" />
				  <RadioButton IsChecked="{Binding IsM3}" GroupName="JvmMode" Content="激进模式" />
				  
			  </StackPanel>
		  </StackPanel>
		  <!-- 下载选项 -->
		  <StackPanel Spacing="8" HorizontalAlignment="Left">
			  <TextBlock FontSize="24" FontWeight="Bold" Text="下载选项"/>
			  <Separator Margin="-4,0,0,0"/>
			  <StackPanel Margin="0,6,0,0">
				  <TextBlock Text="最大下载线程："/>
				  <NumericUpDown Value="{Binding MaxDownloadThreadsValue}" Minimum="1" Maximum="128" Width="150"/>
			  </StackPanel>
			  <StackPanel Margin="0,16,0,0">
				  <TextBlock Text="最大Sha1校验线程："/>
				  <NumericUpDown Value="{Binding MaxSha1ThreadsValue}" Minimum="1" Maximum="128" Width="150"/>
				  <TextBlock Text="是否校验Sha1" Margin="0,8,0,0"/>
				  <ToggleSwitch IsChecked="{Binding IsSha1Enabled}">
					  <ToggleSwitch.OnContent>
						  <TextBlock Text="校验Sha1"/>
					  </ToggleSwitch.OnContent>
					  <ToggleSwitch.OffContent>
						  <TextBlock Text="不再校验Sha1"/>
					  </ToggleSwitch.OffContent>
				  </ToggleSwitch>
				  <TextBlock Text="允许连接 BMLCAPI" Margin="0,8,0,0"/>
				  <ToggleSwitch IsChecked="{Binding IsAllowUseBMLCAPI}">
					  <ToggleSwitch.OnContent>
						  <TextBlock Text="使用BMLC API"/>
					  </ToggleSwitch.OnContent>
					  <ToggleSwitch.OffContent>
						  <TextBlock Text="不使用"/>
					  </ToggleSwitch.OffContent>
				  </ToggleSwitch>
			  </StackPanel>
		  </StackPanel>
	  </StackPanel>
  </ScrollViewer>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/version.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="1070" d:DesignHeight="620"
             x:Class="OneLauncher.Views.version"
			 xmlns:vm="clr-namespace:OneLauncher.Views.ViewModels;assembly=OneLauncher"
			 xmlns:lo="clr-namespace:OneLauncher.Core.Helper.Models;assembly=OneLauncher.Core"
			 x:CompileBindings="True"
			 x:DataType="vm:VersionPageViewModel"
			 xmlns:i="using:Avalonia.Xaml.Interactivity"
             xmlns:ia="using:Avalonia.Xaml.Interactions.Core"
			 >
	<i:Interaction.Behaviors>
		<ia:EventTriggerBehavior EventName="Loaded">
			<ia:InvokeCommandAction Command="{Binding PageLoadedCommand}" />
		</ia:EventTriggerBehavior>
	</i:Interaction.Behaviors>
	<SplitView IsPaneOpen="{Binding IsPaneShow,Mode=TwoWay}"
               DisplayMode="Overlay"
               OpenPaneLength="650"
               PanePlacement="Right">
		<SplitView.Pane>
			<TransitioningContentControl Background="{DynamicResource PaneBackgound}" Content="{Binding RefDownPane}"/>
		</SplitView.Pane>
		<Grid RowDefinitions="52,*" Margin="24">
		<StackPanel Margin="9,0,0,0" Orientation="Horizontal" Grid.Row="0" Spacing="28" >
			<TextBlock Grid.Row="0" Text="管理你的游戏版本" FontSize="36"/>
			<Button>
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/settings1.png" Width="20" Height="20"/>
					<TextBlock Text="排序"/>
				</StackPanel>
				<Button.Flyout>
					<Flyout>
						<StackPanel>
							<Button Content="按时间排序（旧）"
									Command="{Binding SortingCommand}"
									CommandParameter="{x:Static lo:SortingType.AnTime_OldFront}"/>
							<Button Content="按时间排序（新）"
									Command="{Binding SortingCommand}"
									CommandParameter="{x:Static lo:SortingType.AnTime_NewFront}"/>
							<Button Content="按版本排序（旧）"
									Command="{Binding SortingCommand}"
									CommandParameter="{x:Static lo:SortingType.AnVersion_OldFront}"/>
							<Button Content="按版本排序（新）"
									Command="{Binding SortingCommand}"
									CommandParameter="{x:Static lo:SortingType.AnVersion_NewFront}"/>
						</StackPanel>
					</Flyout>
				</Button.Flyout>
			</Button>
			<!--
			<Button Command="{Binding GoToDownloadCommand}" Margin="-14,0,0,0">
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/download.png" Width="20" Height="20"/>
					<TextBlock Text="转到下载"/>
				</StackPanel>
			</Button>
			
			<Button Command="{Binding ImportVersionByPCL2Command}" Margin="-14,0,0,0">
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/download.png" Width="20" Height="20"/>
					<TextBlock Text="从PCL2导入版本"/>
				</StackPanel>
			</Button>
			-->
		</StackPanel>
		<ListBox x:Name="navVL" Grid.Row="1" ItemsSource="{Binding VersionList,Mode=TwoWay}" Background="Transparent" SelectionMode="Multiple">
			<ListBox.ItemTemplate>
				<DataTemplate x:DataType="vm:VersionItem">
					<Border CornerRadius="5">
						<Grid RowDefinitions="*,*" Margin="12,0,0,0" ColumnDefinitions="Auto,*" >
							<StackPanel Grid.Row="0" Grid.Column="1" Orientation="Horizontal" Spacing="4">
								<TextBlock FontSize="24" Text="{Binding versionExp.VersionID}" FontWeight="Bold"/>
							</StackPanel>
							<TextBlock Margin="0,8,0,0" Grid.Row="1" Grid.Column="1"  Text="{Binding versionExp.AddTime}"/>
							<StackPanel Spacing="4" Margin="0,0,8,2" Grid.Row="1" Grid.Column="2" HorizontalAlignment="Right" Orientation="Horizontal" >
								<Button Command="{Binding LaunchGameCommand}" CommandParameter="{Binding versionExp}">
									<StackPanel Orientation="Horizontal" Spacing="2">
										<Image Source="/Assets/icos/launch.png" Width="20" Height="20"/>
										<TextBlock Text="根启动"/>
									</StackPanel>
								</Button>
								<Button>
									<StackPanel Orientation="Horizontal">
										<Image Source="/Assets/icos/settings1.png" Width="20" Height="20"/>
										<TextBlock Text="操作"/>
									</StackPanel>
									<Button.Flyout>
										<MenuFlyout>
											<MenuItem>
												<MenuItem.Header>
													<StackPanel Orientation="Horizontal">
														<Image Source="/Assets/icos/server.png" Width="20" Height="20"/>
														<TextBlock Text="服务端..." />
													</StackPanel>
												</MenuItem.Header>
												<MenuItem Command="{Binding $parent[ListBox].DataContext.OpenServerCommand}" CommandParameter="{Binding versionExp}">
													<MenuItem.Header>
														<StackPanel Orientation="Horizontal">
															<Image Source="/Assets/icos/launch.png" Width="20" Height="20"/>
															<TextBlock Text="一键开服"/>
														</StackPanel>
													</MenuItem.Header>
												</MenuItem>
												<MenuItem Command="{Binding OpenServerFolderCommand}">
													<MenuItem.Header>
														<StackPanel Orientation="Horizontal">
															<Image Source="/Assets/icos/browser.png" Width="20" Height="20"/>
															<TextBlock Text="打开服务端文件夹"/>
														</StackPanel>
													</MenuItem.Header>
												</MenuItem>
											</MenuItem>
											<MenuItem Command="{Binding ReadMoreInformationsCommand}">
												<MenuItem.Header>
													<StackPanel Orientation="Horizontal">
														<Image Source="/Assets/icos/browser.png" Width="20" Height="20"/>
														<TextBlock Text="查看详细信息" />
													</StackPanel>
												</MenuItem.Header>
											</MenuItem>
										</MenuFlyout>
									</Button.Flyout>
								</Button>
							</StackPanel>
						</Grid>
					</Border>
				</DataTemplate>
			</ListBox.ItemTemplate>
			<ListBox.Styles>
				<Style Selector="ListBoxItem">
					<Setter Property="Background" Value="Transparent"/>
					<Setter Property="Padding" Value="5"/>
					<Setter Property="Transitions">
						<Transitions>
							<BrushTransition Property="Background" Duration="0:0:0.23"/>
							<BrushTransition Property="Background" Duration="0:0:0.3" Easing="QuadraticEaseInOut"/>
						</Transitions>
					</Setter>
				</Style>
				<Style Selector="ListBoxItem:pointerover /template/ ContentPresenter">
					<Setter Property="Background" Value="Transparent"/>
					<Setter Property="Opacity" Value="0.95"/>
					<Setter Property="RenderTransform">
						<ScaleTransform ScaleX="1.02" ScaleY="1.02"/>
					</Setter>
				</Style>
				<Style Selector="ListBoxItem:pressed /template/ ContentPresenter">
					<Setter Property="Background" Value="Transparent"/>
				</Style>
				<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
					<Setter Property="Background" Value="Transparent"/>
				</Style>
				<!-- 阴影样式 -->
				<Style Selector="ListBoxItem > Border">
					<Setter Property="ClipToBounds" Value="False"/>
					<Setter Property="Margin" Value="4"/>
					<Setter Property="BoxShadow" Value="0 0 4 1 #22000000"/>
					<Setter Property="Background" Value="{DynamicResource ListBoxItemBackgound}" />
				</Style>
				<Style Selector="ListBoxItem:pointerover > Border">
					<Setter Property="BoxShadow" Value="2 2 8 2 #33000000"/>
				</Style>
				<Style Selector="ListBoxItem:pressed > Border">
					<Setter Property="BoxShadow" Value="1 1 4 1 #22000000"/>
				</Style>
				<!-- 确保内容不被裁剪 -->
				<Style Selector="ListBoxItem > Border">
					<Setter Property="ClipToBounds" Value="False"/>
					<Setter Property="Margin" Value="10"/>
				</Style>
			</ListBox.Styles>
		</ListBox>
	</Grid>
	</SplitView>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/DownloadPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core.Helper;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.ViewModels;
using OneLauncher.Views.Windows;

namespace OneLauncher.Views.Panes;
internal partial class DownloadPane : UserControl
{
    // 以后别他妈的打DEBUG了，傻逼编译器报错
//#if DEBUG
    // 供设计器预览
    public DownloadPane()
    {
        InitializeComponent();
    }

}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/EditGameDataPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core.Helper;
using OneLauncher.Views.Panes.PaneViewModels;

namespace OneLauncher.Views.Panes;

public partial class EditGameDataPane : UserControl
{
    public EditGameDataPane()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/InitServerPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Views.Panes.PaneViewModels;

namespace OneLauncher.Views.Panes;

public partial class InitServerPane : UserControl
{

    public InitServerPane()
    {
        InitializeComponent();
#if DEBUG
        this.DataContext = new InitServerPaneViewModel();
#endif
    }
    public InitServerPane(string version)
    {
        InitializeComponent();
        this.DataContext = new InitServerPaneViewModel(version);
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/InstallModPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.ViewModels;

namespace OneLauncher.Views.Panes;

internal partial class InstallModPane : UserControl
{

    public InstallModPane()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/NewGameDataPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Views.Panes.PaneViewModels;

namespace OneLauncher.Views.Panes;

public partial class NewGameDataPane : UserControl
{
    public NewGameDataPane()
    {
        InitializeComponent();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PowerPlayPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Views.Panes.PaneViewModels;
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes;

public partial class PowerPlayPane : UserControl
{
    public PowerPlayPane()
    {
        InitializeComponent();
        //_=InitializationAsync();
    }
    //private async Task InitializationAsync()
    //{
    //    {
    //        if(!File.Exists(Path.Combine(Init.BasePath,"installed","main.exe")))
    //            MainWindow.mainwindow.ShowFlyout("正在初始化联机模块...");
    //        try
    //        {
    //            var viewmodel = await PowerPlayPaneViewModel.CreateAsync();
    //            this.DataContext = viewmodel;
    //        }
    //        catch (OlanException ex)
    //        {
    //            await OlanExceptionWorker.ForOlanException(ex);
    //        }
    //        catch (Exception ex)
    //        {
    //            await OlanExceptionWorker.ForUnknowException(ex);
    //        }
    //    }
    //}
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/SkinMangerPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.ViewModels;

namespace OneLauncher.Views.Panes;

internal partial class SkinMangerPane : UserControl
{
    public SkinMangerPane()
    {
        InitializeComponent();
#if DEBUG
        this.DataContext = new SkinMangerPaneViewModel();
#endif
    }
    public SkinMangerPane(AccountPageViewModel accountPageViewModel, UserModel SelUserModel)
    {
        InitializeComponent();
        this.DataContext = new SkinMangerPaneViewModel(accountPageViewModel, SelUserModel);
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/UserModelLoginPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.ViewModels;

namespace OneLauncher.Views.Panes;

internal partial class UserModelLoginPane : UserControl
{
    public UserModelLoginPane()
    {
        InitializeComponent();
#if DEBUG
        this.DataContext = new UserModelLoginPaneViewModel();
#endif
    }
    public UserModelLoginPane(AccountPageViewModel accountPageViewModel)
    {
        InitializeComponent();
        this.DataContext = new UserModelLoginPaneViewModel(accountPageViewModel);
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/DownloadPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="650" d:DesignHeight="620"
			 xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
			 x:DataType="vm:DownloadPaneViewModel"
			 x:CompileBindings="True"
             x:Class="OneLauncher.Views.Panes.DownloadPane">
	<Grid RowDefinitions="Auto,1,*" VerticalAlignment="Top" Margin="12">
		<!-- 标题栏 -->
		<StackPanel Grid.Row="0" Orientation="Horizontal" Spacing="8">
			<Button Command="{Binding ClosePaneCommand}">
				<StackPanel Orientation="Horizontal" Spacing="8">
					<Image Source="/Assets/icos/back.png" Width="20" Height="20"/>
					<TextBlock Text="返回" VerticalAlignment="Center"/>
				</StackPanel>
			</Button>
			<Button Command="{Binding PopUpCommand}">
				<StackPanel Orientation="Horizontal" Spacing="8">
					<Image Source="/Assets/icos/internet.png" Width="20" Height="20"/>
					<TextBlock Text="弹出" VerticalAlignment="Center"/>
				</StackPanel>
			</Button>
		</StackPanel>
		<TextBlock FontSize="52" HorizontalAlignment="Center" Grid.Row="0" Text="{Binding VersionName}"/>
		<StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0,6,0,0" HorizontalAlignment="Right" Spacing="8">
			<Button 
				x:Name="ToDownloadButton"
				Command="{Binding ToDownloadCommand}"
				IsEnabled="{Binding IsAllowDownloading}">
				<StackPanel Orientation="Horizontal" Spacing="8">
					<Image Source="/Assets/icos/downloadnow.png" Width="20" Height="20"/>
					<TextBlock 
							   Text="下载版本"
							   VerticalAlignment="Center"/>
				</StackPanel>
			</Button>
			<Button
				Command="{Binding ToCancellationDownloadTaskCommand}"
				IsEnabled="{Binding !#ToDownloadButton.IsEnabled}">
				<StackPanel Orientation="Horizontal" Spacing="8">
					<Image Source="/Assets/icos/error.png" Width="29" Height="20"/>
					<TextBlock 
							   Text="取消任务"
							   VerticalAlignment="Center"/>
				</StackPanel>
			</Button>
		</StackPanel>
		<!-- 下载按钮和进度条 -->
		<Separator Grid.Row="1" Margin="0,24,0,52" Background="#252423"/>
		<Grid Grid.Row="2" Margin="0,-24,0,0" >
			<!-- 给模组添加预留控件 -->
			<StackPanel>
				<!-- 模组安装选项 -->
				<StackPanel Orientation="Horizontal" Spacing="61">
					<CheckBox IsEnabled="{Binding IsAllowFabric}" IsChecked="{Binding IsMod}" >是否带Fabric</CheckBox>
					<CheckBox IsVisible="{Binding IsMod}" IsChecked="{Binding IsDownloadFabricWithAPI}">同时下载Fabric API</CheckBox>
				</StackPanel>
				<StackPanel Orientation="Horizontal" Spacing="36">
					<CheckBox IsEnabled="{Binding IsAllowNeoforge}" IsChecked="{Binding IsNeoForge}" >是否带NeoForge</CheckBox>
					<CheckBox IsVisible="{Binding IsNeoForge}" IsChecked="{Binding IsAllowToUseBetaNeoforge}">允许下载Beta版</CheckBox>
				</StackPanel>
				<StackPanel Orientation="Horizontal" Spacing="36">
					<CheckBox IsEnabled="{Binding IsAllowForge}" IsChecked="{Binding IsForge}" >是否带Forge（预览版）</CheckBox>
					<CheckBox IsVisible="{Binding IsForge}" IsChecked="{Binding IsUseRecommendedToInstallForge}">使用推荐版</CheckBox>
				</StackPanel>
				<!-- 额外设置 -->
				<CheckBox IsChecked="{Binding IsJava}">是否安装合适Java</CheckBox>
				<StackPanel Margin="0,12,0,0" Orientation="Horizontal" Spacing="8">
					<TextBlock Text="{Binding Dp}"/>
					<TextBlock Text="{Binding Fs}"/>
				</StackPanel>
				<TextBlock Text="{Binding FileName}"/>
				<ProgressBar  
					Margin="0 10" Height="20"
					Minimum="0" Maximum="100" Value="{Binding CurrentProgress}"
					ShowProgressText="True"/>
			</StackPanel>
		</Grid>
	</Grid>
</UserControl>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/EditGameDataPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
             x:Class="OneLauncher.Views.Panes.EditGameDataPane"
             x:DataType="vm:EditGameDataPaneViewModel"
			 x:CompileBindings="True"
			 d:DesignWidth="650" d:DesignHeight="620"
			 >
	<StackPanel Spacing="15" Margin="20">
		<Grid ColumnDefinitions="*,*,*">
			<StackPanel Orientation="Horizontal" Grid.Column="0" Margin="12,0,0,0" Spacing="12">
				<Button Command="{Binding CancelCommand}">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/back.png" Height="20" Width="20"/>
						<TextBlock Text="返回"/>
					</StackPanel>
				</Button>
				<Button Command="{Binding SaveCommand}">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/save.png" Height="20" Width="20"/>
						<TextBlock Text="保存"/>
					</StackPanel>
				</Button>
			</StackPanel>
			<TextBlock Grid.Column="1" Text="编辑游戏数据" FontSize="24" FontWeight="Bold" HorizontalAlignment="Center"/>
		</Grid>
		<Separator/>
		<Border CornerRadius="10" Width="100" Height="100" ClipToBounds="True" HorizontalAlignment="Center">
			<Image Source="{Binding CurrentIcon}" Stretch="UniformToFill"/>
		</Border>
		<Button Content="更换图标" Command="{Binding ChangeIconCommand}" HorizontalAlignment="Center"/>
		<TextBlock Text="实例名称"/>
		<TextBox Text="{Binding InstanceName}"/>
		<TextBlock Text="高级操作"/>
		<Button Content="打开实例文件夹" Command="{Binding OpenInstanceFolderCommand}" />
		<Button Content="在桌面快速启动" Command="{Binding AddToQuicklyPlayCommand}" />
		<Grid ColumnDefinitions="*,*" Margin="0,20,0,0">
			<Button Command="{Binding DeleteInstanceCommand}">
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/del.png" Height="20" Width="20"/>
					<TextBlock Text="移除此游戏数据"/>
				</StackPanel>
			</Button>
		</Grid>
	</StackPanel>
</UserControl>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/InitServerPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
			 xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
			 x:DataType="vm:InitServerPaneViewModel"
			 x:CompileBindings="True"
             mc:Ignorable="d" d:DesignWidth="650" d:DesignHeight="620"
             x:Class="OneLauncher.Views.Panes.InitServerPane">
	<Grid RowDefinitions="80,*">
		<Panel Grid.Row="0">
			<StackPanel Orientation="Horizontal"  HorizontalAlignment="Left" VerticalAlignment="Top" Margin="24" Spacing="4">
				<Button>
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/back.png" Width="20" Height="20"/>
						<TextBlock Text="返回" />
					</StackPanel>
				</Button>
				<Button Command="{Binding ToInstallServerCommand}">
					<StackPanel Orientation="Horizontal">
						<Image Source="/Assets/icos/downloadnow.png" Width="20" Height="20"/>
						<TextBlock Text="继续" />
					</StackPanel>
				</Button>
			</StackPanel>
			<TextBlock FontSize="36" Margin="0,-6,0,0" Text="服务器初始化向导" HorizontalAlignment="Center" VerticalAlignment="Center"/>
		</Panel>
		<StackPanel Grid.Row="1" VerticalAlignment="Top" Margin="24" Spacing="36">
			<StackPanel>
				<TextBlock FontSize="24" Text="安装选项"/>
				<CheckBox IsChecked="{Binding IsVI}" Margin="0,12,0,0">启用服务端版本隔离</CheckBox>
			</StackPanel>
			<StackPanel>
				<TextBlock FontSize="24" Text="协议"/>
				<CheckBox IsChecked="{Binding IsAgreeMinecraftEULA,Mode=TwoWay}" Margin="0,12,0,0">我同意Minecraft最终用户许可协议</CheckBox>
				<Button Command="{Binding ReadMinecraftEULACommand}" Content="查看协议内容"/>
			</StackPanel>
		</StackPanel>
	</Grid>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/InstallModPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
			 xmlns:lo="using:OneLauncher.Core.Helper.Models"
             mc:Ignorable="d" d:DesignWidth="650" d:DesignHeight="620"
             x:Class="OneLauncher.Views.Panes.InstallModPane"
			 xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
			 x:DataType="vm:InstallModPaneViewModel"
			 x:CompileBindings="True"
			 >
	<Grid RowDefinitions="Auto,1,*" VerticalAlignment="Top" Margin="12">
		<!-- 标题栏 -->
		<StackPanel Grid.Row="0" Orientation="Horizontal" Spacing="8">
			<Button Command="{Binding $parent[UserControl].DataContext.ClosePaneCommand}">
				<StackPanel Orientation="Horizontal" Spacing="8">
					<Image Source="/Assets/icos/back.png" Width="20" Height="20"/>
					<TextBlock Text="返回" VerticalAlignment="Center"/>
				</StackPanel>
			</Button>
		</StackPanel>
		<TextBlock TextWrapping="Wrap" FontSize="32" HorizontalAlignment="Center" Grid.Row="0" Text="{Binding ModName}"/>
		<!-- 下载按钮和进度条 -->
		<Separator Grid.Row="1" Margin="0,24,0,52" Background="#252423"/>
		<Grid RowDefinitions="*,*" Grid.Row="2" Margin="0,0,0,0" >
			<ScrollViewer Grid.Row="0">
				<StackPanel Margin="24,8" Spacing="6">
					<TextBlock Text="安装到哪个游戏数据？" FontSize="20" FontWeight="Bold"/>
					<StackPanel Orientation="Horizontal" Spacing="6" >
						<ComboBox ItemsSource="{Binding AvailableGameData}"
								  SelectedItem="{Binding SelectedGameData}"
								  PlaceholderText="请选择要安装到的游戏实例..."
								  Margin="0,10,0,0">
							<ComboBox.ItemTemplate>
								<DataTemplate x:DataType="lo:GameData">
									<TextBlock Text="{Binding Name}" />
								</DataTemplate>
							</ComboBox.ItemTemplate>
						</ComboBox>
						<CheckBox IsChecked="{Binding IsICS}">下载依赖</CheckBox>
						<Button Command="{Binding ToInstallCommand}" Content="安装"/>
					</StackPanel>
					<Panel IsVisible="{Binding IsShowMoreInfo}">
						<TextBlock FontSize="18" Text="支持的版本："/>
						<ListBox ItemsSource="{Binding SupportVersions}">
							<ListBox.Styles>
								<Style Selector="ListBoxItem:pointerover /template/ ContentPresenter">
									<Setter Property="Background" Value="Transparent"/>
								</Style>
								<Style Selector="ListBoxItem:pressed /template/ ContentPresenter">
									<Setter Property="Background" Value="Transparent"/>
								</Style>
								<Style Selector="ListBoxItem:selected /template/ ContentPresenter">
									<Setter Property="Background" Value="Transparent"/>
								</Style>
							</ListBox.Styles>
						</ListBox>
					</Panel>
				</StackPanel>
			</ScrollViewer>
			<StackPanel Grid.Row="1">
				<StackPanel Orientation="Horizontal" Spacing="8">
					<TextBlock Text="{Binding Dp}"/>
					<TextBlock Text="{Binding Fs}"/>
				</StackPanel>
				<ProgressBar
					Margin="0 10" Height="20"
					Minimum="0" Maximum="100" Value="{Binding CurrentProgress}"
					ShowProgressText="True"/>
			</StackPanel>
		</Grid>
	</Grid>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/NewGameDataPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
			 xmlns:lo="clr-namespace:OneLauncher.Core.Helper.Models;assembly=OneLauncher.Core"
             mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="500"
			 x:DataType="vm:NewGameDataPaneViewModel"
			 x:CompileBindings="True"
             x:Class="OneLauncher.Views.Panes.NewGameDataPane">
	<StackPanel Spacing="15" Margin="20">
		<TextBlock Text="新建游戏数据" FontSize="24" FontWeight="Bold" HorizontalAlignment="Center"/>

		<TextBlock Text="第一步：选择基础版本"/>
		<ComboBox ItemsSource="{Binding AvailableBaseVersions}"
				  SelectedItem="{Binding SelectedBaseVersion}"
				  PlaceholderText="请选择...">
			<ComboBox.ItemTemplate>
				<DataTemplate x:DataType="lo:UserVersion">
					<TextBlock Text="{Binding VersionID}" />
				</DataTemplate>
			</ComboBox.ItemTemplate>
		</ComboBox>

		<TextBlock Text="第二步：填写实例信息"/>
		<TextBox Text="{Binding GameDataName}" IsEnabled="{Binding SelectedBaseVersion, Converter={x:Static ObjectConverters.IsNotNull}}" Watermark="例如：我的整合包"/>

		<TextBlock Text="模组加载器"/>
		<ComboBox ItemsSource="{Binding AvailableModLoaders}"
				  SelectedItem="{Binding SelectedModLoader}"
				  IsEnabled="{Binding SelectedBaseVersion, Converter={x:Static ObjectConverters.IsNotNull}}">
			<ComboBox.ItemTemplate>
				<DataTemplate x:DataType="lo:ModEnum">
					<TextBlock Text="{Binding Converter={StaticResource ModEnumConverter}}"/>
				</DataTemplate>
			</ComboBox.ItemTemplate>
		</ComboBox>

		<TextBlock Text="默认用户"/>
		<ComboBox ItemsSource="{Binding AvailableUsers}"
				  SelectedItem="{Binding SelectedUser}"
				  IsEnabled="{Binding SelectedBaseVersion, Converter={x:Static ObjectConverters.IsNotNull}}">
			<ComboBox.ItemTemplate>
				<DataTemplate>
					<TextBlock Text="{Binding Name}"/>
				</DataTemplate>
			</ComboBox.ItemTemplate>
		</ComboBox>

		<Grid ColumnDefinitions="*,*" Margin="0,20,0,0">
			<Button Grid.Column="0" Content="创建" Command="{Binding SaveCommand}" HorizontalAlignment="Stretch" Margin="0,0,5,0"/>
			<Button Grid.Column="1" Content="取消" Command="{Binding CancelCommand}" HorizontalAlignment="Stretch" Margin="5,0,0,0"/>
		</Grid>
	</StackPanel>
</UserControl>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PowerPlayPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
             mc:Ignorable="d" d:DesignWidth="650" d:DesignHeight="620"
             x:DataType="vm:PowerPlayPaneViewModel"
			 x:CompileBindings="True"
             x:Class="OneLauncher.Views.Panes.PowerPlayPane">

	<Grid RowDefinitions="Auto, 1, Auto, *" Margin="15">

		<Grid Grid.Row="0" ColumnDefinitions="*, Auto">
			<TextBlock Grid.Column="0" Text="联机助手" FontSize="20" FontWeight="Bold"
                       HorizontalAlignment="Center" VerticalAlignment="Center"/>

			<StackPanel Grid.Column="1" Orientation="Horizontal" Spacing="10">
				<Panel IsVisible="{Binding !IsConnected}">
					<Button Content="创建房间" IsEnabled="{Binding CanStart}" Command="{Binding HostCommand}" IsVisible="{Binding IsHostModeChecked}"/>
					<Button Content="加入并启动游戏" IsEnabled="{Binding CanStart}" Command="{Binding JoinAndLaunchCommand}" IsVisible="{Binding IsJoinModeChecked}"/>
				</Panel>
				<Button Content="断开连接" IsEnabled="{Binding CanStop}" Background="IndianRed" Command="{Binding StopCommand}" IsVisible="{Binding IsConnected}"/>
			</StackPanel>
		</Grid>

		<Separator Grid.Row="1" Margin="0,10"/>

		<StackPanel Grid.Row="2" Spacing="15">
			<StackPanel Orientation="Horizontal" Spacing="20" HorizontalAlignment="Center" IsEnabled="{Binding !IsConnected}">
				<RadioButton Content="创建房间" GroupName="Mode" IsChecked="{Binding IsHostModeChecked, Mode=TwoWay}"/>
				<RadioButton Content="加入房间" GroupName="Mode" IsChecked="{Binding IsJoinModeChecked, Mode=TwoWay}"/>
			</StackPanel>

			<Border IsVisible="{Binding IsHostModeChecked}" BorderBrush="Gray" BorderThickness="1" CornerRadius="3" Padding="15">
				<StackPanel Spacing="10">
					<TextBlock Text="我是房主" FontSize="16" FontWeight="SemiBold"/>

					<ComboBox ItemsSource="{Binding AvailableGameData}"
                              SelectedItem="{Binding SelectedHostGameData}"
                              PlaceholderText="第一步: 选择一个游戏数据"
                              IsEnabled="{Binding !IsConnected}"/>

					<Grid ColumnDefinitions="*,Auto">
						<SelectableTextBlock Grid.Column="0" Text="{Binding HostRoomCode, FallbackValue='第二步: 点击“创建房间”生成码'}" VerticalAlignment="Center"/>
						<Button Grid.Column="1" Content="复制" Command="{Binding CopyCodeCommand}" IsEnabled="{Binding !!HostRoomCode}"/>
					</Grid>
				</StackPanel>
			</Border>

			<Border IsVisible="{Binding IsJoinModeChecked}" BorderBrush="Gray" BorderThickness="1" CornerRadius="3" Padding="15">
				<StackPanel Spacing="10" IsEnabled="{Binding !IsConnected}">
					<TextBlock Text="我是玩家" FontSize="16" FontWeight="SemiBold"/>
					<TextBox Text="{Binding JoinRoomCode}" Watermark="输入房主分享的房间码"/>
					<TextBox Text="{Binding JoinPort}" Watermark="输入房主的游戏端口 (如 25565)"/>
					<TextBox Text="{Binding LocalServerAddress}" IsReadOnly="True" Watermark="连接成功后此处显示本地地址"/>
				</StackPanel>
			</Border>
		</StackPanel>

		<Border Grid.Row="3" BorderBrush="Gray" BorderThickness="1" CornerRadius="3" Padding="10" Margin="0,15,0,0">
			<ScrollViewer>
				<TextBox Text="{Binding LogOutput}" AcceptsReturn="True" IsReadOnly="True" TextWrapping="Wrap" BorderThickness="0"/>
			</ScrollViewer>
		</Border>

	</Grid>
</UserControl>
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/SkinMangerPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
			 xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
			 x:DataType="vm:SkinMangerPaneViewModel"
			 x:CompileBindings="True"
             mc:Ignorable="d" d:DesignWidth="650" d:DesignHeight="530"
             x:Class="OneLauncher.Views.Panes.SkinMangerPane">
	<Grid Margin="24">
		<StackPanel Spacing="8">
			<ComboBox PlaceholderText="选择来源..." SelectedIndex="{Binding SelectedIndex}">
				<ComboBoxItem>通过本地上传</ComboBoxItem>
				<ComboBoxItem>通过NameMC获取</ComboBoxItem>
			</ComboBox>

			<StackPanel IsVisible="{Binding IsUseFile,FallbackValue=true}">
				<Button Content="选择本地文件..." Command="{Binding ToChooseSkinFileCommand}"/>
			</StackPanel>
			<StackPanel Spacing="12" Orientation="Horizontal" IsVisible="{Binding IsUseUrl}">
				<TextBox Watermark="输入NameMC的皮肤ID" Text="{Binding Url}">
					<TextBox.KeyBindings>
						<KeyBinding Gesture="Enter" Command="{Binding OpenInNameMCCommand}" />
					</TextBox.KeyBindings>
				</TextBox>
				<Button Content="检查并添加" Command="{Binding OpenInNameMCCommand}"/>
			</StackPanel>
			<TextBlock Text="选择模型类型："/>
			<StackPanel Orientation="Horizontal" Spacing="4">
				<RadioButton 
					IsChecked="{Binding IsSteveModel,FallbackValue=true}"
					GroupName="ModeType"
					Content="史蒂夫模型"/>
				<RadioButton GroupName="ModeType"
						  Content="爱丽丝模型"/>
			</StackPanel>
		</StackPanel>
	</Grid>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/UserModelLoginPane.axaml
【代码拼接器】文件内容开始
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
			 xmlns:vm="using:OneLauncher.Views.Panes.PaneViewModels"
			 x:DataType="vm:UserModelLoginPaneViewModel"
			 x:CompileBindings="True"
             x:Class="OneLauncher.Views.Panes.UserModelLoginPane">
	<Grid RowDefinitions="Auto,*">
		<Grid Grid.Row="0" ColumnDefinitions="*,*,*">
			<Button Command="{Binding BackCommand}" Margin="14" Grid.Column="0" HorizontalAlignment="Left">
				<StackPanel Orientation="Horizontal">
					<Image Source="/Assets/icos/back.png" Width="20" Height="20"/>
					<TextBlock Text="返回"/>
				</StackPanel>
			</Button>
			<TextBlock Margin="0,0,0,0" Grid.Column="1"  Text="收集信息..." FontSize="48"/>
		</Grid>
		<StackPanel Margin="12" Grid.Row="1" Spacing="12">
			<ComboBox SelectedItem="{Binding WhiceLoginType}" PlaceholderText="选择登入类型">
				<ComboBoxItem>离线登入</ComboBoxItem>
				<ComboBoxItem>微软登入</ComboBoxItem>
			</ComboBox>
			<StackPanel IsVisible="{Binding IsYaLogin}" Orientation="Horizontal" Spacing="8">
				<TextBox Text="{Binding UserName}" Watermark="输入用户名"/>
				<Button Command="{Binding DoneCommand}" Content="完成"/>
			</StackPanel>
			<StackPanel IsVisible="{Binding IsMsaLogin}">
				<StackPanel Orientation="Horizontal" Spacing="12">
					<Button Content="跳转登入" Command="{Binding LoginWithMicrosoftCommand}"/>
				</StackPanel>
			</StackPanel>
		</StackPanel>
	</Grid>
</UserControl>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/DownloadPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Downloader.DownloadMinecraftProviders;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Views.ViewModels;
using OneLauncher.Views.Windows;
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
namespace OneLauncher.Views.Panes.PaneViewModels;
internal partial class DownloadPaneViewModel : BaseViewModel
{
    private readonly DBManager _configManager;
    private readonly GameDataManager _gameDataManager;
#if DEBUG
    // 供设计器预览
    public DownloadPaneViewModel()
    {
        VersionName = "1.21.5";
        IsAllowNeoforge = true;
        IsAllowFabric = true;
    }
#endif
    public DownloadPaneViewModel(VersionBasicInfo Version,DBManager dBManager,GameDataManager gameDataManager)
    {
        this._configManager = dBManager;
        this._gameDataManager = gameDataManager;
        VersionName = Version.ID.ToString();
        thisVersionBasicInfo = Version;
        // 这个版本以下不支持模组加载器
        IsAllowFabric = new Version(Version.ID) < new System.Version("1.14") ? false : true;
        IsAllowNeoforge = new Version(Version.ID) < new System.Version("1.20.2") ? false : true;
        IsAllowForge = new Version(Version.ID) < new System.Version("1.2") ? false : true;
    }
    ~DownloadPaneViewModel()
    {
        Debug.WriteLine("页面释放");
        cts?.Dispose();
    }
    private CancellationTokenSource cts;
    #region 数据绑定区
    [ObservableProperty] public bool _IsForge;
    [ObservableProperty] public bool _IsAllowForge;
    [ObservableProperty] public bool _IsUseRecommendedToInstallForge = true;
    [ObservableProperty] public bool _IsAllowFabric;
    [ObservableProperty] public bool _IsAllowNeoforge;
    [ObservableProperty] public string _VersionName;
    [ObservableProperty] public bool _IsMod;
    [ObservableProperty] public bool _IsNeoForge;
    [ObservableProperty] public bool _IsAllowToUseBetaNeoforge = false;
    [ObservableProperty] public bool _IsDownloadFabricWithAPI = true;
    [ObservableProperty] public bool _IsJava;
    [ObservableProperty] public bool _IsAllowDownloading = true; // 默认允许下载
    [ObservableProperty] public string _Dp = "下载未开始";
    [ObservableProperty] public string _Fs = "?/0";
    [ObservableProperty] public string _FileName = "操作文件名：（下载未开始）";
    [ObservableProperty] public double _CurrentProgress = 0;
    private VersionBasicInfo thisVersionBasicInfo;
    #endregion
    [RelayCommand]
    public Task ToDownload()
    {
        IsAllowDownloading = false;
        var VersionModType = new ModType()
        {
            IsFabric = IsMod,
            IsNeoForge = IsNeoForge,
            IsForge = IsForge,
        };
        DateTime lastUpdateTime = DateTime.MinValue;
        TimeSpan _updateInterval = TimeSpan.FromMilliseconds(50);

        return Task.Run(async () =>
        {
            DownloadInfo content;

            cts = new();
            try
            {
                using (Download download = new Download())
                {
                    // 创建下载上下文信息
                    content = await DownloadInfo.Create(
                        VersionName,
                        VersionModType,
                        download, 
                        IsAllowToUseBetaNeoforge, 
                        IsUseRecommendedToInstallForge, 
                        IsDownloadFabricWithAPI, 
                        IsJava
                        );
                    // 创建进度回调
                    var progressReporter = new Progress<(DownProgress d, int a, int b, string c)>(p =>
                        Dispatcher.UIThread.Post(() =>
                        {
                            double progressPercentage = (p.a == 0) ? 0 : (double)p.b / p.a * 100;
                            if (p.d == DownProgress.Done)
                            {
                                Dp = "已下载完毕";
                                CurrentProgress = 100;
                            }
                            else if ((DateTime.UtcNow - lastUpdateTime) > _updateInterval)
                            {
                                Dp = p.d switch
                                {
                                    DownProgress.Meta => "准备元数据...",
                                    DownProgress.DownAndInstModFiles => "下载并安装模组加载器...",
                                    DownProgress.DownLog4j2 => "下载日志配置...",
                                    DownProgress.DownLibs => "下载库文件...",
                                    DownProgress.DownAssets => "下载资源文件...",
                                    DownProgress.DownMain => "下载游戏主文件...",
                                    DownProgress.Verify => "校验文件中..."
                                };
                                CurrentProgress = progressPercentage;
                                lastUpdateTime = DateTime.UtcNow;
                            }
                            Fs = $"{p.b}/{p.a}";
                            FileName = p.c;
                        }));
                    // 执行下载
                    await new DownloadMinecraft(
                        _configManager,
                        content,
                        progressReporter,
                        cts.Token
                    ).MinecraftBasic(
                        _configManager.Data.OlanSettings.MaximumDownloadThreads,
                        _configManager.Data.OlanSettings.MaximumSha1Threads,
                        _configManager.Data.OlanSettings.IsSha1Enabled);
                }
               UserVersion? mayInstalledVersion = _configManager.Data.VersionList.FirstOrDefault(x => x.VersionID == VersionName);
                if (mayInstalledVersion == null)
                    _configManager.Data.VersionList.Add(content.VersionInstallInfo);
                else
                {
                    var updatedModType = mayInstalledVersion.modType;
                    if (content.VersionInstallInfo.modType.IsFabric) updatedModType.IsFabric = true;
                    if (content.VersionInstallInfo.modType.IsNeoForge) updatedModType.IsNeoForge = true;
                    if (content.VersionInstallInfo.modType.IsForge) updatedModType.IsForge = true;
                    mayInstalledVersion.modType = updatedModType; // 将修改后的整个副本赋值回去
                }
                await _gameDataManager.AddGameDataAsync(content.UserInfo);
                await _gameDataManager.SetDefaultInstanceAsync(content.UserInfo);
                await _configManager.Save();
                WeakReferenceMessenger.Default.Send(new MainWindowShowFlyoutMessage($"“{content.UserInfo.Name}”已成功创建并设为默认启动项。"));
            }
            catch (OperationCanceledException)
            {
                Debug.WriteLine("下载任务被用户取消");
            }
            catch (OlanException ex)
            {
                await cts.CancelAsync();
                await OlanExceptionWorker.ForOlanException(ex);
            }
#if !DEBUG
        catch (Exception ex)
        {
            await cts.CancelAsync();
            await OlanExceptionWorker.ForUnknowException(ex);
        }
#endif
        });
    }
    [RelayCommand]
    public void ToCancellationDownloadTask()
    {
        cts.Cancel();
    }
    [RelayCommand]
    public void ClosePane()
    {
        WeakReferenceMessenger.Default.Send(new DownloadPageClosePaneControlMessage());
    }
    [RelayCommand]
    public void PopUp()
    {
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        //new PopUpPane(new DownloadPane(thisVersionBasicInfo,this)).Show();
    }
    //public void CheckOnWeb()
    //{
    //    Process.Start(new ProcessStartInfo
    //    {
    //        FileName = $"https://zh.minecraft.wiki/w/Java版{VersionName}",
    //        UseShellExecute = true
    //    });
    //}
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/EditGameDataPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;

internal partial class EditGameDataPaneViewModel : BaseViewModel
{
    private readonly GameDataManager _gameDataManager;
    private readonly GameData editingGameData;
    [ObservableProperty] private string instanceName;
    [ObservableProperty] private Bitmap currentIcon;

    public EditGameDataPaneViewModel(GameData gameData,GameDataManager gameDataManager)
    {
        this._gameDataManager = gameDataManager;
        editingGameData = gameData;
        InstanceName = gameData.Name;
        LoadCurrentIcon();
    }

    private void UpdateGameData()
    {
        try
        {
            _gameDataManager.Data.Instances[editingGameData.InstanceId] = editingGameData;
        }
        catch(KeyNotFoundException e)
        {
            throw new OlanException(
                "无法更新游戏数据",
                "尝试更新一个不存在的游戏数据实例",
                OlanExceptionAction.Error, e);
        }
    }
    private void LoadCurrentIcon()
    {
        if (!string.IsNullOrEmpty(editingGameData.CustomIconPath) && File.Exists(editingGameData.CustomIconPath))
        {
            try { CurrentIcon = new Bitmap(editingGameData.CustomIconPath); return; }
            catch (Exception) { /* 忽略错误，使用默认图标 */ }
        }

        string iconUri = editingGameData.ModLoader switch
        {
            ModEnum.fabric => "avares://OneLauncher/Assets/Imgs/fabric.png",
            ModEnum.neoforge => "avares://OneLauncher/Assets/Imgs/neoforge.png",
            ModEnum.forge => "avares://OneLauncher/Assets/Imgs/forge.jpg",
            _ => "avares://OneLauncher/Assets/Imgs/basic.png",
        };
        CurrentIcon = new Bitmap(AssetLoader.Open(new Uri(iconUri)));
    }
    private void DeleteGameData()
    {
        // 未来可以加一个对话框确认
        _ = _gameDataManager.RemoveGameDataAsync(editingGameData);

        try
        {
            if (Directory.Exists(editingGameData.InstancePath))
                Directory.Delete(editingGameData.InstancePath, true);
        }
        catch (Exception ex)
        {
            MainWindow.mainwindow.ShowFlyout($"删除文件夹失败: {ex.Message}", true);
        }

        WeakReferenceMessenger.Default.Send(
            new GameDataPageDisplayListRefreshMessage()); // 重新加载列表
        WeakReferenceMessenger.Default.Send(
            new MainWindowShowFlyoutMessage($"已删除实例“{editingGameData.Name}”！"));
    }

    [RelayCommand]
    private async Task ChangeIcon()
    {
        var topLevel = TopLevel.GetTopLevel(MainWindow.mainwindow);
        if (topLevel?.StorageProvider is null) return;

        var files = await topLevel.StorageProvider.OpenFilePickerAsync(new FilePickerOpenOptions
        {
            Title = "选择一个新的图标",
            AllowMultiple = false,
            FileTypeFilter = new[] { FilePickerFileTypes.ImagePng }
        });

        var selectedFile = files?.FirstOrDefault();
        if (selectedFile == null) return;

        string imageDir = Path.Combine(editingGameData.InstancePath, "image");
        Directory.CreateDirectory(imageDir);
        string destPath = Path.Combine(imageDir, $"{editingGameData.InstanceId}.png");

        { // 确保文件流被释放
            await using var sourceStream = await selectedFile.OpenReadAsync();
            await using var destStream = File.Create(destPath);
            await sourceStream.CopyToAsync(destStream);
        }

        editingGameData.CustomIconPath = destPath;
        CurrentIcon = new Bitmap(destPath); // 显示预览
        UpdateGameData();

        WeakReferenceMessenger.Default.Send(
            new GameDataPageDisplayListRefreshMessage());

        WeakReferenceMessenger.Default.Send(
            new MainWindowShowFlyoutMessage($"已更改实例“{editingGameData.Name}”的图标！"));
    }

    [RelayCommand]
    private void OpenInstanceFolder()
    {
        string modsPath = Path.Combine(editingGameData.InstancePath);
        Tools.OpenFolder(modsPath);
    }
    [RelayCommand]
    private void AddToQuicklyPlay()
    {
        File.WriteAllTextAsync(
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop),$"快速启动 - {editingGameData.Name}"+
            #if WINDOWS
            ".bat"
            #else
            ".sh"
            #endif
            ), 
            $"{Environment.ProcessPath} --quicklyPlay {editingGameData.InstanceId}"
            );
    }
    [RelayCommand]
    private void Save()
    {
        editingGameData.Name = InstanceName;
        //parentViewModel.UpdateGameData(editingGameData);
        _gameDataManager.Data.Instances.GetValueOrDefault(editingGameData.InstanceId);
        _=_gameDataManager.Save();

        WeakReferenceMessenger.Default.Send(new GameDataPageDisplayListRefreshMessage());
        WeakReferenceMessenger.Default.Send(new GameDataPageClosePaneControlMessage());
        WeakReferenceMessenger.Default.Send(
            new MainWindowShowFlyoutMessage($"实例“{InstanceName}”已保存"));
    }
    [RelayCommand]
    private void DeleteInstance()
    {
        DeleteGameData();
        WeakReferenceMessenger.Default.Send(new GameDataPageClosePaneControlMessage());
    }

    [RelayCommand]
    private void Cancel()
    {
        WeakReferenceMessenger.Default.Send(new GameDataPageClosePaneControlMessage());
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/InitServerPaneViewModel.cs
【代码拼接器】文件内容开始
using CommunityToolkit.Mvvm.Collections;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Minecraft.Server;
using OneLauncher.Views.ViewModels;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;
internal partial class InitServerPaneViewModel : BaseViewModel
{
#if DEBUG
    public InitServerPaneViewModel() { }
#endif
    public InitServerPaneViewModel(string version)
    {
        serverVersion = version;    
    }
    private string serverVersion;
    [ObservableProperty]
    public bool isAgreeMinecraftEULA;
    [RelayCommand]
    public void ReadMinecraftEULA()
        => Process.Start(new ProcessStartInfo { FileName = "https://aka.ms/MinecraftEULA", UseShellExecute = true });

    [ObservableProperty]
    public bool isVI = true;
    [RelayCommand]
    public async Task ToInstallServer()
    {
        if (!IsAgreeMinecraftEULA)
            await OlanExceptionWorker.ForOlanException(
                new OlanException("无法初始化服务端","你必须在安装前同意Minecraft的最终用户许可协议",OlanExceptionAction.Error));
        else
        {
            // 反正后面也要用，这里也读取了索性直接返回一个java版本
            int javaVersion = await MinecraftServerManger.Init(serverVersion,IsVI);
            //完成后打开服务端
            MinecraftServerManger.Run(serverVersion,javaVersion,IsVI);
            WeakReferenceMessenger.Default.Send(new VersionPageClosePaneControlMessage());
            //MainWindow.mainwindow.versionPage.viewmodel.IsPaneShow = false;
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/InstallModPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;

internal partial class InstallModPaneViewModel : BaseViewModel
{
    private readonly GameDataManager _gameDataManager;
#if DEBUG
    // 给设计器预览的
    public InstallModPaneViewModel()
    {
        if (Design.IsDesignMode)
            ModName = "暮色森林";
    }
#endif
    private readonly ModItem modItem;
    public InstallModPaneViewModel(ModItem item,GameDataManager gameDataManager)
    {
        this._gameDataManager = gameDataManager;
        modItem = item;
        ModName = item.Title;
        SupportVersions = item.SupportVersions;
        AvailableGameData = _gameDataManager.AllGameData;
        this.SupportModType = item.SupportModType;
    }
    private ModType SupportModType;
    [ObservableProperty]
    public bool _IsShowMoreInfo = true;
    [ObservableProperty]
    public string _ModName;
    [ObservableProperty]
    public List<string> _SupportVersions;

    // --- 修改点 2：添加用于绑定的属性 ---
    [ObservableProperty]
    private List<GameData> _AvailableGameData;

    [ObservableProperty]
    private GameData? _SelectedGameData; 
    [RelayCommand]
    public async Task ToInstall()
    {
        // 验证是否选择了实例
        if (SelectedGameData == null)
        {
            WeakReferenceMessenger.Default.Send(
                new MainWindowShowFlyoutMessage("请先选择一个游戏实例！"));
            //MainWindow.mainwindow.ShowFlyout("请先选择一个游戏实例！", true);
            return;
        }
        // 检查加载器是否匹配
        if (SupportModType != SelectedGameData.ModLoader)
        {
            WeakReferenceMessenger.Default.Send(
                new MainWindowShowFlyoutMessage($"此 Mod 不支持 {SelectedGameData.ModLoader} 加载器。"));
            //MainWindow.mainwindow.ShowFlyout($"此 Mod 不支持 {SelectedGameData.ModLoader} 加载器。", true);
            return;
        }
        // 检查游戏版本是否受支持
        if (!SupportVersions.Contains(SelectedGameData.VersionId))
        {
            WeakReferenceMessenger.Default.Send(
                new MainWindowShowFlyoutMessage($"此 Mod 不支持游戏版本 {SelectedGameData.VersionId}。"));
            //MainWindow.mainwindow.ShowFlyout($"此 Mod 不支持游戏版本 {SelectedGameData.VersionId}。", true);
            return;
        }
        // 4. 所有检查通过，开始下载
        IsShowMoreInfo = false;
        try
        {
            using (Download downTask = new())
            {
                // 目标路径现在直接从 SelectedGameData 获取
                string modsPath = Path.Combine(SelectedGameData.InstancePath, "mods");

                await downTask.StartDownloadMod(
                    new Progress<(long all, long done, string c)>(p => Dispatcher.UIThread.Post(() =>
                    {
                        if (p.all > 0) // 避免除零错误
                        {
                            CurrentProgress = (double)p.done / p.all * 100;
                            Fs = $"{p.done}/{p.all}";
                        }
                        Dp = p.c; // 更新文件名或状态
                    })),
                    modItem.ID,
                    modsPath,
                    SelectedGameData.VersionId,
                    IsIncludeDependencies: IsICS,
                    // 先凑合用，未来再重写
                    IsSha1: Init.ConfigManger.Data.OlanSettings.IsSha1Enabled
                );
            }
            WeakReferenceMessenger.Default.Send(
                new MainWindowShowFlyoutMessage($"{ModName} 安装成功！"));
            //MainWindow.mainwindow.ShowFlyout($"{ModName} 安装成功！");
        }
        catch (OlanException ex)
        {
            await OlanExceptionWorker.ForOlanException(ex);
            IsShowMoreInfo = true; // 失败后恢复界面
        }
        catch (Exception ex)
        {
            await OlanExceptionWorker.ForUnknowException(ex);
            IsShowMoreInfo = true; // 失败后恢复界面
        }
    }

    [ObservableProperty]
    public bool _IsICS = true; // 默认勾选下载依赖

    [ObservableProperty]
    public string _Dp = "等待安装";

    [ObservableProperty]
    public string _Fs = "0/0";

    [ObservableProperty]
    public double _CurrentProgress = 0;

    [RelayCommand]
    public void ClosePane()
    {
        WeakReferenceMessenger.Default.Send(new ModsBrowserClosePaneControlMessage());
        //MainWindow.mainwindow.modsBrowserPage.viewmodel.IsPaneShow = false;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/NewGameDataPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Data.Converters;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;
internal partial class NewGameDataPaneViewModel : BaseViewModel
{
    private readonly DBManager _configManager;
    private readonly AccountManager _accountManager;
    private readonly GameDataManager _gameDataManager;
    [ObservableProperty] private string gameDataName;
    [ObservableProperty] private List<UserVersion> availableBaseVersions;
    [ObservableProperty] private UserVersion selectedBaseVersion;
    [ObservableProperty] private List<ModEnum> availableModLoaders;
    [ObservableProperty] private ModEnum? selectedModLoader;
    [ObservableProperty] private List<UserModel> availableUsers;
    [ObservableProperty] private UserModel selectedUser;


    public NewGameDataPaneViewModel(DBManager configManager,AccountManager accountManager,GameDataManager gameDataManager)
    {
        this._configManager = configManager;
        this._configManager = configManager;
        this._accountManager = accountManager;
        // 加载所需数据
        AvailableBaseVersions = _configManager.Data.VersionList;
        AvailableUsers = _accountManager.GetAllUsers().ToList();
        SelectedUser = _accountManager.GetDefaultUser() ?? AvailableUsers.FirstOrDefault() ??
            new UserModel(Guid.NewGuid(),"GameDataDefault",Guid.NewGuid());

        // 默认情况下，模组加载器列表为空，等待用户选择基础版本
        AvailableModLoaders = new List<ModEnum> { ModEnum.none };
        SelectedModLoader = ModEnum.none;
    }
    partial void OnSelectedBaseVersionChanged(UserVersion value)
    {
        if (value == null)
        {
            // 如果清空选择，则重置加载器列表
            AvailableModLoaders = new List<ModEnum> { ModEnum.none };
            SelectedModLoader = ModEnum.none;
            GameDataName = string.Empty;
            return;
        }

        var loaders = new List<ModEnum> { ModEnum.none };
        if (value.modType.IsFabric) loaders.Add(ModEnum.fabric);
        if (value.modType.IsNeoForge) loaders.Add(ModEnum.neoforge);
        if (value.modType.IsForge) loaders.Add(ModEnum.forge);
        AvailableModLoaders = loaders;

        SelectedModLoader = value.modType.ToModEnum();
        GameDataName = $"{value.VersionID} - Instance";
    }

    [RelayCommand]
    private async Task Save()
    {
        // 数据验证
        if (SelectedBaseVersion == null)
        {
            MainWindow.mainwindow.ShowFlyout("请先选择一个基础游戏版本！", true);
            return;
        }
        if (string.IsNullOrWhiteSpace(GameDataName))
        {
            MainWindow.mainwindow.ShowFlyout("游戏数据名称不能为空！", true);
            return;
        }

        var loaderType = SelectedModLoader ?? ModEnum.none;

        var newGameData = new GameData(
            name: GameDataName,
            versionId: SelectedBaseVersion.VersionID,
            loader: loaderType, 
            userModel: SelectedUser.UserID
        );

        await _gameDataManager.AddGameDataAsync(newGameData);
        WeakReferenceMessenger.Default.Send(new MainWindowShowFlyoutMessage($"已成功创建游戏数据：{GameDataName}"));
        //MainWindow.mainwindow.ShowFlyout($"已成功创建游戏数据: {GameDataName}");

        WeakReferenceMessenger.Default.Send(new GameDataPageDisplayListRefreshMessage());
        //MainWindow.mainwindow.gamedataPage.viewmodel.RefList();

        Cancel();
    }

    [RelayCommand]
    private void Cancel()
    {
        WeakReferenceMessenger.Default.Send(new GameDataPageClosePaneControlMessage());
        //MainWindow.mainwindow.gamedataPage.viewmodel.IsPaneShow = false;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/PowerPlayPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.ConnectToolPower;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;
public enum PowerPlayMode { Host, Join }
public partial class PowerPlayPaneViewModel : BaseViewModel
{
    private readonly GameDataManager _gameDataManager;
    ~PowerPlayPaneViewModel() => Stop(); // 销毁时停止核心进程
    public PowerPlayPaneViewModel(IConnectService connectService,MCTPower mainPower,GameDataManager gameDataManager)
    {
        this._gameDataManager = gameDataManager;
        PropertyChanged += (s, e) =>
        {
            if (e.PropertyName == nameof(IsHostModeChecked) && IsHostModeChecked)
            {
                SetProperty(ref isJoinModeChecked, false, nameof(IsJoinModeChecked));
            }
            else if (e.PropertyName == nameof(IsJoinModeChecked) && IsJoinModeChecked)
            {
                SetProperty(ref isHostModeChecked, false, nameof(IsHostModeChecked));
            }
        };
        WeakReferenceMessenger.Default.Register<ApplicationClosingMessage>(this, (recipient, message) =>
        {
            mainPower.Dispose();
            Debug.WriteLine("核心已停止");
        });
        AvailableGameData = _gameDataManager.AllGameData;
        mainPower.CoreLog += OnCoreLogReceived;
        this.mainPower = mainPower;
        this.connectService = connectService;
    }
    private readonly MCTPower mainPower;
    private readonly IConnectService connectService;
    #region 模型定义
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanStart))]
    [NotifyPropertyChangedFor(nameof(CanStop))]
    private bool isConnected = false;

    [ObservableProperty]
    private bool isHostModeChecked = true;

    [ObservableProperty]
    private bool isJoinModeChecked = false;

    [ObservableProperty] private string hostRoomCode = string.Empty;
    [ObservableProperty] private string joinRoomCode = string.Empty;
    [ObservableProperty] private string joinPort = string.Empty;
    [ObservableProperty] private string localServerAddress = string.Empty;
    [ObservableProperty] private string logOutput = string.Empty;

    // 获取当前可用的所有可以游戏实例
    [ObservableProperty]
    public List<GameData> availableGameData;

    // 那个要作为主机的实例
    [ObservableProperty]
    public GameData? selectedHostGameData;

    private readonly StringBuilder logBuilder = new();

    public bool CanStart => !isConnected;
    public bool CanStop => isConnected;
    #endregion
    [RelayCommand]
    private async Task Host()
    {
        try
        {
            if (SelectedHostGameData == null)
                throw new OlanException("未能创建房间", "请先在下拉框中选择一个要进行联机的游戏版本。", OlanExceptionAction.Warning);

            string p2pNodeName = "OLANNODE" + RandomNumberGenerator.GetInt32(100000, 1000000000);
            string combinedInfo = $"{p2pNodeName}:{SelectedHostGameData.VersionId}";
            string finalRoomCode = TextHelper.Base64Encode(combinedInfo);

            HostRoomCode = finalRoomCode;
            IsConnected = true;
            connectService.StartAsHost(p2pNodeName, null);
            _ = version.EasyGameLauncher(SelectedHostGameData); // 直接帮他把游戏启动了
        }
        catch (OlanException olanEx)
        {
            await OlanExceptionWorker.ForOlanException(olanEx);
        }
        catch (Exception ex)
        {
            await OlanExceptionWorker.ForUnknowException(ex);
        }
    }

    [RelayCommand]
    private async Task JoinAndLaunch()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(JoinRoomCode))
                throw new OlanException("输入无效", "必须输入房间码。", OlanExceptionAction.Warning);

            if (string.IsNullOrWhiteSpace(JoinPort) || !int.TryParse(JoinPort, out int destPort) || destPort is < 1 or > 65535)
                throw new OlanException("输入无效", "请输入一个有效的目标端口号 (1-65535)。", OlanExceptionAction.Warning);

            string p2pNodeName;
            string versionId = string.Empty;
            bool isMCTMode = false;

            try
            {
                string decodedInfo = TextHelper.Base64Decode(JoinRoomCode);
                string[] parts = decodedInfo.Split(':', 2);
                if (parts.Length < 2 || !parts[0].StartsWith("OLANNODE")) throw new FormatException("不是有效的OneLauncher房间码格式。");
                p2pNodeName = parts[0];
                versionId = parts[1];
            }
            // 尝试兼容MCT
            catch (FormatException)
            {
                if (JoinRoomCode.StartsWith("M") && JoinRoomCode.EndsWith("C"))
                {
                    p2pNodeName = JoinRoomCode;
                    isMCTMode = true;
                }
                else
                    throw new OlanException("房间码无效", "无法解析此房间码，请确认是否从OneLauncher主机处复制。", OlanExceptionAction.Error);
                
            }

            int localPort = Tools.GetFreeTcpPort();
            LocalServerAddress = $"127.0.0.1:{localPort}";
            IsConnected = true;

            if (isMCTMode)
            {
                // **纯MCT兼容模式：只启动P2P，不启动游戏**
                connectService.Join(null, p2pNodeName, localPort, destPort, null, null, null);
                LogMessage($"已进入MCT兼容模式，仅启动P2P连接服务，目标节点: {p2pNodeName}");
            }
            else
            {
                var allInstancesForVersion = _gameDataManager.AllGameData;

                if (!allInstancesForVersion.Any())
                {
                    throw new OlanException("加入失败", $"你还没有安装版本 {versionId} 的任何游戏实例。", OlanExceptionAction.Error);
                }

                // 查找或设置要启动的实例
                GameData instanceToLaunch; 
                var defaultInstance = _gameDataManager.GetDefaultInstance(versionId);

                if (defaultInstance != null)
                {
                    instanceToLaunch = defaultInstance;
                }
                else
                {
                    // 如果没有默认项，自动设置第一个并通知用户
                    instanceToLaunch = allInstancesForVersion.First();
                    await _gameDataManager.SetDefaultInstanceAsync(instanceToLaunch);
                    WeakReferenceMessenger.Default.Send(
                        new MainWindowShowFlyoutMessage($"已自动将'{instanceToLaunch.Name}'设为版本{versionId}的默认实例"));
                    //MainWindow.mainwindow.ShowFlyout($"已自动将'{instanceToLaunch.Name}'设为版本{versionId}的默认实例");
                }

                // 启动P2P
                mainPower.ConnectionEstablished += () =>
                {
                    _ = version.EasyGameLauncher(instanceToLaunch, serverInfo: new ServerInfo
                    {
                        Ip = "127.0.0.1",
                        Port = localPort.ToString()
                    });
                };

                connectService.Join(null, p2pNodeName, localPort, destPort, null, null, null);
                LogMessage($"P2P启动，准备连接到 {p2pNodeName} 并启动游戏...");
            }
        }
        catch (OlanException olanEx)
        {
            await OlanExceptionWorker.ForOlanException(olanEx);
            Stop();
        }
        catch (Exception ex)
        {
            await OlanExceptionWorker.ForUnknowException(ex);
            Stop();
        }
    }
    [RelayCommand]
    private Task CopyCode() =>
        TopLevel.GetTopLevel(MainWindow.mainwindow)?.Clipboard?.SetTextAsync(IsHostModeChecked ? HostRoomCode : JoinRoomCode);
    
    [RelayCommand]
    private void Stop()
    {
        mainPower.Dispose();
        IsConnected = false;
        HostRoomCode = string.Empty;
        LocalServerAddress = string.Empty;
        LogMessage("连接已断开。");
    }

    private void OnCoreLogReceived(string logMessage) => Dispatcher.UIThread.Post(() => LogMessage(logMessage));
    private void LogMessage(string message) { logBuilder.AppendLine(message); LogOutput = logBuilder.ToString(); }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/SkinMangerPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.msa;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;

internal partial class SkinMangerPaneViewModel : BaseViewModel
{
#if DEBUG
    public SkinMangerPaneViewModel() { }
#endif
    private AccountPageViewModel accountPageViewModel;
    private UserModel SelUserModel;
    public SkinMangerPaneViewModel(AccountPageViewModel accountPageViewModel,UserModel SelUserModel)
    {
        this.accountPageViewModel = accountPageViewModel;
        this.SelUserModel = SelUserModel;
    }
    private int _selectedIndex;
    public int SelectedIndex
    {
        set
        {
            _selectedIndex = value;
            if (value == 0)
            {
                IsUseFile = true;
                IsUseUrl = false;
            }
            else if (value == 1)
            {
                IsUseUrl = true;
                IsUseFile = false;
            }
        }
        get 
        { 
            return _selectedIndex;
        }
    }
    [ObservableProperty]
    public bool _IsSteveModel;
    [RelayCommand]
    public async Task ToChooseSkinFile()
    {
        var topLevel = TopLevel.GetTopLevel(MainWindow.mainwindow);
        if (topLevel?.StorageProvider is { } storageProvider && storageProvider.CanOpen)
        {
            // 配置文件选择器选项
            var options = new FilePickerOpenOptions
            {
                Title = "选择皮肤文件", // 对话框标题
                AllowMultiple = false, // 是否允许选择多个文件
                FileTypeFilter = new[]
                {
                    FilePickerFileTypes.ImagePng // 仅限png文件
                }
            };

            // 打开文件选择器
            var files = await storageProvider.OpenFilePickerAsync(options);
            var selectedFile = files.FirstOrDefault();

            if (files == null || !files.Any() || selectedFile == null)
                return;

            // 获取本地路径
            string filePath = selectedFile.Path.LocalPath;

            // 检查皮肤文件有效性
            if (!await MojangProfile.IsValidSkinFile(filePath))
            {
                MainWindow.mainwindow.ShowFlyout("皮肤文件无效！", true);
                return;
            }
            Debug.WriteLine("有效的皮肤文件");
            using (var task = new MojangProfile(SelUserModel))
            {
                // 上传
                await task.SetUseLocalFile(new MojangSkin()
                {
                    Skin = filePath,
                    IsSlimModel = (IsSteveModel) ? false : true
                });
                // 重新缓存本地皮肤文件
                await task.GetSkinHeadImage();
                // 刷新
                accountPageViewModel.RefList();

                MainWindow.mainwindow.ShowFlyout("已成功上传皮肤！");
            } 
        }
    }
    [ObservableProperty]
    public bool _IsUseUrl;
    [ObservableProperty]
    public bool _IsUseFile = true;
    [ObservableProperty]
    public string _Url;
    [RelayCommand]
    public async Task OpenInNameMC()
    {
        // 检查url有效性
        string Url = $"https://s.namemc.com/i/{this.Url}.png";
        using (var client = new HttpClient())
        {
            client.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36");
            var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Head, Url));
            if (!response.IsSuccessStatusCode || Url == null)
            {
                MainWindow.mainwindow.ShowFlyout("无效的ID", true);
                return;
            }
        }
        using (var task = new MojangProfile(SelUserModel))
        {
            // 上传
            await task.SetUseUrl(new MojangSkin()
            {
                Skin = Url,
                IsSlimModel = (IsSteveModel) ? false : true
            });
            // 重新缓存本地皮肤文件
            await task.GetSkinHeadImage();
            // 刷新
            accountPageViewModel.RefList();

            MainWindow.mainwindow.ShowFlyout("已成功通过NameMC上传皮肤！");
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/UserModelLoginPaneViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.msa;
using OneLauncher.Views.ViewModels;
using System;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels;

internal partial class UserModelLoginPaneViewModel : BaseViewModel
{
#if DEBUG
    public UserModelLoginPaneViewModel() { }
#endif
    private AccountPageViewModel accountPageViewModel;
    public UserModelLoginPaneViewModel(AccountPageViewModel accountPageViewModel)
    {
        this.accountPageViewModel = accountPageViewModel;
    }
    [ObservableProperty]
    public string _UserName;
    [RelayCommand]
    public void Done()
    {
        if (string.IsNullOrEmpty(UserName)) return;
        if (!Regex.IsMatch(UserName, @"^[a-zA-Z0-9_]+$"))
        {
            MainWindow.mainwindow.ShowFlyout("用户名包含非法字符！", true);
            return;
        }
        Init.AccountManager.AddUser(new UserModel(
            UserID : Guid.NewGuid(),
            name : UserName,
            uuid : Guid.NewGuid()
        ));
        accountPageViewModel.RefList();
        accountPageViewModel.IsPaneShow = false;
        MainWindow.mainwindow.ShowFlyout($"已新建用户:{UserName}");
    }
    [RelayCommand]
    public void Back()
    {
        accountPageViewModel.IsPaneShow = false;
        MainWindow.mainwindow.ShowFlyout("已暂存修改！");
    }

    [ObservableProperty]
    public bool _IsYaLogin = true;
    [ObservableProperty]
    public bool _IsMsaLogin = false;
    private ListBoxItem _whiceLoginType;
    public ListBoxItem WhiceLoginType
    {
        set
        {
            _whiceLoginType = value;
            if (value.Content == "离线登入")
            {
                Debug.WriteLine("离线登入");
                IsYaLogin = true;
                IsMsaLogin = false;
            }
            if (value.Content == "微软登入")
            {
                Debug.WriteLine("微软登入");
                IsYaLogin = false;
                IsMsaLogin = true;
            }
        }
        get
        {
            return _whiceLoginType;
        }
    }
    [RelayCommand]
    public async Task LoginWithMicrosoft()
    {
        try
        {
            UserModel um;
#if WINDOWS
            if (Init.SystemType == SystemType.windows)
            {
                um = 
                    await Init.MMA.LoginNewAccountToGetMinecraftMojangAccessTokenUseWindowsWebAccountManger(
                        (MainWindow.mainwindow.TryGetPlatformHandle().Handle))
                    ?? throw new OlanException("认证失败", "无法认证你的微软账号"); ;
            }
            else
#endif
            {
                um =
                    await Init.MMA.LoginNewAccountToGetMinecraftMojangAccessTokenOnSystemBrowser()
                    ?? throw new OlanException("认证失败", "无法认证你的微软账号");
            }
            await Init.AccountManager.AddUser(um);
            using (var task = new MojangProfile(um))
                await task.GetSkinHeadImage();
            accountPageViewModel.RefList();
            accountPageViewModel.IsPaneShow = false;
            MainWindow.mainwindow.ShowFlyout($"已登入账号:{UserName}");
        }
        catch (OlanException ex)
        {
            OlanExceptionWorker.ForOlanException(ex);
            return;
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/Factories/DownloadPaneViewModelFactory.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels.Factories;

internal class DownloadPaneViewModelFactory
{
    //private readonly AccountManager _accountManager;
    private readonly DBManager _dbManager;
    private readonly GameDataManager _gameDataManager;

    // 工厂的构造函数：让DI容器把工具都送进来
    public DownloadPaneViewModelFactory(
        
        DBManager dbManager,
        GameDataManager gameDataManager)
    {
        //_accountManager = accountManager;
        _dbManager = dbManager;
        _gameDataManager = gameDataManager;
    }

    // 实现接口的Create方法：接收“特殊材料”，开始生产！
    public DownloadPaneViewModel Create(VersionBasicInfo version)
    {
        // 在这里，你终于可以把两边的参数完美地结合在一起了！
        return new DownloadPaneViewModel(version, _dbManager,_gameDataManager);
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/Factories/EditGameDataPaneViewModelFactory.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels.Factories;

internal class EditGameDataPaneViewModelFactory
{
    private readonly GameDataManager gameDataManager;
    public EditGameDataPaneViewModelFactory(GameDataManager gameDataManager)
    {
        this.gameDataManager = gameDataManager;
    }
    public EditGameDataPaneViewModel Create(GameData gameData)
    {
        return new EditGameDataPaneViewModel(gameData,gameDataManager);
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/Factories/InstallModPaneViewModelFactory.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels.Factories;

internal class InstallModPaneViewModelFactory
{
    private readonly GameDataManager _gameDataManager;
    public InstallModPaneViewModelFactory(GameDataManager gameDataManager)
    {
        _gameDataManager = gameDataManager;
    }
    public InstallModPaneViewModel Create(ModItem item)
    {
        return new InstallModPaneViewModel(item, _gameDataManager);
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Panes/PaneViewModels/Factories/PowerPlayPaneViewModelFactory.cs
【代码拼接器】文件内容开始
using Avalonia.Platform;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Net.ConnectToolPower;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Panes.PaneViewModels.Factories;

internal class PowerPlayPaneViewModelFactory
{
    private readonly GameDataManager _gameDataManager;
    public PowerPlayPaneViewModelFactory(GameDataManager gameDataManager)
    {
        _gameDataManager = gameDataManager;
    }
    public async Task<PowerPlayPaneViewModel> CreateAsync()
    {
        var mctPower = await MCTPower.InitializationAsync();
        var connectService = new P2PMode(mctPower);
        var viewModel = new PowerPlayPaneViewModel(connectService, mctPower,_gameDataManager);
        return viewModel;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/AccountPageViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.msa;
using OneLauncher.Views.Panes;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace OneLauncher.Views.ViewModels;
internal partial class UserItem
{
    public UserModel um { get; set; }
    public Bitmap HeadImg { get; set; } = new Bitmap(AssetLoader.Open(new Uri("avares://OneLauncher/Assets/Imgs/steve.png")));
    public bool IsDefault { get; set; }
    public bool IsNotDefault => !IsDefault;
}
internal partial class AccountPageViewModel : BaseViewModel
{
    private AccountManager _accountManager;
    private MsalAuthenticator _msalAuthenticator;
    // 刷新
    public void RefList()
    {
        // 在刷新列表时，判断每一项是否为默认用户
        UserModel? defaultUser = _accountManager.GetDefaultUser();

        UserModelList = _accountManager.GetAllUsers()
            .Select(user => new UserItem()
            {
                um = user,
                HeadImg = (user.IsMsaUser && File.Exists(Path.Combine(Init.BasePath, "playerdata", "body", $"{user.uuid}.png")))
                    ? new Bitmap(Path.Combine(Init.BasePath, "playerdata", "body", $"{user.uuid}.png"))
                    : new Bitmap(AssetLoader.Open(new Uri("avares://OneLauncher/Assets/Imgs/steve.png"))),
                // 在创建 UserItem 时，就设置好 IsDefault 属性
                IsDefault = (defaultUser != null && user.uuid == defaultUser.uuid)
            }).ToList();
    }
    [RelayCommand]
    public async Task Refresh()
    {
        try
        {
            foreach (var user in UserModelList)
            {
                using (var task = new MojangProfile(user.um))
                    await task.GetSkinHeadImage();
            }
            RefList();
            MainWindow.mainwindow.ShowFlyout("刷新完毕");
        }
        catch (OlanException oex)
        {
            OlanExceptionWorker.ForOlanException(oex);
        }
        catch (Exception ex) { 
            OlanExceptionWorker.ForUnknowException(ex);
        }
    }
    public AccountPageViewModel(AccountManager manager,MsalAuthenticator msalAuthenticator)
    {
        this._accountManager = manager;
        this._msalAuthenticator = msalAuthenticator;
#if DEBUG
        if (Design.IsDesignMode)
            UserModelList = new List<UserItem>()
            {
                new UserItem()
                {
                    um = new UserModel(new Guid(),"steve",new Guid(UserModel.nullToken))

                }
            };
        else
#endif
        {
            try
            {
                RefList();
            }
            catch (NullReferenceException ex)
            {
                throw new OlanException(
                    "内部异常",
                    "配置文件特定部分账户部分为空，这可能是新版和旧版配置文件不兼容导致的",
                    OlanExceptionAction.FatalError,
                    ex,
                   () =>
                   {
                       File.Delete(Path.Combine(Init.BasePath, "config.json"));
                       Init.Initialize();
                   }
                    );
            }
        }
    }
    [ObservableProperty]
    public List<UserItem> _UserModelList;
    [ObservableProperty]
    private bool _IsPaneShow= false;
    [ObservableProperty]
    public UserControl _AccountPane;

    [RelayCommand]
    private void NewUserModel()
    {
        IsPaneShow = true;
        AccountPane = new UserModelLoginPane(this);
    }
    [RelayCommand]
    private void SkinManger(UserModel userModel)
    {
        IsPaneShow = true;
        AccountPane = new SkinMangerPane(this,userModel);
    }
    
    [RelayCommand]
    private void SetDefault(UserItem user)
    {
        UserModelList.Select(x => x.IsDefault = false);
        user.IsDefault = true;
        _accountManager.SetDefault(user.um.UserID);
        RefList();
        MainWindow.mainwindow.ShowFlyout($"已将默认用户模型设置为{user.um.Name}");
    }
    [RelayCommand]
    private void DeleteUser(UserModel user)
    {
        if (user.IsMsaUser)
            _msalAuthenticator.RemoveAccount(
                Tools.UseAccountIDToFind(user.AccountID).Result);
        _accountManager.RemoveUser(user.UserID);
        RefList();
        MainWindow.mainwindow.ShowFlyout($"已移除用户模型{user.Name}", true);
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/BaseViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Data.Converters;
using CommunityToolkit.Mvvm.ComponentModel;
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.ViewModels;
public class ModEnumToStringConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is ModEnum modEnum)
        {
            return modEnum switch
            {
                ModEnum.none => "原版",
                ModEnum.fabric => "Fabric",
                ModEnum.neoforge => "NeoForge",
                ModEnum.forge => "Forge",
                _ => value.ToString() // 作为备用，显示原始名称
            };
        }
        return value;
    }

    // ConvertBack 通常用于双向绑定，这里我们用不到，但接口要求实现
    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
public class BaseViewModel : ObservableObject
{
    
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/DownloadPageViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using OneLauncher.Codes;
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Minecraft;
using OneLauncher.Views;
using OneLauncher.Views.Panes;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Input;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.Panes.PaneViewModels.Factories;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Core.Helper.Models;

namespace OneLauncher.Views.ViewModels;
internal class DownloadPageClosePaneControlMessage { public bool value = false; }
internal partial class DownloadPageViewModel : BaseViewModel
{
    private readonly DownloadPaneViewModelFactory _viewFactory;
    // 这里要异步初始化的，但是屎山懒得修了
    private async Task VersionManifestReader()
    {
        VersionsList vl;
        if (!File.Exists(Path.Combine(Init.BasePath, "version_manifest.json")))
        {
            // 如果不存在版本清单则调用下载方法
            try
            {
                // 路径（1）
                using (Download download = new Download())
                    await download.DownloadFile(
                        "https://piston-meta.mojang.com/mc/game/version_manifest.json",
                        Path.Combine(Init.BasePath, "version_manifest.json")
                    );
                vl = new VersionsList(await File.ReadAllTextAsync(Path.Combine(Init.BasePath, "version_manifest.json")));
            }
            catch (HttpRequestException ex)
            {
                throw new OlanException(
                    "无法加载下载版本列表", 
                    "无法进行网络请求，且本地文件不存在", 
                    OlanExceptionAction.Error,
                    ex,
                    () => _=VersionManifestReader());
            }
        }
        vl = new VersionsList(await File.ReadAllTextAsync(Path.Combine(Init.BasePath, "version_manifest.json")));
        ReleaseItems = Init.MojangVersionList = vl.GetReleaseVersionList();
        IsLoaded = true;
    }
    public DownloadPageViewModel(DownloadPaneViewModelFactory viewFactory)
    {
        this._viewFactory = viewFactory;
        _=VersionManifestReader();
        // 
        WeakReferenceMessenger.Default.Register<DownloadPageClosePaneControlMessage>(this,(re,message) => IsPaneShow = message.value);
    }
    [ObservableProperty] private bool isLoaded = false;
    [ObservableProperty] private List<VersionBasicInfo> releaseItems;
    [ObservableProperty] private VersionBasicInfo? selectedItem;
    partial void OnSelectedItemChanged(VersionBasicInfo value)
    {
        if(value != null)
            ToDownload(value);
    }
    [ObservableProperty] public UserControl _DownloadPaneContent;
    [ObservableProperty] public bool _IsPaneShow = false;
    [ObservableProperty] public bool _IsAllowDownloading;

    [RelayCommand]
    private void ToDownload(VersionBasicInfo vbi)
    {
        IsPaneShow = true;
        DownloadPaneContent = new DownloadPane()
        {DataContext = _viewFactory.Create(vbi)};
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/GameDataPageViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft;
using OneLauncher.Core.Mod.ModPack;
using OneLauncher.Views.Panes;
using OneLauncher.Views.Panes.PaneViewModels;
using OneLauncher.Views.Panes.PaneViewModels.Factories;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace OneLauncher.Views.ViewModels;
internal class GameDataPageClosePaneControlMessage { public bool value = false;}
internal class GameDataPageDisplayListRefreshMessage { }
internal partial class GameDataItem : BaseViewModel
{
    public GameData data { get; set; }
    public bool IsDefault { get; }
    public Bitmap Icon { get; set; }
    public bool IsUseDebugModLaunch {  get; set; }
    [RelayCommand]
    public void Launch(GameData gameData)
    {
        _=version.EasyGameLauncher(gameData,IsUseDebugModLaunch);
    }
    public GameDataItem(GameData gameData,GameDataManager gameDataManager)
    {
        data = gameData;

        // 检查自己是否是其对应版本的默认实例
        var defaultInstance = gameDataManager.GetDefaultInstance(gameData.VersionId);
        IsDefault = (defaultInstance != null && defaultInstance.InstanceId == gameData.InstanceId);
        if (!string.IsNullOrEmpty(data.CustomIconPath) && File.Exists(data.CustomIconPath))
        {
            try { Icon = new Bitmap(data.CustomIconPath); return; }
            catch (Exception) { /* 忽略错误，使用默认图标 */ }
        }
        string iconUri = data.ModLoader switch
        {
            ModEnum.fabric => "avares://OneLauncher/Assets/Imgs/fabric.png",
            ModEnum.neoforge => "avares://OneLauncher/Assets/Imgs/neoforge.png",
            ModEnum.forge => "avares://OneLauncher/Assets/Imgs/forge.jpg",
            _ => "avares://OneLauncher/Assets/Imgs/basic.png", // 草方块
        };
        Icon = new Bitmap(AssetLoader.Open(new Uri(iconUri)));
    }
}
internal partial class GameDataPageViewModel : BaseViewModel
{
    private readonly GameDataManager _gameDataManager;
    private readonly NewGameDataPaneViewModel _newVM;
    private readonly EditGameDataPaneViewModelFactory _editVMFactory;
    private readonly PowerPlayPaneViewModelFactory _mctVMFactory;
    [ObservableProperty] public List<GameDataItem> gameDataList = new();
    [ObservableProperty] public string type;
    [ObservableProperty] public UserControl paneContent;
    [ObservableProperty] public bool isPaneShow;
    // 刷新列表
    public void RefList()
    {
        GameDataList = _gameDataManager.Data.Instances.Select(x => new GameDataItem(x.Value,_gameDataManager)).ToList();
    }
    /* 由PaneViewModel实现 */
    //// 修改特定的游戏数据实例
    //public void UpdateGameData(GameData updatedData)
    //{
    //    var index = Init.GameDataManger.AllGameData.FindIndex(gd => gd.InstanceId == updatedData.InstanceId);
    //    if (index != -1)
    //    {
    //        Init.GameDataManger.AllGameData[index] = updatedData;
    //    }
    //}
    public GameDataPageViewModel(
        GameDataManager gameDataManager,
        NewGameDataPaneViewModel NewVM,
        EditGameDataPaneViewModelFactory editGameDataPaneViewModelFactory,
        PowerPlayPaneViewModelFactory powerPlayPaneViewModelFactory
        )
    {
        this._mctVMFactory = powerPlayPaneViewModelFactory;
        this._editVMFactory = editGameDataPaneViewModelFactory;
        this._newVM = NewVM;
        this._gameDataManager = gameDataManager;
#if DEBUG
        // 造密码的Avalonia设计器天天报错
        // 设计时数据
        if (Design.IsDesignMode)
        {
            // 创建一个临时的、仅用于设计的假用户模型
            var designTimeUser = Guid.NewGuid();
            var gameData1 = new GameData(
                name: "纯净生存 (设计时)",
                versionId: "1.21",
                loader: ModEnum.none,
                userModel: designTimeUser
            );

            var gameData2 = new GameData(
                name: "Fabric 模组包 (设计时)",
                versionId: "1.20.4",
                loader: ModEnum.fabric,
                userModel: designTimeUser
            );

            // 将创建好的 GameData 包装成 GameDataItem 并添加到列表
            GameDataList = new List<GameDataItem>()
        {
            new GameDataItem(gameData1,_gameDataManager),
            new GameDataItem(gameData2,_gameDataManager)
        };
        }
        else
#endif
        {
            // 把配置文件的游戏数据列表显示到UI
            OnPageLoaded();
            // 提前初始化联机模块
            _connentServiceInitializationTasker = _mctVMFactory.CreateAsync();
            // 注册消息
            WeakReferenceMessenger.Default.Register<GameDataPageClosePaneControlMessage>(this,(re,message) => IsPaneShow = message.value);
            WeakReferenceMessenger.Default.Register<GameDataPageDisplayListRefreshMessage>(this, (re, message) => RefList());
        }
    }
    [RelayCommand]
    void OnPageLoaded()
    {
        try
        {
            RefList();
        }
        catch (NullReferenceException ex)
        {
            throw new OlanException(
                "无法初始化",
                "在游戏数据管理器页面读取配置文件时失败",
                OlanExceptionAction.FatalError,
                ex,
               () =>
               {
                   File.Delete(Path.Combine(Init.GameRootPath, "instance", "instance.json"));
                   Init.Initialize().Wait();
               }
                );
        }
    }
    [RelayCommand]
    public void NewGameData()
    {
        IsPaneShow = true;
        PaneContent = new NewGameDataPane()
        { DataContext =  _newVM};
    }
    [RelayCommand]
    public void ShowEditPane(GameData data)
    {
        IsPaneShow = true;
        PaneContent = new EditGameDataPane()
        { DataContext = _editVMFactory.Create(data) };
    }
    [RelayCommand]
    private async Task SetAsDefaultInstance(GameData targetData)
    {
        if (targetData == null) return;
        await _gameDataManager.SetDefaultInstanceAsync(targetData);
        RefList();
        WeakReferenceMessenger.Default.Send(
            new MainWindowShowFlyoutMessage($"已将 '{targetData.Name}' 设为版本 {targetData.VersionId} 的默认实例。"));
        //MainWindow.mainwindow.ShowFlyout($"已将 '{targetData.Name}' 设为版本 {targetData.VersionId} 的默认实例。");
    }
    [RelayCommand]
    public void Sorting(SortingType type)
    {
        List<GameDataItem> orderedList = type switch
        {
            SortingType.AnTime_OldFront => GameDataList.OrderBy(x => x.data.CreationTime).ToList(),
            SortingType.AnTime_NewFront => GameDataList.OrderByDescending(x => x.data.CreationTime).ToList(),
            SortingType.AnVersion_OldFront => GameDataList.OrderBy(x => new Version(x.data.VersionId)).ToList(),
            SortingType.AnVersion_NewFront => GameDataList.OrderByDescending(x => new Version(x.data.VersionId)).ToList(),
            _ => GameDataList // 默认不排序
        };

        GameDataList = orderedList;
        _gameDataManager.Data.Instances = GameDataList.ToDictionary(x => x.data.InstanceId,x => x.data);
        _=_gameDataManager.Save();
    }
    private PowerPlayPane? _powerPlayGo;
    private Task<PowerPlayPaneViewModel> _connentServiceInitializationTasker;
    [RelayCommand]
    public async Task PowerPlay()
    {
        // 只有当第一次点击时才创建
        if (_powerPlayGo == null)
        {
            WeakReferenceMessenger.Default.Send(
                new MainWindowShowFlyoutMessage("正在加载联机模块，请稍后..."));

            try
            {
                // 外部创建好
                var viewModel = await _connentServiceInitializationTasker;
                _powerPlayGo = new PowerPlayPane { DataContext = viewModel };
            }
            catch (OlanException ex)
            {
                await OlanExceptionWorker.ForOlanException(ex);
                IsPaneShow = false; // 出错时隐藏Pane
                return;
            }
            catch (Exception ex)
            {
                await OlanExceptionWorker.ForUnknowException(ex);
                IsPaneShow = false; // 出错时隐藏Pane
                return;
            }
        }

        // 将已经创建好的、包含完整数据的Pane设置为内容并显示
        PaneContent = _powerPlayGo;
        IsPaneShow = true;
    }
    [RelayCommand]
    public async Task Import()
    {
        var topLevel = TopLevel.GetTopLevel(MainWindow.mainwindow);
        if (topLevel?.StorageProvider is { } storageProvider && storageProvider.CanOpen)
        {
            var mrpackFileType = new FilePickerFileType("Modrinth整合包文件")
            {
                Patterns = new[] { "*.mrpack" },
                MimeTypes = new[] { "application/mrpack" }
            };

            var options = new FilePickerOpenOptions
            {
                Title = "选择 Modrinth Pack 文件",
                AllowMultiple = false,
                FileTypeFilter = new[] { mrpackFileType },
            };
            var files = await storageProvider.OpenFilePickerAsync(options);
            var selectedFile = files.FirstOrDefault();

            if (files == null || !files.Any() || selectedFile == null)
                return;

            string filePath = selectedFile.Path.LocalPath;
            WeakReferenceMessenger.Default.Send(new MainWindowShowFlyoutMessage("正在导入。。。（这可能需要较长时间）"));
            //MainWindow.mainwindow.ShowFlyout("正在导入。。。（这可能需要较长时间）");
            await ModpackImporter.ImportFromMrpackAsync(filePath, Init.GameRootPath, CancellationToken.None);
            WeakReferenceMessenger.Default.Send(new MainWindowShowFlyoutMessage("导入完成！"));
            //MainWindow.mainwindow.ShowFlyout("导入完成！");
            RefList();
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/HomePageViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using OneLauncher.Codes;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;

namespace OneLauncher.Views.ViewModels;

internal partial class HomePageViewModel : BaseViewModel
{
    private readonly GameDataManager _gameDataManager;
    private readonly DBManager _configManager;
    [ObservableProperty] private List<GameData> launchItems;
    [ObservableProperty] private GameData? selectedGameData;
    [ObservableProperty] private bool isShowServerOption;
    public HomePageViewModel(GameDataManager gameDataManager,DBManager configManager)
    {
        this._configManager = configManager;
        this._gameDataManager = gameDataManager;
        LaunchItems = _gameDataManager.AllGameData;
        SelectedGameData = _gameDataManager.Data.Instances.GetValueOrDefault(_configManager.Data.DefaultInstanceID);
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
    }
    [RelayCommand]
    public void Launch()
    {
        if(SelectedGameData == null)
        {
            MainWindow.mainwindow.ShowFlyout("未指定默认实例！",true);
            return;
        }
        _ = version.EasyGameLauncher(SelectedGameData);
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/ModsBrowserViewModel.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.ModService.Modrinth;
using OneLauncher.Core.Net.ModService.Modrinth.JsonModelSearch;
using OneLauncher.Views.Panes;
using OneLauncher.Views.Panes.PaneViewModels.Factories;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Input;

namespace OneLauncher.Views.ViewModels;
internal class ModsBrowserClosePaneControlMessage { public bool value = false; }
internal partial class ModItem : BaseViewModel
{
    public static List<ModItem> Create(ModrinthSearch info)
    {
        List<ModItem> modItems = new List<ModItem>();
        using (var httpClient = new HttpClient())
        {
            foreach (var item in info.Hits)
            {
                var i = new ModItem()
                {
                    Title = item.Title,
                    Description = item.Description,
                    ID = item.ProjectId,
                    time = item.DateCreated,
                    SupportVersions = Tools.McVsFilter(item.Versions),
                    IconUrl = new Uri((
                        // 处理某个缺德作者不加图标的情况
                        (string.IsNullOrEmpty(item.IconUrl))
                        ? "https://img.icons8.com/carbon-copy/100/border-none.png" : item.IconUrl)),
                    // 默认初始化 SupportModType
                    SupportModType = new ModType() // 初始化为默认值（bool为false）
                };

                // 获取 SupportModType 的副本
                ModType currentModType = i.SupportModType;

                foreach (var j in item.Categories)
                {
                    if (j == "fabric")
                        currentModType.IsFabric = true; // 修改副本
                    if (j == "neoforge")
                        currentModType.IsNeoForge = true; // 修改副本
                }

                // 将修改后的副本赋值回原属性
                i.SupportModType = currentModType;

                modItems.Add(i);
            }
        }
        return modItems;
    }
    public string Title { get; set; }
    public Uri IconUrl { get; set; }
    public string Description { get; set; }
    public string ID { get; set; }
    public List<string> SupportVersions { get; set; } = new List<string>();
    public ModType SupportModType { get; set; }
    public DateTime time { get; set; }
}
internal partial class ModsBrowserViewModel : BaseViewModel
{
    private readonly InstallModPaneViewModelFactory _paneVMFactory;
    public ModsBrowserViewModel(InstallModPaneViewModelFactory installModPaneViewModelFactory)
    {
        this._paneVMFactory = installModPaneViewModelFactory;   
        // 初始搜索显示热门结果
        _ =ToSearch(); // 失败就不显示任何结果
        WeakReferenceMessenger.Default.Register<ModsBrowserClosePaneControlMessage>(this, (r, m) =>IsPaneShow = m.value);
    }
    [ObservableProperty]
    public bool _IsPaneShow = false;
    [ObservableProperty]
    public UserControl _InstallModPaneContent = new UserControl();
    [ObservableProperty]
    public string _SearchContent = string.Empty;
    [ObservableProperty]
    public List<ModItem> searchItems;
    [RelayCommand]
    public async Task ToSearch()
    {
        using (SearchModrinth SearchTask = new SearchModrinth())
        {
            SearchItems = ModItem.Create(await SearchTask.ToSearch(SearchContent));
        }
    }
    [RelayCommand]
    public void ToInstallMod(ModItem item)
    {
        IsPaneShow = true;
        InstallModPaneContent = new InstallModPane()
        { DataContext = _paneVMFactory.Create(item) };
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/SettingsPageViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using CommunityToolkit.Mvvm.ComponentModel;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.ViewModels;

internal partial class SettingsPageViewModel : BaseViewModel
{
    // 将 manager 重命名为 _dbManger 以遵循常见的私有字段命名约定
    private readonly DBManager _dbManger;

    [ObservableProperty]
    public bool isM1, isM2, isM3;

    partial void OnIsM1Changed(bool value)
    {
        if (!value) return; // 避免在取消选中时也执行
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.MinecraftJvmArguments = JvmArguments.CreateFromMode(OptimizationMode.Conservative);
        _dbManger.Save();
    }
    partial void OnIsM2Changed(bool value)
    {
        if (!value) return;
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.MinecraftJvmArguments = JvmArguments.CreateFromMode(OptimizationMode.Standard);
        _dbManger.Save();
    }
    partial void OnIsM3Changed(bool value)
    {
        if (!value) return;
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.MinecraftJvmArguments = JvmArguments.CreateFromMode(OptimizationMode.Aggressive);
        _dbManger.Save();
    }

    #region 下载选项
    [ObservableProperty]
    public int _MaxDownloadThreadsValue;
    partial void OnMaxDownloadThreadsValueChanged(int value)
    {
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.MaximumDownloadThreads = value;
        _dbManger.Save();
    }

    [ObservableProperty]
    public int _MaxSha1ThreadsValue;
    partial void OnMaxSha1ThreadsValueChanged(int value)
    {
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.MaximumSha1Threads = value;
        _dbManger.Save();
    }

    [ObservableProperty]
    public bool _IsSha1Enabled;
    partial void OnIsSha1EnabledChanged(bool value)
    {
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.IsSha1Enabled = value;
        _dbManger.Save();
    }

    [ObservableProperty]
    public bool _IsAllowUseBMLCAPI;
    partial void OnIsAllowUseBMLCAPIChanged(bool value)
    {
#if DEBUG
        if (Design.IsDesignMode)
            return;
#endif
        // 使用注入的实例
        _dbManger.Data.OlanSettings.IsAllowToDownloadUseBMLCAPI = value;
        _dbManger.Save();
    }

    #endregion

    // 构造函数接收正确的 DBManger 类型
    public SettingsPageViewModel(DBManager configManager)
    {
        this._dbManger = configManager;
#if DEBUG
        if (Design.IsDesignMode)
        {
            MaxDownloadThreadsValue = 24;
            MaxSha1ThreadsValue = 24;
            IsSha1Enabled = true;
            return; // 在设计模式下提前返回
        }
#endif
        // else 块不再需要，因为非 DEBUG 模式下总会执行下面的代码

        try
        {
            // 使用注入的实例来初始化属性
            switch (_dbManger.Data.OlanSettings.MinecraftJvmArguments.mode)
            {
                case OptimizationMode.Conservative:
                    IsM1 = true;
                    break;
                case OptimizationMode.Standard:
                    IsM2 = true;
                    break;
                case OptimizationMode.Aggressive:
                    IsM3 = true;
                    break;
            }
            MaxDownloadThreadsValue = _dbManger.Data.OlanSettings.MaximumDownloadThreads;
            MaxSha1ThreadsValue = _dbManger.Data.OlanSettings.MaximumSha1Threads;
            IsSha1Enabled = _dbManger.Data.OlanSettings.IsSha1Enabled;
            IsAllowUseBMLCAPI = _dbManger.Data.OlanSettings.IsAllowToDownloadUseBMLCAPI;
        }
        catch (NullReferenceException ex)
        {
            // 异常处理中的静态调用暂时保留，因为这是更深层次的重构问题
            throw new OlanException(
                "内部异常",
                "配置文件特定部分设置部分为空，这可能是新版和旧版配置文件不兼容导致的",
                OlanExceptionAction.FatalError,
                ex,
               () =>
               {
                   File.Delete(Path.Combine(Init.BasePath, "config.json"));
                   Init.Initialize(); // 注意：这个静态调用最终也应被移除
               }
            );
        }
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/ViewModels/VersionPageViewModel.cs
【代码拼接器】文件内容开始
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Codes;
using OneLauncher.Core.Compatible.ImportPCL2Version;
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Downloader.DownloadMinecraftProviders;
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.ImportPCL2Version;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft.Server;
using OneLauncher.Views.Panes;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.Json.Nodes;
using System.Threading.Tasks;

namespace OneLauncher.Views.ViewModels;
internal class VersionPageClosePaneControlMessage { public bool value = false; }
internal partial class VersionItem : BaseViewModel
{
    /// <param Name="a">UserVersion实例</param>
    /// <param Name="IndexInInit">UserVsersion实例在整个Init.ConfigManager.config.VersionList中的索引值</param>
    public VersionItem(UserVersion a)
    {
        versionExp = a;
    }
    public UserVersion versionExp { get; set; }
    [RelayCommand]
    public async Task LaunchGame()
    {
        GameData gameData = await Init.GameDataManager.GetOrCreateInstanceAsync(versionExp);
        _=new Game().LaunchGame(gameData,null,true);
    }
    [RelayCommand]
    public void ReadMoreInformations()
    {

    }
    [RelayCommand]
    public void OpenServerFolder()
    {
        string path = Path.Combine(Init.GameRootPath,"versions",versionExp.VersionID,"servers");
        if (!Directory.Exists(path))
            OlanExceptionWorker.ForOlanException(
                new OlanException("无法打开服务端文件夹","服务端尚未初始化",OlanExceptionAction.Error));
        else
            Tools.OpenFolder(path);
    }
}
internal partial class VersionPageViewModel : BaseViewModel
{
    private readonly DBManager _dBManager;
    private void RefList()
    {
        //var tempVersoinList = new List<VersionItem>(_dBManager.Data.VersionList.Count);
        //for (int i = 0; i < tempVersoinList.Count; i++)
        //{
        //    tempVersoinList.Add(new VersionItem(
        //        Init.ConfigManger.Data.VersionList[i], i));
        //}
        VersionList = _dBManager.Data.VersionList.Select(x => new VersionItem(x)).ToList();
    }
    public VersionPageViewModel(DBManager dBManager)
    {
        this._dBManager = dBManager;
#if DEBUG
        // 设计时数据
        if (Design.IsDesignMode)
        {
            VersionList = new List<VersionItem>()
            {
                new VersionItem(new UserVersion() 
                {
                    VersionID="1.21.5",
                    AddTime=DateTime.Now
                })
            };
        }
        else
#endif
        {
            try
            {
                RefList();
            }
            catch (NullReferenceException ex)
            {
                throw new OlanException(
                    "内部异常",
                    "配置文件特定部分版本部分为空，这可能是新版和旧版配置文件不兼容导致的",
                    OlanExceptionAction.FatalError,
                    ex,
                   () => {
                       File.Delete(Path.Combine(Init.BasePath, "config.json"));
                       Init.Initialize();
                   });
            }
            WeakReferenceMessenger.Default.Register<VersionPageClosePaneControlMessage>(this, (re, message) =>IsPaneShow = message.value);
        } 
    }
    [RelayCommand]
    protected void PageLoaded()
    {
        try
        {
            RefList();
        }
        catch (NullReferenceException ex)
        {
            throw new OlanException(
                "内部异常",
                "配置文件特定部分版本列表部分为空，这可能是新版和旧版配置文件不兼容导致的",
                OlanExceptionAction.FatalError,
                ex,
               () =>
               {
                   File.Delete(Path.Combine(Init.BasePath, "config.json"));
                   Init.Initialize().GetAwaiter().GetResult();
               });
        }
    }
    [ObservableProperty]
    public List<VersionItem> _versionList;
    [ObservableProperty]
    public UserControl _refDownPane;
    [ObservableProperty]
    public bool _isPaneShow;
    [RelayCommand]
    public void Sorting(SortingType type)
    {
        List<VersionItem> orderedList = type switch
        {
            SortingType.AnTime_OldFront => VersionList.OrderBy(x => x.versionExp.AddTime).ToList(),
            SortingType.AnTime_NewFront => VersionList.OrderByDescending(x => x.versionExp.AddTime).ToList(),
            SortingType.AnVersion_OldFront => VersionList.OrderBy(x => new Version(x.versionExp.VersionID)).ToList(),
            SortingType.AnVersion_NewFront => VersionList.OrderByDescending(x => new Version(x.versionExp.VersionID)).ToList(),
            _ => VersionList // 默认不排序
        };

        VersionList = orderedList; 
        _dBManager.Data.VersionList = VersionList.Select(x => x.versionExp).ToList();
        _=_dBManager.Save();
    }
    [RelayCommand]
    public async Task OpenServer(UserVersion versionExp)
    {
        try
        {
            // 去尝试读取，判断这个服务端版本是否启用了版本隔离
            bool IsVI = true;
            if (Directory.Exists(Path.Combine(Init.GameRootPath, "versoins", versionExp.VersionID, "servers")))
                IsVI = true;
            else if (Directory.Exists(Path.Combine(Init.GameRootPath, "servers")))
                IsVI = false;
            string versionPath = Path.Combine(Init.GameRootPath, "versions", versionExp.VersionID);
            // 判断服务端是否已经完成初始化
            if (!File.Exists(Path.Combine(versionPath, "server.jar")))
            {
                IsPaneShow = true;
                RefDownPane = new InitServerPane(versionExp.VersionID);
            }
            else       
                MinecraftServerManger.Run(versionPath,
                    // 读取源文件获取Java版本
                    (await JsonNode.ParseAsync(
                        File.OpenRead(
                            Path.Combine(versionPath, $"{versionExp.VersionID}.json"))))
                                ?["javaVersion"]
                                ?["majorVersion"]
                                ?.GetValue<int>()
                                ?? Tools.ForNullJavaVersion(versionExp.VersionID)
                                , IsVI);
            
        }
        catch (OlanException ex)
        {
            await OlanExceptionWorker.ForOlanException(ex);
        }
    }
    [RelayCommand]
    public async Task ImportVersionByPCL2()
    {
        //var topLevel = TopLevel.GetTopLevel(MainWindow.mainwindow);
        //if (topLevel?.StorageProvider is { } storageProvider && storageProvider.CanOpen)
        //{
        //    var options = new FolderPickerOpenOptions
        //    {
        //        Title = "选择你的PCL2版本文件夹",
        //        AllowMultiple = false,
        //    };
        //    var files = await storageProvider.OpenFolderPickerAsync(options);
        //    var selectedFile = files.FirstOrDefault();

        //    if (files == null || !files.Any() || selectedFile == null)
        //        return;

        //    string path = selectedFile.Path.LocalPath;
        //    var dirs = Directory.GetDirectories(path);
        //    Debug.WriteLine(path);
        //    foreach (var item in dirs)
        //    {
        //        Debug.WriteLine(item);
        //        if (item == Path.Combine(path,"PCL"))
        //        {
        //            MainWindow.mainwindow.ShowFlyout("正在导入。。。（这可能需要较长时间）");
        //            await new PCL2Importer(new Progress<(DownProgress Title, int AllFiles, int DownedFiles, string DowingFileName)>(p => {
        //                Debug.WriteLine($"Titli:{p.Title}\nAll:{p.AllFiles},Down:{p.DownedFiles}\nOutput:\n{p.DowingFileName}");
        //            })).ImportAsync(path);
        //            MainWindow.mainwindow.ShowFlyout("导入完成！");
        //            RefList();
        //            return;
        //        }
        //    }
        //    MainWindow.mainwindow.ShowFlyout("这不是有效的PCL版本文件夹",true);
        //}
    }
}


【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/ExceptionTip.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Core.Global;
using OneLauncher.Views.Windows.WindowViewModels;
using System;
using System.Threading.Tasks;

namespace OneLauncher.Views.Windows;
public partial class ExceptionTip : Window
{
    private readonly OlanException olanException;
    public ExceptionTip(OlanException olanException,Action TAF = null)
    {
        InitializeComponent();
        this.olanException = olanException;
        if(TAF != null)
            this.olanException.TryAgainFunction = TAF;
        ErrorTitle.Text = olanException.Title;
        ErrorDetails.Text = olanException.Message;
    }

    private void TryAgainFunction(object? sender, Avalonia.Interactivity.RoutedEventArgs e)
    {
        if (this.olanException.TryAgainFunction != null)
            this.olanException.TryAgainFunction();
    }
    private void IgnoreFunction(object? sender, Avalonia.Interactivity.RoutedEventArgs e)
    { 
        this.Close();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/GameTasker.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using OneLauncher.Views.Windows.WindowViewModels;

namespace OneLauncher.Views.Windows;

public partial class GameTasker : Window
{
    public GameTasker()
    {
        InitializeComponent();
        this.DataContext = new GameTaskerViewModel();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/PopUpPane.axaml.cs
【代码拼接器】文件内容开始
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace OneLauncher.Views.Windows;

public partial class PopUpPane : Window
{
    public PopUpPane(UserControl contont)
    {
        InitializeComponent();
        Content = contont;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/ExceptionTip.axaml
【代码拼接器】文件内容开始
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d" d:DesignWidth="300" d:DesignHeight="230"
        x:Class="OneLauncher.Views.Windows.ExceptionTip"
		ExtendClientAreaToDecorationsHint="True"
		ExtendClientAreaChromeHints="NoChrome"
		ExtendClientAreaTitleBarHeightHint="30"
		Width="300" Height="230"
        Title="异常窗口">
	<Grid Margin="24" RowDefinitions="*,*,*">
		<StackPanel Grid.Row="0">
			<StackPanel Orientation="Horizontal">
				<Image Source="/Assets/icos/error.png" Width="52" Height="52"/>
				<TextBlock x:Name="ErrorTitle" FontSize="24" VerticalAlignment="Center" FontWeight="Bold"/>
			</StackPanel>
			<ScrollViewer>
				<SelectableTextBlock Margin="12,0,0,0" x:Name="ErrorDetails" TextWrapping="Wrap"/>
			</ScrollViewer>
		</StackPanel>
		<StackPanel Grid.Row="2" Orientation="Horizontal" Spacing="6" HorizontalAlignment="Right" VerticalAlignment="Bottom">
			<Button Click="TryAgainFunction" Content="重试"/>
			<Button Click="IgnoreFunction" Content="忽略"/>
		</StackPanel>
	</Grid>
</Window>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/GameTasker.axaml
【代码拼接器】文件内容开始
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
		xmlns:vm="using:OneLauncher.Views.Windows.WindowViewModels"
		x:DataType="vm:GameTaskerViewModel"
		x:CompileBindings="True"
        mc:Ignorable="d" d:DesignWidth="250" d:DesignHeight="320"
        x:Class="OneLauncher.Views.Windows.GameTasker"
		Icon="/Assets/window-logo.ico"
        Title="游戏监视器" Width="250" Height="320">
	<Grid RowDefinitions="32,*" Margin="12">
		<TextBlock Grid.Row="0" Text="你可以安全的关闭此窗口"/>
		<ScrollViewer Grid.Row="1">
			<SelectableTextBlock Text="{Binding Out}" TextWrapping="NoWrap"/>
		</ScrollViewer>
	</Grid>
</Window>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/PopUpPane.axaml
【代码拼接器】文件内容开始
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d" d:DesignWidth="650" d:DesignHeight="620"
		Width="650" Height="620"
        x:Class="OneLauncher.Views.Windows.PopUpPane"
        Title="弹出窗口">
		<ContentControl x:Name="Contont"/>
</Window>

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher/Views/Windows/WindowViewModels/GameTaskerViewModel.cs
【代码拼接器】文件内容开始
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Messaging;
using OneLauncher.Views.ViewModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Views.Windows.WindowViewModels;
internal class GameMessage
{
    public string Content { get; }

    public GameMessage(string content)
    {
        Content = content;
    }
}
internal partial class GameTaskerViewModel : BaseViewModel
{
    [ObservableProperty]
    private string _Out = string.Empty; 

    private readonly System.Text.StringBuilder _logBuilder = new System.Text.StringBuilder();
    private const int MaxDisplayLength = 1024 * 50; 

    public GameTaskerViewModel()
    {
        WeakReferenceMessenger.Default.Register<GameMessage>(this, (recipient, message) =>
        {
            // 在 UI 线程上更新 UI 绑定属性，避免跨线程访问问题
            Avalonia.Threading.Dispatcher.UIThread.Post(() =>
            {
                _logBuilder.Append(message.Content);

                // 如果日志长度超过限制，截断最旧的部分
                if (_logBuilder.Length > MaxDisplayLength)
                {
                    // 移除旧的部分，保留最新的内容
                    // 通常移除一半或四分之一，以避免频繁截断
                    _logBuilder.Remove(0, _logBuilder.Length - (MaxDisplayLength / 2));
                }

                // 将 StringBuilder 的内容更新到绑定属性
                Out = _logBuilder.ToString();
            });
        });
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Console/boot.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Console;
public class boot
{
    public static async Task RunBoot(string[] args)
    {
        try
        {
            await Init.Initialize();
            if (args.Length != 2)
                return;
            switch (args[0])
            {
                case "--quicklyPlay":
                    await QuicklyPlay.GameLauncher.Launch(args[1]);
                    break;
            }
        }
        catch (Exception e) { 
            Environment.FailFast(e.ToString());
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Console/QuicklyPlay/GameLauncher.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Minecraft;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Console.QuicklyPlay;

internal class GameLauncher
{
    public static async Task Launch(string InstanceId)
    {
        //#region 初始化基本游戏构建类
        //GameData launchInstance = Init.GameDataManger.AllGameData.FirstOrDefault(x => x.InstanceId == InstanceId);
        //if (launchInstance == null)
        //    throw new Exception("无法找到您的游戏实例");
        //await Init.AccountManager.GetUser(launchInstance.DefaultUserModelID).IntelligentLogin(Init.MMA);
        //var Builder = new LaunchCommandBuilder
        //                (
        //                    Init.GameRootPath,
        //                    launchInstance,
        //                    null
        //                );
        //#endregion

        //using (Process process = new Process())
        //{
        //    process.StartInfo = new ProcessStartInfo()
        //    {
        //        Arguments =
        //        await Builder.BuildCommand(
        //            Init.ConfigManger.config.OlanSettings.MinecraftJvmArguments.ToString(Builder.versionInfo.GetJavaVersion())),
        //        FileName = Builder.GetJavaPath(),
        //        WorkingDirectory = Init.GameRootPath,
        //        RedirectStandardOutput = true,
        //        RedirectStandardError = true,
        //        UseShellExecute = false,
        //        CreateNoWindow = true,
        //        StandardOutputEncoding = Encoding.UTF8,
        //        StandardErrorEncoding = Encoding.UTF8
        //    };
        //    process.OutputDataReceived += (s,e) => System.Console.WriteLine(e.Data);
        //    process.ErrorDataReceived += (s, e) => System.Console.WriteLine(e.Data);
        //    process.Start();
        //    process.BeginOutputReadLine();
        //    process.BeginErrorReadLine();
        //    await process.WaitForExitAsync();
        //}  
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/Download.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.ModService.Modrinth;
using System.Buffers;
using System.Diagnostics;
using System.IO.Compression;
using System.Net.Http.Headers;
using System.Security.Cryptography;

namespace OneLauncher.Core.Downloader;

public partial class Download : IDisposable
{
    /// <summary>
    /// 解压 ZIP 结构文件到指定目录
    /// </summary>
    /// <param ID="filePath">待解压的文件路径（例如 .docx 或其他 ZIP 结构文件）</param>
    /// <param ID="extractPath">解压到的目标目录</param>
    /// <exception cref="IOException">文件访问或解压失败</exception>
    /// <exception cref="InvalidDataException">文件不是有效的 ZIP 格式</exception>
    public static void ExtractFile(string filePath, string extractPath)
    {
        try
        {
            // 确保输出目录存在
            Directory.CreateDirectory(extractPath);

            // 打开 ZIP 文件
            using (ZipArchive archive = ZipFile.OpenRead(filePath))
            {
                // 遍历 ZIP 条目
                foreach (ZipArchiveEntry entry in archive.Entries)
                {
                    // 确定解压路径
                    string destinationPath = Path.Combine(extractPath, entry.FullName);

                    // 确保目录存在
                    string destinationDir = Path.GetDirectoryName(destinationPath);
                    Directory.CreateDirectory(destinationDir);

                    // 仅处理文件（跳过目录）
                    if (!string.IsNullOrEmpty(entry.Name))
                    {
                        // 提取文件
                        entry.ExtractToFile(destinationPath, overwrite: true);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            throw;
        }
    }
    public Download(HttpClient? tc = null)
    {
        unityClient = tc ?? new HttpClient(new HttpClientHandler
        {
            MaxConnectionsPerServer = 32 
        })
        {
            Timeout = TimeSpan.FromSeconds(60) 
        };
        unityClient.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36");
    }
    public readonly HttpClient unityClient;

    /// <summary>
    /// 开始异步下载Mod（可选是否下载依赖项）
    /// </summary>
    /// <param Name="progress">进度回调：总字节数，已经下载的字节数，当前正在操作的文件名</param>
    /// <param Name="ModID">Mod ID （Modrinth）</param>
    /// <param Name="ModPath">Mods文件夹路径</param>
    /// <param Name="version">需要安装Mod的版本的版本号</param>
    /// <param Name="IsIncludeDependencies">是否下载依赖</param>
    /// <param Name="maxConcurrentDownloads">最大下载线程</param>
    /// <param Name="maxConcurrentSha1">最大Sha1校验线程</param>
    /// <param Name="IsSha1">是否校验Sha1</param>
    /// <returns></returns>
    public async Task StartDownloadMod(
        IProgress<(long AllSizes, long DownedSizes, string DowingFileName)> progress,
        string ModID,
        string ModPath,
        string version,
        bool IsIncludeDependencies = true,
        int maxConcurrentDownloads = 8,
        int maxConcurrentSha1 = 4,
        bool IsSha1 = true,
        CancellationToken? token = null
    )
    {
        CancellationToken cancellationToken = token ?? CancellationToken.None;

        var GetTask = new GetModrinth(ModID, version, ModPath);
        await GetTask.Init();

        // 获取主 Mod 文件信息
        NdDowItem? mainMod = GetTask.GetDownloadInfos();
        if (!mainMod.HasValue)
            return;

        List<NdDowItem> allFiles = new List<NdDowItem> { (NdDowItem)mainMod };

        // 如果需要下载依赖项，则获取依赖项信息并添加到下载列表
        if (IsIncludeDependencies)
        {
            List<NdDowItem> dependencies = GetTask.GetDependenciesInfos();
            if (dependencies != null)
                allFiles.AddRange(dependencies);
        }

        // 过滤掉已经存在的文件
        List<NdDowItem> filesToDownload = CheckFilesExists(allFiles, cancellationToken);
        if (!filesToDownload.Any())
        {
            long totalExistingBytes = allFiles.Sum(item => (long)item.size);
            progress?.Report((totalExistingBytes, totalExistingBytes, "所有文件均已存在。"));
            if (IsSha1)
            {
                progress?.Report((totalExistingBytes, totalExistingBytes, "正在校验文件..."));
                await CheckAllSha1(allFiles, maxConcurrentSha1, cancellationToken);
            }
            progress?.Report((totalExistingBytes, totalExistingBytes, "处理完成！"));
            return;
        }

        long totalBytesToDownload = filesToDownload.Sum(item => (long)item.size);

        // --- 优化点 1: 移除 fileDownloadProgressMap, 使用一个 long 变量通过原子操作更新 ---
        long accumulatedDownloadedBytes = 0;

        // --- 优化点 2: 为进度报告节流（Throttling）准备变量 ---
        int lastReportTimestamp = 0;
        const int reportIntervalMs = 100; // 每 100ms 报告一次

        // 初始报告总大小和0已下载
        progress?.Report((totalBytesToDownload, 0, "开始下载Mod文件..."));

        var semaphore = new SemaphoreSlim(maxConcurrentDownloads);

        await Parallel.ForEachAsync(
            filesToDownload,
            new ParallelOptions { MaxDegreeOfParallelism = maxConcurrentDownloads, CancellationToken = cancellationToken },
            async (item, ct) =>
            {
                await semaphore.WaitAsync(ct);
                try
                {
                    // ===== 主下载逻辑 =====
                    Directory.CreateDirectory(Path.GetDirectoryName(item.path)!);
                    using (var request = new HttpRequestMessage(HttpMethod.Get, item.url))
                    {
                        request.Headers.CacheControl = new CacheControlHeaderValue { NoCache = true, NoStore = true, MustRevalidate = true };
                        using (var response = await unityClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, ct))
                        {
                            response.EnsureSuccessStatusCode();
                            using (var httpStream = await response.Content.ReadAsStreamAsync(ct))
                            {
                                using (var fileStream = new FileStream(item.path, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: 8192, useAsync: true))
                                {
                                    var buffer = new byte[8192];
                                    int bytesRead;
                                    while ((bytesRead = await httpStream.ReadAsync(buffer, 0, buffer.Length, ct)) > 0)
                                    {
                                        await fileStream.WriteAsync(buffer, 0, bytesRead, ct);

                                        // --- 优化点 3: 使用 Interlocked.Add 进行无锁、线程安全的累加 ---
                                        Interlocked.Add(ref accumulatedDownloadedBytes, bytesRead);

                                        // --- 优化点 4: 节流，控制进度报告频率 ---
                                        int currentTimestamp = Environment.TickCount;
                                        if (currentTimestamp - lastReportTimestamp > reportIntervalMs)
                                        {
                                            lastReportTimestamp = currentTimestamp;
                                            // 报告总进度。第一个参数应为总大小，以确保进度条最大值稳定
                                            progress?.Report((totalBytesToDownload, accumulatedDownloadedBytes, Path.GetFileName(item.path)));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (HttpRequestException) // 注意：只捕获 HttpRequestException 以进入重试
                {
                    // ===== 重试逻辑 (内联) =====
                    const int maxRetries = 3;
                    for (int attempt = 0; attempt < maxRetries; attempt++)
                    {
                        try
                        {
                            await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt)), ct);
                            Directory.CreateDirectory(Path.GetDirectoryName(item.path)!);
                            using (var request = new HttpRequestMessage(HttpMethod.Get, item.url))
                            {
                                request.Headers.CacheControl = new CacheControlHeaderValue { NoCache = true, NoStore = true, MustRevalidate = true };
                                using (var response = await unityClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, ct))
                                {
                                    response.EnsureSuccessStatusCode();
                                    using (var httpStream = await response.Content.ReadAsStreamAsync(ct))
                                    {
                                        using (var fileStream = new FileStream(item.path, FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: 8192, useAsync: true))
                                        {
                                            var buffer = new byte[8192];
                                            int bytesRead;
                                            while ((bytesRead = await httpStream.ReadAsync(buffer, 0, buffer.Length, ct)) > 0)
                                            {
                                                await fileStream.WriteAsync(buffer, 0, bytesRead, ct);

                                                // --- 优化点 3 (同样应用于重试逻辑): 使用 Interlocked.Add ---
                                                Interlocked.Add(ref accumulatedDownloadedBytes, bytesRead);

                                                // --- 优化点 4 (同样应用于重试逻辑): 节流 ---
                                                int currentTimestamp = Environment.TickCount;
                                                if (currentTimestamp - lastReportTimestamp > reportIntervalMs)
                                                {
                                                    lastReportTimestamp = currentTimestamp;
                                                    progress?.Report((totalBytesToDownload, accumulatedDownloadedBytes, Path.GetFileName(item.path)));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            break; // 重试成功，跳出 for 循环
                        }
                        catch (HttpRequestException ex2)
                        {
                            Debug.WriteLine($"重试下载失败: {ex2.Message}, URL: {item.url}");
                            if (attempt == maxRetries - 1) // 最后一次重试也失败
                            {
                                throw new OlanException("下载失败", "重试到达阈值抛出", OlanExceptionAction.Error, ex2);
                            }
                        }
                    }
                }
                catch (Exception ex) // 捕获其他未知异常
                {
                    Debug.WriteLine($"下载文件时发生意外错误: {ex.Message}, URL: {item.url}");
                    throw; // 重新抛出异常，让上层处理
                }
                finally
                {
                    semaphore.Release();
                }
            }
        );

        if (IsSha1)
        {
            progress?.Report((totalBytesToDownload, totalBytesToDownload, "正在校验文件..."));
            await CheckAllSha1(allFiles, maxConcurrentSha1, cancellationToken);
        }

        // 确保最后一次进度是100%
        progress?.Report((totalBytesToDownload, totalBytesToDownload, "下载完成！"));
    }

    public async Task DownloadFileBig(
        string url,
        string savePath,
        long? knownSize,
        int maxSegments,
        IProgress<(long Start, long End)>? segmentProgress = null,
        CancellationToken token = default)
    {
        long fileSize;
        if (knownSize.HasValue)
            fileSize = knownSize.Value;
        else
        {
            using var headRequest = new HttpRequestMessage(HttpMethod.Head, url);
            headRequest.Headers.CacheControl = new CacheControlHeaderValue
            {
                NoCache = true,
                NoStore = true,
                MustRevalidate = true
            };

            using var headResponse = await unityClient.SendAsync(headRequest, token);
            headResponse.EnsureSuccessStatusCode();
            fileSize = headResponse.Content.Headers.ContentLength
                       ?? throw new OlanException("下载失败","无法确定文件大小。");
        }

        Directory.CreateDirectory(Path.GetDirectoryName(savePath)!);

        long interval = (fileSize + maxSegments - 1) / maxSegments;

        var segments = new List<(long Start, long End)>();
        for (long current = 0; current < fileSize; current += interval)
        {
            long end = Math.Min(current + interval - 1, fileSize - 1);
            segments.Add((current, end));
        }

        // 禁用FileStream内部缓冲，并使用WriteThrough模式
        // WriteThrough可以绕过操作系统缓存，对于随机写入可能提升性能
        await using var fileStream = new FileStream(
            savePath, FileMode.Create, FileAccess.Write, FileShare.None,
            bufferSize: 0, // 禁用缓冲
            FileOptions.Asynchronous
        );
        fileStream.SetLength(fileSize);
        var fileHandle = fileStream.SafeFileHandle;

        // 下载
        await Parallel.ForEachAsync(
            segments,
            new ParallelOptions { MaxDegreeOfParallelism = maxSegments, CancellationToken = token },
            async (segment, ct) =>
            {
                // 报告当前处理的分片范围
                segmentProgress?.Report((segment.Start, segment.End));

                // 租用内存池的缓冲区，顶级性能优化
                using var bufferOwner = MemoryPool<byte>.Shared.Rent(128 * 1024); // 128KB
                var buffer = bufferOwner.Memory;

                // 简单的重试逻辑
                const int maxRetries = 3;
                for (int attempt = 1; ; attempt++)
                {
                    try
                    {
                        using var request = new HttpRequestMessage(HttpMethod.Get, url);
                        request.Headers.Range = new RangeHeaderValue(segment.Start, segment.End);

                        using var response = await unityClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, ct);
                        response.EnsureSuccessStatusCode();

                        await using var httpStream = await response.Content.ReadAsStreamAsync(ct);

                        long position = segment.Start;
                        int bytesRead;
                        while ((bytesRead = await httpStream.ReadAsync(buffer, ct)) > 0)
                        {
                            // 使用 SafeFileHandle 和 RandomAccess 进行线程安全的并行写入
                            await RandomAccess.WriteAsync(fileHandle, buffer.Slice(0, bytesRead), position, ct);
                            position += bytesRead;
                        }

                        return; // 分片下载成功，退出重试循环
                    }
                    catch (HttpRequestException) when (attempt < maxRetries)
                    {
                        // 发生异常都简单等待后重试
                        await Task.Delay(200 * attempt, ct);
                    }
                }
            }
        );
    }

    public Task DownloadListAsync(
        IProgress<(int completedFiles, string FilesName)> progress,
        List<NdDowItem> downloadNds,
        int maxConcurrentDownloads,
        CancellationToken token)
    {
        int completedFiles = 0;

        return Parallel.ForEachAsync(
            downloadNds,
            new ParallelOptions
            {
                MaxDegreeOfParallelism = maxConcurrentDownloads,
                CancellationToken = token
            },
            async (item, ct) =>
            {
                try
                {
                    // 原子递增已完成文件数
                    Interlocked.Increment(ref completedFiles);
                    // 报告进度
                    progress?.Report((completedFiles, item.url));
                    // 执行下载操作
                    await DownloadFile(item.url, item.path, ct);
                }
                catch (HttpRequestException ex)
                {
                    for (int attempt = 0; attempt < 3; attempt++)
                    {
                        await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt)), ct);
                        try
                        {
                            await DownloadFile(item.url, item.path, ct);
                            return; // 成功下载，退出重试循环
                        }
                        catch (HttpRequestException ex2)
                        {
                            Debug.WriteLine($"重试下载失败: {ex2.Message}, URL: {item.url}");
                            continue;
                        }
                    }
                    throw new OlanException("下载失败", "重试到达阈值抛出", OlanExceptionAction.Error, ex);
                }
            });
    }
    public async Task DownloadFile(string url,string savepath, CancellationToken? token = null)
    {
        if (string.IsNullOrEmpty(url))
            return;
        CancellationToken cancellationToken = token ?? CancellationToken.None;
        using (var response = await unityClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead,cancellationToken))
        {
            response.EnsureSuccessStatusCode();
            using (var httpStream = await response.Content.ReadAsStreamAsync(cancellationToken))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(savepath));
                using (var fileStream = new FileStream(savepath, FileMode.Create, FileAccess.Write, FileShare.Write, bufferSize: 8192, useAsync: true))
                {
                    await httpStream.CopyToAsync(fileStream, 8192,cancellationToken);
                }
            }
        }
    }
    public async Task DownloadFileAndSha1(string url, string savepath,string sha1, CancellationToken token)
    {
        using (var response = await unityClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, token))
        {
            response.EnsureSuccessStatusCode();
            using (var httpStream = await response.Content.ReadAsStreamAsync(token))
            {
                var directory = Path.GetDirectoryName(savepath);
                if (!string.IsNullOrEmpty(directory))
                    Directory.CreateDirectory(directory);
                using (var fileStream = new FileStream(savepath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite, bufferSize: 8192, useAsync: true))
                {
                    await httpStream.CopyToAsync(fileStream, 8192, token);
                    fileStream.Position = 0;
                    using (var sha1Hash = SHA1.Create())
                    {
                        byte[] hash = await sha1Hash.ComputeHashAsync(fileStream,token);
                        string calculatedSha1 = BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
                        if (!string.Equals(calculatedSha1, sha1, StringComparison.OrdinalIgnoreCase))
                        {
                            throw new OlanException(
                                "下载失败",
                                $"无法校验文件({savepath})Sha1，实际：{calculatedSha1}预期：{sha1}",
                                OlanExceptionAction.Warning);
                        }
                    }
                }
            }
        }
    }
    public List<NdDowItem> CheckFilesExists(List<NdDowItem> FDI, CancellationToken token)
    {
        List<NdDowItem> filesToDownload = new List<NdDowItem>(FDI.Count);
        foreach (var item in FDI)
        {
            token.ThrowIfCancellationRequested();
            if (File.Exists(item.path))
                continue;
            filesToDownload.Add(item);
        }
        return filesToDownload;
    }
    public async Task CheckAllSha1(List<NdDowItem> FDI, int maxConcurrentSha1,CancellationToken token)
    {
        var semaphore = new SemaphoreSlim(maxConcurrentSha1);
        var sha1Tasks = new List<Task>(FDI.Count);
        foreach (var item in FDI)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrEmpty(item.sha1))
                continue;
            if (!File.Exists(item.path))
                continue;
            sha1Tasks.Add(Task.Run(async () =>
            {
                await semaphore.WaitAsync();
                using (var stream = new FileStream(item.path, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 8192, useAsync: true))
                using (var sha1Hash = SHA1.Create())
                {
                    byte[] hash = await sha1Hash.ComputeHashAsync(stream,token);
                    string calculatedSha1 = BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
                    if (!string.Equals(calculatedSha1, item.sha1, StringComparison.OrdinalIgnoreCase))
                    {
                        throw new OlanException(
                            "下载失败",
                            $"无法校验文件({item.path})Sha1，实际：{calculatedSha1}预期：{item.sha1}",
                            OlanExceptionAction.Warning);
                    }
                }
                
                semaphore.Release();
            },token));
        }
        await Task.WhenAll(sha1Tasks);
    }
    public void Dispose() => unityClient.Dispose();
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/DownloadInfo.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders;

public partial class DownloadInfo
{
    // 基本信息
    public string ID => VersionDownloadInfo.ID ?? VersionInstallInfo.VersionID ?? UserInfo.VersionId;
    public string GameRootPath { get; init; }
    
    // 核心下载组件与配置
    public Download DownloadTool { get; init; }
    public VersionInfomations VersionMojangInfo { get; init; }

    // 用户意图与版本选择
    public UserVersion VersionInstallInfo { get; init; } 
    public GameData UserInfo { get; init; } 
    public VersionBasicInfo VersionDownloadInfo { get; init; }

    // 可选参数
    // 下面三个是预留的参数
    public string SpecifiedFabricVersion { get; init; }
    public string SpecifiedForgeVersion { get; init; }
    public string SpecifiedNeoForgeVersion { get; init; }

    public bool IsAllowToUseBetaNeoforge { get; init; }
    public bool IsUseRecommendedToInstallForge { get; init; }
    public bool IsDownloadFabricWithAPI { get; init; }
    public bool AndJava { get; init; }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/DownloadInfoCreater.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders;

public partial class DownloadInfo
{
    private DownloadInfo() { }
    public static async Task<DownloadInfo> Create(
        string versionId,
        ModType modType,
        Download download,
        // 下面是一些下载选项
        bool isAllowToUseBetaNeoforge = false,
        bool isUseRecommendedToInstallForge = false,
        bool isDownloadFabricWithAPI = true,
        bool isDownloadWithJavaRuntime = true,
        // 下面是一些可传递可不传递的参数，不传递会自动获取
        VersionBasicInfo? versionBasic = null,
        GameData? gameDataD = null,
        string? gameRootPathD = null
        )
    {
        string gameRootPath = gameRootPathD ?? Init.GameRootPath;
        #region 查找一些资源
        // 创建默认实例
        ModEnum modEnum = modType.ToModEnum();
        string defaultInstanceModLoaderDisplayName =
            modEnum == ModEnum.fabric
            ? "fabric"
            : modEnum == ModEnum.neoforge
            ? "neoforge"
            : modEnum == ModEnum.forge
            ? "forge"
            : "原版";
        string defaultInstanceName = $"{versionId} - {defaultInstanceModLoaderDisplayName}";
        GameData gameData = gameDataD ?? new GameData(defaultInstanceName, versionId, modEnum, Init.AccountManager.GetDefaultUser().UserID);

        // 确定下载信息
        VersionBasicInfo versionDownloadInfo =
            versionBasic ??
            Init.MojangVersionList.FirstOrDefault(x => x.ID == versionId)
            ?? throw new OlanException("内部错误", "无法搜索到你需要下载版本的下载信息");

        // 确定版本信息
        UserVersion userVersion = new()
        {
            VersionID = versionId,
            modType = modType,
            AddTime = DateTime.Now,
        };
        #endregion
        #region 补全可能没有的资源
        VersionInfomations mations;

        var versionJsonSavePath = Path.Combine(userVersion.VersionPath, "version.json");

        if (!File.Exists(versionJsonSavePath))
            await download.DownloadFile(versionDownloadInfo.Url, versionJsonSavePath);
        mations = new VersionInfomations(
            await File.ReadAllTextAsync(versionJsonSavePath),
            gameRootPath
            );
        #endregion

        return new DownloadInfo()
        {
            DownloadTool = download,
            VersionMojangInfo = mations,

            VersionInstallInfo = userVersion,
            UserInfo = gameData,
            VersionDownloadInfo = versionDownloadInfo,

            IsAllowToUseBetaNeoforge = isAllowToUseBetaNeoforge,
            IsDownloadFabricWithAPI = isDownloadFabricWithAPI,
            IsUseRecommendedToInstallForge = isUseRecommendedToInstallForge,
            AndJava = isDownloadWithJavaRuntime,

            GameRootPath = gameRootPath,
        };
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/DownloadMinecraft.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft;
using OneLauncher.Core.Mod.ModLoader.fabric;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using OneLauncher.Core.Net.ModService.Modrinth;


namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders;
public partial class DownloadMinecraft
{
    private readonly DBManager _configManager;
    internal DownloadInfo info;

    public readonly CancellationToken cancelToken;
    public readonly IProgress<(DownProgress Title, int AllFiles, int DownedFiles, string DowingFileName)>? progress;
    public int maxDownloadThreads = 24;
    public int maxSha1Threads = 24;
    public int alls = 0;
    public int dones = 0;

    public DownloadMinecraft(
        DBManager configManager,
        DownloadInfo info,
        
        IProgress<(DownProgress Title, int AllFiles, int DownedFiles, string DowingFileName)> progress,
        CancellationToken? cancelToken = null
        )
    {
        this._configManager = configManager;
        this.info = info;
        this.progress = progress;
        this.cancelToken = cancelToken ?? CancellationToken.None;
    }

    public async Task MinecraftBasic(
        int maxDownloadThreads = 24,
        int maxSha1Threads = 24,
        bool IsSha1 = true,
        bool useBMLCAPI = false)
    {
        this.maxDownloadThreads = Math.Clamp(maxDownloadThreads,1,256);
        this.maxSha1Threads = Math.Clamp(maxSha1Threads,1,256);

        // 1. 启动后台任务：如果需要，则开始下载Java
        Task javaInstallTask = info.AndJava ? JavaInstallTasker() : Task.CompletedTask;

        // 2. 生成下载计划
        progress?.Report((DownProgress.Meta, 0, 0, "正在生成下载计划..."));
        var plan = await CreateDownloadPlan();

        // 3. 初始化进度报告
        alls = plan.AllFilesGoVerify.Count;
        progress?.Report((DownProgress.Meta, alls, dones, "下载计划生成完毕，开始下载..."));

        // 4. 执行核心下载任务

        await DownloadClientTasker(plan.ClientMainFile, useBMLCAPI);
        // 模组加载器的下载和安装是后台任务
        Task modInstallTasker = 
            plan.ModProviders != null && info.UserInfo.ModLoader != ModEnum.none 
            ? UnityModsInstallTasker(plan.ModLoaderFiles, plan.ModProviders,javaInstallTask)
            : Task.CompletedTask;
        
        await DownloadLibrariesSupportTasker(plan.LibraryFiles, useBMLCAPI);
        await DownloadAssetsSupportTasker(plan.AssetFiles, useBMLCAPI);


        if (plan.LoggingFile.HasValue)
            await LogginInstallTasker(plan.LoggingFile.Value);

        // 5. 等待后台任务完成
        await modInstallTasker;
        await javaInstallTask;

        // 6. (可选)校验所有文件
        if (IsSha1)
        {
            progress?.Report((DownProgress.Verify, alls, alls, "校验中...")); 
            await info.DownloadTool.CheckAllSha1(plan.AllFilesGoVerify, maxSha1Threads, cancelToken);
        }

        // 7. 报告最终完成
        progress?.Report((DownProgress.Done, alls, alls, "下载完毕！"));
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/DownloadMinecraftPlanner.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders;
public partial class DownloadMinecraft
{
    private readonly record struct DownloadPlan(
        List<NdDowItem> AllFilesGoVerify,
        List<NdDowItem> LibraryFiles,
        List<NdDowItem> AssetFiles,
        List<NdDowItem>? ModLoaderFiles,
        NdDowItem ClientMainFile,
        NdDowItem? LoggingFile,
        IModLoaderConcreteProviders[] ModProviders // 如果原版则为null
    );
    private async Task<DownloadPlan> CreateDownloadPlan()
    {
        #region 原版资源
        var mation = info.VersionMojangInfo;
        // 依赖库和资源文件
        var libraryFiles = new List<NdDowItem>(mation.GetLibraries());
        var assetsIndex = mation.GetAssets();
        if (!File.Exists(assetsIndex.path))
            await info.DownloadTool.DownloadFile(assetsIndex.url,assetsIndex.path,cancelToken);
        var assetFiles = VersionAssetIndex.ParseAssetsIndex(
            await File.ReadAllTextAsync(assetsIndex.path, cancelToken),
            info.GameRootPath
        );
        // 一些别的
        var clientFile = mation.GetMainFile();
        var loggingFile = mation.GetLoggingConfig();
        #endregion

        #region 模组加载器

        List<IModLoaderConcreteProviders> providers = new();
        if (info.VersionInstallInfo.modType.IsFabric)
            providers.Add(new FabricProvider(info));
        if (info.VersionInstallInfo.modType.IsNeoForge)
            providers.Add(new NeoforgeProvider(info));
        if (info.VersionInstallInfo.modType.IsForge)
            providers.Add(new ForgeProvider(info));

        List<NdDowItem>? modFiles = new();
        #endregion

        #region 汇总所有文件
        var allFiles = new List<NdDowItem>(libraryFiles.Count+assetFiles.Count+2);
        allFiles.AddRange(assetFiles);
        allFiles.AddRange(libraryFiles);
        allFiles.Add(clientFile);
        if(loggingFile != null)
            allFiles.Add((NdDowItem)loggingFile);
        if (providers.Count != 0)
            foreach (var provider in providers)
            {
                modFiles.AddRange(await provider.GetDependencies());
                allFiles.AddRange(modFiles);
            }
        
        return new DownloadPlan(
            // 自动检查文件存在性
            AllFilesGoVerify:info.DownloadTool.CheckFilesExists(allFiles,cancelToken),
            LibraryFiles: info.DownloadTool.CheckFilesExists(libraryFiles,cancelToken),
            AssetFiles: info.DownloadTool.CheckFilesExists(assetFiles,cancelToken),
            ModLoaderFiles: info.DownloadTool.CheckFilesExists(modFiles,cancelToken),
            ClientMainFile: clientFile,
            LoggingFile:loggingFile,
            ModProviders: providers.ToArray()
            );
        #endregion
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/DownloadMinecraftProvider.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using OneLauncher.Core.Net;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders;
public enum DownProgress
{
    Meta,
    DownMain,
    DownLibs,
    DownAndInstModFiles,
    DownAssets,
    DownLog4j2,
    Verify,
    Done
}
public partial class DownloadMinecraft
{
    private int retryTimes; // 已经重试次数
    private const int MAX_DOWNLOAD_RETRIES = 3; // 每个文件最多重试3次
    private const int DOWNLOAD_TIMEOUT_SECONDS = 10; // 每次尝试的超时时间为10秒
    private async Task DownloadClientTasker(NdDowItem main, bool UseBMLCAPI)
    {
        using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancelToken);

        if (!UseBMLCAPI)
        {
            progress?.Report((DownProgress.DownMain, alls, dones, Path.GetFileName(main.path)));
            await info.DownloadTool.DownloadFile(main.url, main.path, cancelToken);
        }
        else
        {
            await Task.Run(async () =>
            {
                progress?.Report((DownProgress.DownMain, alls, dones, Path.GetFileName(main.path)));
                string mirrorUrl = $"https://bmclapi2.bangbang93.com/version/{info.ID}/client";
                using var raceCts = CancellationTokenSource.CreateLinkedTokenSource(cts.Token);

                try
                {
                    var originalTask = info.DownloadTool.unityClient.GetAsync(main.url, HttpCompletionOption.ResponseHeadersRead, raceCts.Token);
                    var mirrorTask = info.DownloadTool.unityClient.GetAsync(mirrorUrl, HttpCompletionOption.ResponseHeadersRead, raceCts.Token);

                    var winnerTask = await Task.WhenAny(originalTask, mirrorTask);

                    await raceCts.CancelAsync();

                    HttpResponseMessage winnerResponse = await winnerTask;
                    winnerResponse.EnsureSuccessStatusCode();

                    using var contentStream = await winnerResponse.Content.ReadAsStreamAsync();
                    Directory.CreateDirectory(Path.GetDirectoryName(main.path));
                    using (var fileStream = new FileStream(main.path, FileMode.Create, FileAccess.Write, FileShare.None))
                    {
                        await contentStream.CopyToAsync(fileStream, cancelToken);
                    }

                    winnerResponse?.Dispose();
                }
                catch (OperationCanceledException)
                {

                }
                catch (HttpRequestException)
                {
                    // 自动回退
                    await info.DownloadTool.DownloadFile(main.url, main.path, cts.Token);
                }
            }, cts.Token);
        }
    }
    private async Task DownloadAssetsSupportTasker(List<NdDowItem> assets, bool UseBMLCAPI)
    {
        List<NdDowItem> assetsToDownload = assets;
        if (UseBMLCAPI)
        {
            // 替换 URL 使用 BMLCAPI
            assetsToDownload = assets.Select(x =>
                new NdDowItem(
                    x.url.Replace("https://resources.download.minecraft.net/", "https://bmclapi2.bangbang93.com/assets/"),
                    x.path, x.size, x.sha1)).ToList();

            using CancellationTokenSource ctsd = new CancellationTokenSource();
            Task o = info.DownloadTool.unityClient.GetAsync(assets[0].url, HttpCompletionOption.ResponseHeadersRead, ctsd.Token);
            Task b = info.DownloadTool.unityClient.GetAsync(assetsToDownload[0].url, HttpCompletionOption.ResponseHeadersRead, ctsd.Token);

            await Task.WhenAny(o, b);
            if (b.IsCompleted && !b.IsFaulted)
            {
                ctsd.Cancel();
                Debug.WriteLine("使用 BMLC 源");
            }
            else
            {
                ctsd.Cancel();
                Debug.WriteLine("使用官方源");
                assetsToDownload = assets; // 回退到官方源
            }
        }
        else
        {
            Debug.WriteLine("使用官方源");
        }

        // 执行下载
        await               info.DownloadTool.DownloadListAsync(
            new Progress<(int completedFiles, string FilesName)>(p =>
            {
                Interlocked.Increment(ref dones);
                progress?.Report((DownProgress.DownAssets, alls, dones, p.FilesName));
            }),
            assetsToDownload, maxDownloadThreads, cancelToken);
    }
    private async Task DownloadLibrariesSupportTasker(List<NdDowItem> libraries, bool UseBMLCAPI)
    {
        if (UseBMLCAPI)
        {
            await Parallel.ForEachAsync(libraries,
                new ParallelOptions { MaxDegreeOfParallelism = maxDownloadThreads, CancellationToken = cancelToken },
                async (library, cancellationToken) =>
                {
                    string mirrorUrl = library.url.Replace("https://libraries.minecraft.net/", "https://bmclapi2.bangbang93.com/maven/");

                    for (int attempt = 1; attempt <= MAX_DOWNLOAD_RETRIES; attempt++)
                    {
                        using var attemptCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
                        attemptCts.CancelAfter(TimeSpan.FromSeconds(DOWNLOAD_TIMEOUT_SECONDS));

                        try
                        {
                            // --- 3. 竞速：同时启动两个下载任务 ---
                            Task<HttpResponseMessage> originalTask = info.DownloadTool.unityClient.GetAsync(library.url, HttpCompletionOption.ResponseHeadersRead, attemptCts.Token);
                            Task<HttpResponseMessage> mirrorTask = info.DownloadTool.unityClient.GetAsync(mirrorUrl, HttpCompletionOption.ResponseHeadersRead, attemptCts.Token);

                            var completedTask = await Task.WhenAny(originalTask, mirrorTask);

                            HttpResponseMessage successfulResponse = null;

                            // --- 4. 检查胜出者，如果失败则准备回退 ---
                            try
                            {
                                var winnerResponse = await completedTask;
                                if (winnerResponse.IsSuccessStatusCode)
                                {
                                    Debug.WriteLine($"{(completedTask == mirrorTask ? "镜像源" : "官方源")} 胜出并成功: {library.url}");
                                    successfulResponse = winnerResponse;
                                    await attemptCts.CancelAsync(); // 取消另一个请求
                                }
                            }
                            catch (HttpRequestException ex)
                            {
                                Debug.WriteLine($"胜出方任务失败: {ex.Message}");
                                // 忽略异常，继续尝试回退
                            }

                            // --- 5. 回退：如果胜出者失败，则等待另一个源 ---
                            if (successfulResponse == null)
                            {
                                var loserTask = completedTask == originalTask ? mirrorTask : originalTask;
                                try
                                {
                                    Debug.WriteLine($"胜出方失败，回退到另一源... {library.url}");
                                    var loserResponse = await loserTask;
                                    if (loserResponse.IsSuccessStatusCode)
                                    {
                                        Debug.WriteLine($"回退源成功: {library.url}");
                                        successfulResponse = loserResponse;
                                    }
                                }
                                catch (HttpRequestException ex)
                                {
                                    Debug.WriteLine($"回退源也失败: {ex.Message}");
                                }
                            }

                            // --- 6. 处理成功下载 ---
                            if (successfulResponse != null)
                            {
                                using (successfulResponse)
                                using (var contentStream = await successfulResponse.Content.ReadAsStreamAsync())
                                {
                                    Directory.CreateDirectory(Path.GetDirectoryName(library.path));
                                    using (var fileStream = new FileStream(library.path, FileMode.Create, FileAccess.Write, FileShare.None))
                                    {
                                        await contentStream.CopyToAsync(fileStream, cancellationToken);
                                    }
                                }

                                Interlocked.Increment(ref dones);
                                progress?.Report((DownProgress.DownLibs, alls, dones, Path.GetFileName(library.path)));
                                return;
                            }

                            // 如果代码执行到这里，说明两个源都失败了
                            throw new OlanException("下载失败", "经过多次包括更换下载源尝试均以失败告终");
                        }
                        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
                        {
                            // 用户主动取消，终止所有下载
                            Debug.WriteLine("用户取消下载。");
                            throw;
                        }
                        catch (HttpRequestException ex)
                        {
                            // --- 7. 处理尝试失败，准备重试 ---
                            Debug.WriteLine($"文件 {Path.GetFileName(library.path)} 下载第 {attempt} 次尝试失败: {ex.Message}");
                            if (attempt == MAX_DOWNLOAD_RETRIES)
                            {
                                Debug.WriteLine($"文件 {Path.GetFileName(library.path)} 已达最大重试次数，下载失败。");
                                // 注意：这里用 return 来放弃该文件，而用 throw 会使整个 Parallel.ForEachAsync 失败
                                return;
                            }
                            await Task.Delay(1000, cancellationToken); // 等待1秒后重试
                        }
                    }
                });
        }
        else
        {
            // 不使用镜像的原始逻辑
            await info.DownloadTool.DownloadListAsync(
                new Progress<(int a, string b)>(p =>
                {
                    Interlocked.Increment(ref dones);
                    progress?.Report((DownProgress.DownLibs, alls, dones, p.b));
                }), libraries, maxDownloadThreads, cancelToken);
        }

        // 解压原生库文件
        await Task.Run(() =>
        {
            foreach (var i in info.VersionMojangInfo.NativesLibs)
            {
                Download.ExtractFile(Path.Combine(info.GameRootPath, "libraries", i), Path.Combine(info.VersionInstallInfo.VersionPath, "natives"));
            }
        }, cancelToken);
    }
    private async Task UnityModsInstallTasker(List<NdDowItem> modNds, IModLoaderConcreteProviders[] modProviders,Task javaInstallTask)
    {
        // 先把依赖库下载了
        await info.DownloadTool.DownloadListAsync(
                new Progress<(int a, string b)>(p =>
                {
                    Interlocked.Increment(ref dones);
                    progress?.Report((DownProgress.DownAndInstModFiles, alls, dones, p.b));
                }),
                modNds, maxDownloadThreads, cancelToken);
        // 处理器需要Java
        await javaInstallTask;
        // 依次执行每个加载器的处理器
        foreach (var provider in modProviders)
            await provider.RunInstaller(
                new Progress<string>(p =>
                {
                    progress?.Report((DownProgress.DownAndInstModFiles, alls, dones, p));
                }), cancelToken);
        
    }
    private Task LogginInstallTasker(NdDowItem log4j2_xml)
    {
        Interlocked.Increment(ref dones);
        return info.DownloadTool.DownloadFile(log4j2_xml.url, log4j2_xml.path, cancelToken);
    }
    private Task JavaInstallTasker() => Task.Run(async () =>
    {
        if (!_configManager.Data.AvailableJavaList.Contains(info.VersionMojangInfo.GetJavaVersion()))
        {
            await AdoptiumAPI.JavaReleaser(
              info.VersionMojangInfo.GetJavaVersion().ToString(),
              Path.Combine(Path.GetDirectoryName(info.GameRootPath), "runtimes"), Init.SystemType);
            _configManager.Data.AvailableJavaList.Add(info.VersionMojangInfo.GetJavaVersion());
            await _configManager.Save();
        }
    });
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/Sources/FabricProvider.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Mod.ModLoader.fabric;
using OneLauncher.Core.Net.ModService.Modrinth;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;

internal class FabricProvider : IModLoaderConcreteProviders
{
    private readonly DownloadInfo _context;
    public FabricProvider(DownloadInfo context)
    {
        _context = context;
    }
    public async Task<List<NdDowItem>> GetDependencies()
    {
        List<NdDowItem> fabricDependencies;
        string fabricMetaFilePath = Path.Combine(
            _context.VersionInstallInfo.VersionPath,
            "version.fabric.json"
        );
        if(!File.Exists(fabricMetaFilePath))
            await _context.DownloadTool.DownloadFile(
                  $"https://meta.fabricmc.net/v2/versions/loader/{_context.ID}/", fabricMetaFilePath);
        await using var fileStream = new FileStream(fabricMetaFilePath, FileMode.Open, FileAccess.Read);
        // 预留，自定义版本
        var parser = string.IsNullOrEmpty(_context.SpecifiedFabricVersion)
            ? FabricVJParser.ParserAuto(fileStream, _context.GameRootPath)
            : FabricVJParser.ParserUseVersion(fileStream, _context.GameRootPath, _context.SpecifiedFabricVersion);

        fabricDependencies = parser.GetLibraries();

        if (_context.IsDownloadFabricWithAPI)
        {
            var modrinthTask = new GetModrinth(
                "fabric-api", 
                _context.ID,  
                Path.Combine(_context.UserInfo.InstancePath, "mods") 
            );
            await modrinthTask.Init();
            var fabricApiFile = modrinthTask.GetDownloadInfos();
            if (fabricApiFile.HasValue)
            {
                fabricDependencies.Add(fabricApiFile.Value);
            }
        }
        return fabricDependencies;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/Sources/ForgeProvider.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;

internal class ForgeProvider : IModLoaderConcreteProviders
{
    private readonly DownloadInfo _context;
    private readonly ForgeSeriesInstallTasker _installTasker;

    // 用于在 GetDependenciesAsync 和 RunPostInstallTasksAsync 之间传递数据
    private string _clientLzmaTempPath;
    public ForgeProvider(DownloadInfo context)
    {
        _context = context;
        // 提前创建安装任务器实例，供后续两个方法使用
        _installTasker = new ForgeSeriesInstallTasker(
            _context.DownloadTool,
            Path.Combine(_context.GameRootPath, "libraries"),
            _context.GameRootPath
        );
    }
    public async Task<List<NdDowItem>> GetDependencies()
    {
        #region 确定安装器Url
        string installerUrl;
        if (!string.IsNullOrEmpty(_context.SpecifiedForgeVersion))
            installerUrl = $"https://maven.minecraftforge.net/net/minecraftforge/forge/{_context.SpecifiedForgeVersion}/forge-{_context.SpecifiedForgeVersion}-installer.jar";
        else
        {
            // 自动获取最新版本
            installerUrl = await new ForgeVersionListGetter(_context.DownloadTool.unityClient)
                .GetInstallerUrlAsync(
                    true,
                    _context.ID,
                    _context.IsAllowToUseBetaNeoforge,
                    _context.IsUseRecommendedToInstallForge
                );
        }
        #endregion

        // 调用准备方法
        (List<NdDowItem> versionLibs, List<NdDowItem> installerLibs,string lzmaPath) = await _installTasker.StartReadyAsync(
            installerUrl,
            "Forge",
            _context.ID
        );
        _clientLzmaTempPath = lzmaPath;
        // 合并下载信息
        return versionLibs.Concat(installerLibs).ToList();
    }

    public async Task RunInstaller(IProgress<string> Put,CancellationToken token)
    {
        if (_clientLzmaTempPath == null)
            throw new OlanException("内部错误","无法执行安装器，无法得到补丁文件");
        _installTasker.ProcessorsOutEvent += (all, done, message) =>
        {
            if (all == -1 && done == -1)
                throw new OlanException("执行Forge安装器时出错",$"当安装器[{done}/{all}]被执行时抛出了错误或异常退出{Environment.NewLine}错误信息：{message}");
            Put?.Report($"[执行处理器({done}/{all})]{Environment.NewLine}{message}");
        };

        await _installTasker.RunProcessorsAsync(
            _context.VersionMojangInfo.GetMainFile().path,
            Tools.IsUseOlansJreOrOssJdk(_context.VersionMojangInfo.GetJavaVersion()),
            _clientLzmaTempPath,
            token,
            isForge: _context.UserInfo.ModLoader == ModEnum.forge
        );

        // 清理临时文件
        if (File.Exists(_clientLzmaTempPath))
            File.Delete(_clientLzmaTempPath);
        
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/Sources/IModLoaderConcreteProviders.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;

internal interface IModLoaderConcreteProviders
{
    Task<List<NdDowItem>> GetDependencies();
    Task RunInstaller(IProgress<string> Put,CancellationToken token)
    {
        /* 某些资源可能没有，提供一个默认啥都不干的实现 */
        return Task.CompletedTask;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Downloader/DownloadMinecraftProviders/Sources/NeoforgeProvider.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Downloader.DownloadMinecraftProviders.Sources;

internal class NeoforgeProvider : IModLoaderConcreteProviders
{
    private readonly DownloadInfo _context;
    private readonly ForgeSeriesInstallTasker _installTasker;

    // 用于在 GetDependenciesAsync 和 RunPostInstallTasksAsync 之间传递数据
    private string _clientLzmaTempPath;
    public NeoforgeProvider(DownloadInfo context)
    {
        _context = context;
        // 提前创建安装任务器实例，供后续两个方法使用
        _installTasker = new ForgeSeriesInstallTasker(
            _context.DownloadTool,
            Path.Combine(_context.GameRootPath, "libraries"),
            _context.GameRootPath
        );
    }
    public async Task<List<NdDowItem>> GetDependencies()
    {
        #region 确定安装器Url
        string installerUrl;
        if (!string.IsNullOrEmpty(_context.SpecifiedNeoForgeVersion))
            installerUrl = $"https://maven.neoforged.net/releases/net/neoforged/neoforge/{_context.SpecifiedNeoForgeVersion}/neoforge-{_context.SpecifiedNeoForgeVersion}-installer.jar";
        else
        {
            // 自动获取最新版本
            installerUrl = await new ForgeVersionListGetter(_context.DownloadTool.unityClient)
                .GetInstallerUrlAsync(
                    false,
                    _context.ID,
                    _context.IsAllowToUseBetaNeoforge,
                    _context.IsUseRecommendedToInstallForge
                );
        }
        #endregion

        // 调用准备方法
        (List<NdDowItem> versionLibs, List<NdDowItem> installerLibs, string lzmaPath) = await _installTasker.StartReadyAsync(
            installerUrl,
            "NeoForge",
            _context.ID
        );
        _clientLzmaTempPath = lzmaPath;
        // 合并下载信息
        return versionLibs.Concat(installerLibs).ToList();
    }

    public async Task RunInstaller(IProgress<string> Put, CancellationToken token)
    {
        if (_clientLzmaTempPath == null)
            throw new OlanException("内部错误", "无法执行安装器，无法得到补丁文件");
        _installTasker.ProcessorsOutEvent += (all, done, message) =>
        {
            if (all == -1 && done == -1)
                throw new OlanException("执行Neoforge安装器时出错", $"当安装器[{done}/{all}]被执行时抛出了错误或异常退出{Environment.NewLine}错误信息：{message}");
            Put?.Report($"[执行处理器({done}/{all})]{Environment.NewLine}{message}");
        };

        await _installTasker.RunProcessorsAsync(
            _context.VersionMojangInfo.GetMainFile().path,
            Tools.IsUseOlansJreOrOssJdk(_context.VersionMojangInfo.GetJavaVersion()),
            _clientLzmaTempPath,
            token,
            isForge: _context.UserInfo.ModLoader == ModEnum.forge
        );

        // 清理临时文件
        if (File.Exists(_clientLzmaTempPath))
            File.Delete(_clientLzmaTempPath);

    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Global/Init.cs
【代码拼接器】文件内容开始
using Microsoft.Extensions.DependencyInjection;
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.ConnectToolPower;
using OneLauncher.Core.Net.msa;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace OneLauncher.Core.Global;
public static class Init
{
    public const string OneLauncherVersoin = "1.2.0.0";
    public const string ApplicationUUID = "com.onelauncher.lnetface";
    public const string AzureApplicationID = "53740b20-7f24-46a3-82cc-ea0376b9f5b5";
    public static Task<IServiceCollection> InitTask;
    //public static IServiceCollection Service { get; private set; }
    public static string BasePath { get; } = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "OneLauncher");
    public static string GameRootPath
#if DEBUG
    { get; set; }
#else
    { get; private set; }
#endif
    public static string InstalledPath { get; private set; }
    public static SystemType SystemType { get; private set; }
    public static List<VersionBasicInfo> MojangVersionList = null;
    public static List<IDisposable> OnApplicationClosingReleaseSourcesList = new();
    // 必要的时候还是得耦合一下的，啥都得传递那他妈的写起来太难受了
    public static DBManager ConfigManger => ConfigManager;
    public static MsalAuthenticator MMA => MsalAuthenticator;
    //public static Ac
    internal static DBManager ConfigManager { get; private set; }
    public static AccountManager AccountManager { get; private set; }
    public static GameDataManager GameDataManager { get; private set; }
    internal static MsalAuthenticator MsalAuthenticator { get; private set; }
    public static Download Download { get; private set; }
    public static async Task<IServiceCollection> Initialize(bool isCommandMode = false)
    {
        try
        {
            Directory.CreateDirectory(BasePath);

            var services = new ServiceCollection();
            
            // 先把最重要的基本配置信息初始化了，然后初始化别的
            var configManger = new DBManager(Path.Combine(BasePath,"config.json"));
            await configManger.InitializeAsync();
            services.AddSingleton<DBManager>(configManger);
            ConfigManager = configManger;

            InstalledPath = configManger.Data.OlanSettings.InstallPath ?? Path.Combine(BasePath,"installed");
            GameRootPath = InstalledPath == null ? Path.Combine(BasePath, "installed", ".minecraft") : Path.Combine(InstalledPath, ".minecraft");
            // 初始化系统信息
            SystemType = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? SystemType.windows :
                         RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? SystemType.linux :
                         RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? SystemType.osx : SystemType.linux;

            var accountManger = new AccountManager(Path.Combine(BasePath,"playerdata","account.json"));
            await accountManger.InitializeAsync();
            services.AddSingleton<AccountManager>(accountManger);
            AccountManager = accountManger; 

            var gameDataManger = new GameDataManager(Path.Combine(GameRootPath, "instance", "instance.json"));
            await gameDataManger.InitializeAsync();
            services.AddSingleton<GameDataManager>(gameDataManger);
            GameDataManager = gameDataManger;

            var downloadTool = new Download();
            services.AddSingleton<Download>(downloadTool);
            OnApplicationClosingReleaseSourcesList.Add(downloadTool);
            Download = downloadTool;

            var msrl = await MsalAuthenticator.CreateAsync(AzureApplicationID);
            services.AddSingleton<MsalAuthenticator>(msrl);
            OnApplicationClosingReleaseSourcesList.Add(msrl);
            MsalAuthenticator = msrl;

            return services; 
        }
        #region
        catch (ArgumentException ex)
        {
            throw new OlanException("参数错误", $"参数未被正常传递：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (PathTooLongException ex)
        {
            throw new OlanException("路径过长", $"路径过长：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (NotSupportedException ex)
        {
            throw new OlanException("不支持的操作", $"当前操作不被支持：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (UnauthorizedAccessException ex)
        {
            throw new OlanException("权限不足", $"当前用户没有足够的权限：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (FileNotFoundException ex)
        {
            throw new OlanException("文件未找到", $"所需文件不存在：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (DirectoryNotFoundException ex)
        {
            throw new OlanException("目录未找到", $"所需目录不存在：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (InvalidOperationException ex)
        {
            throw new OlanException("操作无效", $"当前操作无效：{ex.Message}", OlanExceptionAction.FatalError);
        }
        catch (Exception ex)
        {
            throw new OlanException("未知错误", $"发生未知错误：{ex.Message}", OlanExceptionAction.FatalError);
        }
        #endregion
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Global/OlanException.cs
【代码拼接器】文件内容开始
namespace OneLauncher.Core.Global;
/// <summary>
/// 出现已知错误时应该做什么？
/// Warning : 仅在右下角显示警告
/// Error : 显示对话框要求用户处理
/// FatalErroe : 致命性错误，显示对话框并提示关闭 OneLauncher
/// </summary>
public enum OlanExceptionAction
{
    Warning,
    Error,
    FatalError
}
public class OlanException : Exception
{
    public OlanExceptionAction Action { get; set; }
    public string Title { get; set; }
    public string Message { get; set; }
    public Exception? OriginalException { get; set; }
    // 重试方法，会在窗口显示，并由用户决定是否调用
    public Action? TryAgainFunction { get; set; } = null;
    public OlanException(string Title, string Message, OlanExceptionAction action = OlanExceptionAction.Error)
    {
        this.Title = Title;
        this.Message = Message;
        Action = action;
    }
    public OlanException(string Title, string Message, OlanExceptionAction action, Exception originalException)
    {
        this.Title = Title;
        this.Message = Message;
        Action = action;
        OriginalException = originalException;
    }
    public OlanException(string Title, string Message, OlanExceptionAction action, Exception originalException, Action taf)
    {
        this.Title = Title;
        this.Message = Message;
        Action = action;
        OriginalException = originalException;
        TryAgainFunction = taf;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Global/ModelDataMangers/AccountManger.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global.ModelDataMangers;
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Threading.Tasks;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace OneLauncher.Core.Global.ModelDataMangers;
[JsonSerializable(typeof(AccountData))]
[JsonSerializable(typeof(Dictionary<Guid,UserModel>))]
public partial class AccountDataJsonContext : JsonSerializerContext { }
public class AccountData
{
    public AccountData() {
        UserDictionary = new Dictionary<Guid, UserModel>();
    }
    public Dictionary<Guid, UserModel> UserDictionary { get; set; }
    public Guid? DefaultUserID { get; set; }
}
public class AccountManager : BasicDataManager<AccountData>
{
    public AccountManager(string basePath)
        : base(basePath)
    {
    }

    protected override JsonSerializerContext GetJsonContext() => AccountDataJsonContext.Default;
    protected override Task PostInitialize()
    {
        // 如果没有用户模型，则创建默认
        if (Data.UserDictionary.Count == 0)
        {
            var tmp = Guid.NewGuid();
            Data.UserDictionary[tmp] = new UserModel(tmp, "default", new Guid(UserModel.nullToken));
            Data.DefaultUserID = tmp;
            return Save();
        }
        return Task.CompletedTask;
    }

    public UserModel? GetUser(Guid id) => Data.UserDictionary.GetValueOrDefault(id);

    public IEnumerable<UserModel> GetAllUsers() => Data.UserDictionary.Values;

    public UserModel? GetDefaultUser()
    {
        // 从 this.Data 中获取默认用户ID
        if (Data.DefaultUserID.HasValue)
            return Data.UserDictionary.GetValueOrDefault(Data.DefaultUserID.Value);

        // 如果没有默认用户，可以返回null或者第一个用户作为备选
        return Data.UserDictionary.Values.FirstOrDefault();
    }

    public Task AddUser(UserModel user)
    {
        Data.UserDictionary[user.UserID] = user;
        return Save();
    }

    public Task RemoveUser(Guid userId)
    {
        if (Data.UserDictionary.Count <= 1)
            throw new OlanException("拒绝访问", "你至少要有一个有效的用户模型");

        if (Data.UserDictionary.Remove(userId))
        {
            if (Data.DefaultUserID == userId)
            {
                Data.DefaultUserID = Data.UserDictionary.Keys.FirstOrDefault();
            }
            return Save();
        }
        return Task.CompletedTask;
    }

    public Task SetDefault(Guid userId)
    {
        if (Data.UserDictionary.ContainsKey(userId))
        {
            Data.DefaultUserID = userId;
            return Save();
        }
        return Task.CompletedTask;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Global/ModelDataMangers/BasicDataManger.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace OneLauncher.Core.Global.ModelDataMangers;

public abstract class BasicDataManager<T> where T : class, new()
{
    public T Data { get; protected set; }

    private readonly string _configPath;
    private readonly JsonSerializerOptions _serializerOptions; // AOT 用得到
    private readonly SemaphoreSlim _saveLock = new(1, 1); // 防止竞态

    protected BasicDataManager(string configPath)
    {
        _configPath = configPath;
        _serializerOptions = new JsonSerializerOptions
        {
            WriteIndented = false, // 是否格式化 
            TypeInfoResolver = GetJsonContext()
        };
    }

    public async Task InitializeAsync()
    {
        Directory.CreateDirectory(Path.GetDirectoryName(_configPath));

        if (!File.Exists(_configPath))
        {
            Data = new T(); 
            await Save(); 
        }
        else
        {
            try
            {
                // 文件存在，尝试读取和解析。
                using var stream = File.OpenRead(_configPath);
                // 防止空文件导致反序列化失败
                if (stream.Length == 0)
                {
                    Data = new T();
                }
                else
                {
                    Data = await JsonSerializer.DeserializeAsync<T>(stream, _serializerOptions) as T ?? new T();
                }
            }
            catch (Exception ex)
            {
                throw new OlanException($"加载配置文件 {_configPath} 失败", "文件可能已损坏。", OlanExceptionAction.FatalError, ex);
            }
        }

        // 调用各个子类的特殊初始化方法
        await PostInitialize();
    }

    protected virtual Task PostInitialize()
        => Task.CompletedTask; // 部分子类无特别操作
    
    public async Task Save()
    {
        await _saveLock.WaitAsync();
        try
        {
            // 覆盖原始文件
            using var fs = new FileStream(_configPath,FileMode.Create,FileAccess.Write,FileShare.None,0,true);
            await JsonSerializer.SerializeAsync<T>(fs,Data, _serializerOptions);
        }
        finally
        {
            _saveLock.Release();
        }
    }
    protected abstract JsonSerializerContext GetJsonContext();
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Global/ModelDataMangers/DBManager.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Global.ModelDataMangers;
[JsonSerializable(typeof(JvmArguments))]
[JsonSerializable(typeof(AppSettings))]
[JsonSerializable(typeof(AppConfig))]
[JsonSerializable(typeof(UserModel))]
[JsonSerializable(typeof(UserVersion))]
[JsonSerializable(typeof(ModType))]
[JsonSerializable(typeof(ModEnum))]
public partial class OneLauncherAppConfigsJsonContext : JsonSerializerContext { }
public class AppSettings
{
    public JvmArguments MinecraftJvmArguments { get; set; } = JvmArguments.CreateFromMode();
    // 下载
    public int MaximumDownloadThreads { get; set; } = 24;
    public int MaximumSha1Threads { get; set; } = 24;
    public bool IsSha1Enabled { get; set; } = true;
    public bool IsAllowToDownloadUseBMLCAPI { get; set; } = false;
    public string? InstallPath { get; set; } 
}
public class AppConfig
{
    // 当前启动器已安装的所有版本列表，默认初始化为空列表
    public List<UserVersion> VersionList { get; set; } = new ();
    public string DefaultInstanceID { get; set; }
    // 除了系统自带的Java以外启动器安装的所有Java版本列表
    public List<int> AvailableJavaList { get; set; } = new ();
    public AppSettings OlanSettings { get; set; } = new AppSettings();
}
public class DBManager : BasicDataManager<AppConfig>
{
    public DBManager(string configPath)
        :base(configPath)
    {
    }

    protected override JsonSerializerContext GetJsonContext()
        => OneLauncherAppConfigsJsonContext.Default;
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Global/ModelDataMangers/GameDataManger.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using System.Data;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Global.ModelDataMangers;

public class GameDataRoot
{
    // 存储所有游戏数据实例的字典
    [JsonPropertyName("instances")]
    public Dictionary<string,GameData> Instances { get; set; } = new();

    // 存储默认实例的映射
    // Key: VersionId (如 "1.20.1")
    // Value: InstanceId (如 "fd92ded1")
    [JsonPropertyName("defaults")]
    public Dictionary<string, string> DefaultInstanceMap { get; set; } = new();
}

// 以便AOT编译
[JsonSerializable(typeof(List<GameData>))]
[JsonSerializable(typeof(GameDataRoot))] 
public partial class GameDataJsonContext : JsonSerializerContext { }

public class GameDataManager : BasicDataManager<GameDataRoot>
{
    //public List<GameData> AllGameData => Data.Instances.Select(x => x.Value).ToList();
    //public GameDataRoot Data => base.Data;
    public List<GameData> AllGameData => Data.Instances.Values.ToList();
    /// <summary>
    /// 获取或创建一个指定版本的游戏数据实例。
    /// 查找逻辑：1. 默认实例 -> 2. 第一个可用实例 -> 3. 创建新实例。
    /// </summary>
    public async Task<GameData> GetOrCreateInstanceAsync(UserVersion userVersion)
    {
        // 尝试获取该版本的默认实例
        var gameData = GetDefaultInstance(userVersion.VersionID);
        if (gameData != null)
            return gameData;
        

        // 2. 如果没有默认实例，则查找该版本的第一个可用实例
        gameData = Data.Instances.FirstOrDefault(x => x.Value.VersionId == userVersion.VersionID).Value;
        if (gameData != null)
        {
            await SetDefaultInstanceAsync(gameData);
            return gameData;
        }

        // 如果完全没有任何实例，则创建一个新的
        // 确定默认游戏数据名称
        string modLoaderName = userVersion.modType.ToModEnum() switch
        {
            ModEnum.fabric => "Fabric",
            ModEnum.neoforge => "NeoForge",
            ModEnum.forge => "Forge",
            _ => "原版"
        };
        string gameDataName = $"{userVersion.VersionID} - {modLoaderName}";
        var newGameData = new GameData(
            name: gameDataName,
            versionId: userVersion.VersionID,
            loader: userVersion.modType.ToModEnum(),
            userModel: Init.AccountManager.GetDefaultUser().UserID
        );

        // 添加并设为默认
        await AddGameDataAsync(newGameData);
        await SetDefaultInstanceAsync(newGameData);

        return newGameData;
    }
    public GameDataManager(string configPath)
        :base(configPath)
    {
    }
    public Task SetDefaultInstanceAsync(GameData targetData)
    {
        Data.DefaultInstanceMap[targetData.VersionId] = targetData.InstanceId;
        return Save();
    }

    public GameData? GetDefaultInstance(string versionId)
    {
        return Data.Instances.FirstOrDefault(x => x.Value.VersionId == versionId).Value;
    }

    public Task AddGameDataAsync(GameData newData)
    {
        Data.Instances.Add(newData.InstanceId,newData);
        // 确保物理文件夹被创建
        Directory.CreateDirectory(newData.InstancePath);
        return Save();
    }

    public Task RemoveGameDataAsync(GameData dataToRemove)
    {
        // 在删除实例前检查并清理它在 defaults 映射中的记录
        if (Data.DefaultInstanceMap.ContainsValue(dataToRemove.InstanceId))
        {
            var entry = Data.DefaultInstanceMap.FirstOrDefault(kvp => kvp.Value == dataToRemove.InstanceId);
            if (!string.IsNullOrEmpty(entry.Key))
                Data.DefaultInstanceMap.Remove(entry.Key);
            
        }

        Data.Instances.Remove(dataToRemove.InstanceId);
        return Save();
    }

    protected override JsonSerializerContext GetJsonContext()
        => GameDataJsonContext.Default;
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/ReleaseMemory.cs
【代码拼接器】文件内容开始
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper;

public static class ReleaseMemory
{
    /// <summary>
    /// 当优化操作失败时抛出的特定异常。
    /// </summary>
    public class OptimizationFailedException : Exception
    {
        public OptimizationFailedException(string message) : base(message) { }
        public OptimizationFailedException(string message, Exception innerException) : base(message, innerException) { }
    }

#if WINDOWS
    #region Windows P/Invoke Definitions (Privilege Management)

    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool LookupPrivilegeValue(string lpSystemName, string lpName, out LUID lpLuid);

    [DllImport("advapi32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool AdjustTokenPrivileges(IntPtr TokenHandle, [MarshalAs(UnmanagedType.Bool)] bool DisableAllPrivileges, ref TOKEN_PRIVILEGES NewState, uint BufferLength, IntPtr PreviousState, IntPtr ReturnLength);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr GetCurrentProcess();

    [DllImport("advapi32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);

    [StructLayout(LayoutKind.Sequential)]
    private struct LUID
    {
        public uint LowPart;
        public int HighPart;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct TOKEN_PRIVILEGES
    {
        public uint PrivilegeCount;
        public LUID_AND_ATTRIBUTES Privileges;
    }

    [StructLayout(LayoutKind.Sequential)]
    private struct LUID_AND_ATTRIBUTES
    {
        public LUID Luid;
        public uint Attributes;
    }

    private const uint TOKEN_ADJUST_PRIVILEGES = 0x0020;
    private const uint TOKEN_QUERY = 0x0008;
    private const uint SE_PRIVILEGE_ENABLED = 0x00000002;
    private const string SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege";

    #endregion

    #region Windows P/Invoke Definitions (Memory Management)
    [DllImport("psapi.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool EmptyWorkingSet(IntPtr hProcess);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool SetSystemFileCacheSize(UIntPtr minimumFileCacheSize, UIntPtr maximumFileCacheSize, uint flags);

    #endregion

    /// <summary>
    /// 为当前进程设置指定的系统特权。
    /// </summary>
    /// <param name="privilegeName">要设置的特权名称。</param>
    /// <param name="enable">True以启用，False以禁用。</param>
    private static void SetPrivilege(string privilegeName, bool enable)
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, out IntPtr tokenHandle))
        {
            throw new OptimizationFailedException($"无法打开进程令牌。Win32 错误码: {Marshal.GetLastWin32Error()}");
        }

        if (!LookupPrivilegeValue(null, privilegeName, out LUID luid))
        {
            throw new OptimizationFailedException($"无法查找特权 '{privilegeName}'。Win32 错误码: {Marshal.GetLastWin32Error()}");
        }

        TOKEN_PRIVILEGES newState = new TOKEN_PRIVILEGES
        {
            PrivilegeCount = 1,
            Privileges = new LUID_AND_ATTRIBUTES
            {
                Luid = luid,
                Attributes = enable ? SE_PRIVILEGE_ENABLED : 0
            }
        };

        if (!AdjustTokenPrivileges(tokenHandle, false, ref newState, 0, IntPtr.Zero, IntPtr.Zero))
        {
            throw new OptimizationFailedException($"无法调整令牌特权。Win32 错误码: {Marshal.GetLastWin32Error()}");
        }
    }

    private static Task OptimizeForWindowsAsync()
    {
        return Task.Run(() =>
        {
            // 1. 清理系统文件缓存
            try
            {
                // 在调用API前后，启用和禁用必需的特权
                SetPrivilege(SE_INCREASE_QUOTA_NAME, true);
                if (!SetSystemFileCacheSize(new UIntPtr(0xFFFFFFFF), new UIntPtr(0xFFFFFFFF), 0))
                {
                    int errorCode = Marshal.GetLastWin32Error();
                    throw new OptimizationFailedException($"清理系统文件缓存失败。Win32 错误码: {errorCode}");
                }
            }
            finally
            {
                // 确保无论成功与否，都尝试禁用特权
                SetPrivilege(SE_INCREASE_QUOTA_NAME, false);
            }

            // 2. 削减其他进程的工作集 (此部分逻辑不变)
            var currentProcess = Process.GetCurrentProcess();
            foreach (var process in Process.GetProcesses())
            {
                if (process.Id == currentProcess.Id) continue;
                try
                {
                    EmptyWorkingSet(process.Handle);
                }
                catch { /* 静默忽略单个进程的失败 */ }
                finally
                {
                    process.Dispose();
                }
            }
        });
    }

#endif

#if MACOS
    private static Task OptimizeForMacOsAsync()
    {
        // macOS implementation remains the same
        return Task.Run(() =>
        {
            try
            {
                var processStartInfo = new ProcessStartInfo
                {
                    FileName = "/usr/sbin/purge",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardError = true
                };

                using (var process = Process.Start(processStartInfo))
                {
                    if (process == null)
                    {
                        throw new OptimizationFailedException("无法启动 'purge' 进程。");
                    }
                    
                    process.WaitForExit();

                    if (process.ExitCode != 0)
                    {
                        string error = process.StandardError.ReadToEnd();
                        throw new OptimizationFailedException($"执行 'purge' 命令失败。错误信息: {error}");
                    }
                }
            }
            catch (Exception ex) when (ex is not OptimizationFailedException)
            {
                throw new OptimizationFailedException("执行 'purge' 命令时发生意外错误。", ex);
            }
        });
    }
#endif

    public static Task OptimizeAsync()
    {
#if WINDOWS
        return OptimizeForWindowsAsync();
#elif MACOS
        return OptimizeForMacOsAsync();
#else
        return Task.CompletedTask;
#endif
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/SystemMemoryHelper.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper;
public static class SystemMemoryHelper
{
    public struct MemoryMetrics
    {
        public double TotalMB { get; set; }
        public double UsedMB { get; set; }
        public double FreeMB { get; set; }
    }

    public static MemoryMetrics GetMemoryMetrics()
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            return GetWindowsMemoryMetrics();
        }
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
        {
            return GetLinuxMemoryMetrics();
        }
        if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
        {
            // 在macOS上，命令行工具仍然是最佳选择
            return GetOsxMemoryMetrics();
        }

        // 未知系统的安全默认值
        return new MemoryMetrics { TotalMB = 4096, FreeMB = 1024, UsedMB = 3072 };
    }

    private static MemoryMetrics GetWindowsMemoryMetrics()
    {
        try
        {
            var memStatus = new MEMORYSTATUSEX();
            if (GlobalMemoryStatusEx(memStatus))
            {
                double totalMB = memStatus.ullTotalPhys / 1024.0 / 1024.0;
                double freeMB = memStatus.ullAvailPhys / 1024.0 / 1024.0;
                double usedMB = totalMB - freeMB;

                return new MemoryMetrics
                {
                    TotalMB = Math.Round(totalMB),
                    FreeMB = Math.Round(freeMB),
                    UsedMB = Math.Round(usedMB)
                };
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to get Windows memory metrics via P/Invoke: {ex.Message}");
        }

        // 如果API调用失败，返回安全默认值
        return new MemoryMetrics { TotalMB = 4096, FreeMB = 1024, UsedMB = 3072 };
    }

    private static MemoryMetrics GetLinuxMemoryMetrics()
    {
        try
        {
            var output = "";
            var info = new ProcessStartInfo("/bin/bash", "-c \"free -m\"")
            {
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true,
            };

            using (var process = Process.Start(info)) { output = process.StandardOutput.ReadToEnd(); }

            var lines = output.Split('\n');
            var memory = lines[1].Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);

            var metrics = new MemoryMetrics();
            metrics.TotalMB = double.Parse(memory[1], CultureInfo.InvariantCulture);

            if (memory.Length > 6)
                metrics.FreeMB = double.Parse(memory[6], CultureInfo.InvariantCulture);
            else
            {
                double free = double.Parse(memory[3], CultureInfo.InvariantCulture);
                double bufferCache = double.Parse(memory[5], CultureInfo.InvariantCulture);
                metrics.FreeMB = free + bufferCache;
            }

            metrics.UsedMB = metrics.TotalMB - metrics.FreeMB;
            return metrics;
        }
        catch (Exception ex) { return new MemoryMetrics { TotalMB = 4096, FreeMB = 1024, UsedMB = 3072 }; }
    }

    private static MemoryMetrics GetOsxMemoryMetrics()
    {
        try
        {
            double totalMB = GetOsxTotalMemory() / 1024.0 / 1024.0;

            // 获取页面信息来计算已用内存
            var output = "";
            var info = new ProcessStartInfo("/bin/bash", "-c \"vm_stat\"")
            {
                RedirectStandardOutput = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };
            using (var process = Process.Start(info)) { output = process.StandardOutput.ReadToEnd(); }

            var lines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            var infoDic = lines
                .Skip(1)
                .Select(line => line.Split(new[] { ':' }, 2))
                .ToDictionary(parts => parts[0].Trim(), parts => long.Parse(Regex.Match(parts[1], @"\d+").Value));

            long pageSize = (long)GetOsxPageSize();
            long pagesActive = infoDic.GetValueOrDefault("Pages active");
            long pagesInactive = infoDic.GetValueOrDefault("Pages inactive");
            long pagesSpeculative = infoDic.GetValueOrDefault("Pages speculative");
            long pagesWiredDown = infoDic.GetValueOrDefault("Pages wired down");
            long pagesPurgeable = infoDic.GetValueOrDefault("Pages purgeable");

            // ProjBobcat的算法比较复杂，一个简化的、被广泛接受的“可用内存”估算
            // 是 (inactive + free + speculative) * pageSize。我们这里用更简单的总-已用
            double usedMB = (pagesActive + pagesWiredDown) * pageSize / 1024.0 / 1024.0;
            double freeMB = totalMB - usedMB;

            return new MemoryMetrics
            {
                TotalMB = Math.Round(totalMB),
                FreeMB = Math.Round(freeMB),
                UsedMB = Math.Round(usedMB)
            };
        }
        catch (Exception ex) { /* ... */ return new MemoryMetrics { TotalMB = 4096, FreeMB = 1024, UsedMB = 3072 }; }
    }

    // macOS 辅助方法
    private static ulong GetOsxTotalMemory()
    {
        var info = new ProcessStartInfo("/usr/sbin/sysctl", "hw.memsize") { RedirectStandardOutput = true };
        using var process = Process.Start(info);
        var output = process.StandardOutput.ReadToEnd();
        var value = output.Split(' ', StringSplitOptions.RemoveEmptyEntries).Last();
        return ulong.TryParse(value, out var outVal) ? outVal : 0;
    }
    private static uint GetOsxPageSize()
    {
        var info = new ProcessStartInfo("/bin/bash", "-c \"vm_stat\"") { RedirectStandardOutput = true };
        using var process = Process.Start(info);
        var output = process.StandardOutput.ReadLine(); // 只读第一行
        return uint.TryParse(Regex.Match(output, @"\d+").Value, out var pageSizeOut) ? pageSizeOut : 4096;
    }

    #region Windows P/Invoke Definitions (现在是唯一需要的Windows部分)

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
    private class MEMORYSTATUSEX
    {
        public uint dwLength;
        public uint dwMemoryLoad;
        public ulong ullTotalPhys;
        public ulong ullAvailPhys;
        public ulong ullTotalPageFile;
        public ulong ullAvailPageFile;
        public ulong ullTotalVirtual;
        public ulong ullAvailVirtual;
        public ulong ullAvailExtendedVirtual;

        public MEMORYSTATUSEX()
        {
            this.dwLength = (uint)Marshal.SizeOf(typeof(MEMORYSTATUSEX));
        }
    }

    [return: MarshalAs(UnmanagedType.Bool)]
    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern bool GlobalMemoryStatusEx([In, Out] MEMORYSTATUSEX lpBuffer);

    #endregion
}


【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/TextHelper.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper;

public static class TextHelper
{
    // 编码
    public static string Base64Encode(string plainText)
    {
        var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
        return Convert.ToBase64String(plainTextBytes);
    }
    // 解码
    public static string Base64Decode(string base64EncodedData)
    {
        var base64EncodedBytes = Convert.FromBase64String(base64EncodedData);
        return Encoding.UTF8.GetString(base64EncodedBytes);
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/Tools.cs
【代码拼接器】文件内容开始
using Microsoft.Identity.Client;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.msa;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper;
public static class Tools
{
    /// <summary>
    /// 基于主类名的模组加载器判断机制
    /// </summary>
    public static ModEnum MainClassToModEnum(string mainClass)
    {
        return mainClass switch
        {
            "cpw.mods.bootstraplauncher.BootstrapLauncher" => ModEnum.neoforge,
            "net.fabricmc.loader.impl.launch.knot.KnotClient" => ModEnum.fabric,
            "net.minecraft.client.main.Main" => ModEnum.none,
            _ => ModEnum.none
        };
    }
    public static async Task CopyDirectoryAsync(string sourceDir, string destDir, CancellationToken token)
    {
        Directory.CreateDirectory(destDir);
        foreach (var file in Directory.GetFiles(sourceDir))
        {
            token.ThrowIfCancellationRequested();
            string destFile = Path.Combine(destDir, Path.GetFileName(file));
            await using var sourceStream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite, 4096, true);
            await using var destStream = new FileStream(destFile, FileMode.Create, FileAccess.Write, FileShare.ReadWrite, 4096, true);
            await sourceStream.CopyToAsync(destStream, token);
        }
        foreach (var dir in Directory.GetDirectories(sourceDir))
        {
            token.ThrowIfCancellationRequested();
            await CopyDirectoryAsync(dir, Path.Combine(destDir, Path.GetFileName(dir)), token);
        }
    }
    /// <summary>
    /// 获取一个当前可用的TCP端口号。
    /// </summary>
    public static int GetFreeTcpPort()
    {
        // 1. 创建一个TCP监听器，并监听0号端口，系统会自动分配一个空闲端口。
        var listener = new TcpListener(IPAddress.Loopback, 0);
        listener.Start();

        // 2. 获取分配到的端口号。
        int port = ((IPEndPoint)listener.LocalEndpoint).Port;

        // 3. 立即停止监听，释放该端口，以便我们的核心程序可以使用。
        listener.Stop();

        return port;
    }
    public static async Task<string?> GetFileMD5Async(string filePath)
    {
        try
        {
            if (!File.Exists(filePath))
            {
                return null;
            }

            using (var md5 = MD5.Create())
            {
                using (var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, true))
                {
                    byte[] hash = await md5.ComputeHashAsync(stream);
                    return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
                }
            }
        }
        catch
        {
            return null;
        }
    }
    public static async Task<IAccount?> UseAccountIDToFind(string accountID)
    {
        return (await Init.MsalAuthenticator.GetCachedAccounts())
            .FirstOrDefault(a => a.HomeAccountId.Identifier == accountID);
    }
    public static void OpenFolder(string folderPath)
    {
        var processOpenInfo = new ProcessStartInfo()
        {
            Arguments = $"\"{folderPath}\"",
            UseShellExecute = true
        };
        Directory.CreateDirectory(folderPath);
        try
        {
            switch (Init.SystemType)
            {
                case SystemType.windows:
                    processOpenInfo.FileName = "explorer.exe";
                    break;
                case SystemType.osx:
                    processOpenInfo.FileName = "open";
                    break;
                case SystemType.linux:
                    processOpenInfo.FileName = "xdg-open";
                    break;
            }
            Process.Start(processOpenInfo);
        }
        catch (Exception ex)
        {
            throw new OlanException(
                "无法打开文件夹",
                "无法执行启动操作",
                OlanExceptionAction.Error);
        }
    }
    public static string IsUseOlansJreOrOssJdk(int javaVersion)
    {
        var t = Path.Combine(Init.BasePath,"installed","runtimes", javaVersion.ToString());
        if (Init.ConfigManager.Data.AvailableJavaList.Contains(javaVersion))
            return Init.SystemType == SystemType.osx
                ? Path.Combine(t, Directory.GetDirectories(t)[0], "Contents", "Home", "bin", "java")
                : Path.Combine(t, Directory.GetDirectories(t)[0], "bin", "java");
        return "java"; // 否则默认使用系统Java 
    }
    public static int ForNullJavaVersion(string version)
    {
        return // 1.16.5及以下都是Java8
                new Version(version) > new Version("1.16.5") ? 8 :
                // 1.17是Java6
                new Version(version) == new Version("1.17") ? 16 :
                // 1.18 1.19 Java 17 1.20往上Java20
                new Version(version) > new Version("1.18") ? 17 : 20;
    }
    /// <summary>
    /// 把各种奇奇怪怪的仓库坐标转换为标准路径
    /// </summary>
    public static string MavenToPath(string librariesPath, string item)
    {
        if (item.StartsWith("[") && item.EndsWith("]"))
        {
            item = item.Substring(1, item.Length - 2);
        }
        string[] parts = item.Split(':');
        // 包
        string groupId = parts[0];
        // 名
        string artifactId = parts[1];
        // 版本
        string version = parts[2];
        // 可选信息 (classifier)
        string? classifier = null;
        // 后缀名 (extension)
        string suffix = "jar"; // 默认后缀名

        if (parts.Length > 3)
        {
            string more = parts[3];
            if (more.Contains("@"))
            {
                string[] s = more.Split('@');
                classifier = s[0];
                suffix = s[1];
            }
            else
            {
                classifier = more; // 如果没有@，则整个more就是classifier
                // 此时 suffix 保持默认值 "jar"
            }
        }
        else if (version.Contains("@")) // 如果可选信息为空，但版本中包含@，例如 "org.ow2.asm:asm:9.3@jar"
        {
            string[] s = version.Split('@');
            version = s[0];
            suffix = s[1];
        }

        // 构建文件名
        string filename = artifactId + "-" + version;
        if (!string.IsNullOrEmpty(classifier))
        {
            filename += "-" + classifier;
        }
        filename += "." + suffix;

        // 构建完整路径
        string fullPath = Path.Combine(librariesPath,
                                       Path.Combine(groupId.Split('.')),
                                       artifactId,
                                       version,
                                       filename);

        return fullPath;
    }

    /// <summary>
    /// 过滤出 Minecraft 的纯粹正式版版本号（如 1.20, 1.20.6）。
    /// </summary>
    /// <param Name="versions">包含所有 Minecraft 版本名称的列表。</param>
    /// <returns>只包含纯粹正式版版本号的列表。</returns>
    public static List<string> McVsFilter(List<string> versions)
    {
        // 静态编译正则表达式，匹配 1.x 或 1.x.x 格式的正式版
        Regex OfficialVersionRegex = new Regex(
            @"^1\.[0-9]{1,2}(?:\.[0-9]{1,2})?$",
            RegexOptions.IgnoreCase | RegexOptions.Compiled
        );

        return versions
            .Where(version => OfficialVersionRegex.IsMatch(version))
            .ToList();
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/ImportPCL2Version/ImportMain.cs
【代码拼接器】文件内容开始
//using OneLauncher.Core.Compatible.ImportPCL2Version;
//using OneLauncher.Core.Downloader;
//using OneLauncher.Core.Downloader.DownloadMinecraftProviders;
//using OneLauncher.Core.Global;
//using OneLauncher.Core.Helper;
//using OneLauncher.Core.Minecraft;
//using System;
//using System.Collections.Concurrent;
//using System.Collections.Generic;
//using System.ComponentModel.DataAnnotations;
//using System.Diagnostics;
//using System.Linq;
//using System.Text;
//using System.Text.Json;
//using System.Threading.Tasks;

//namespace OneLauncher.Core.Helper.ImportPCL2Version;

///// <summary>
///// 负责处理从 PCL2 实例文件夹导入游戏到 OneLauncher 的全部逻辑。
///// </summary>
//public class PCL2Importer
//{
//    public CancellationToken token;
//    public IProgress<(DownProgress Title, int AllFiles, int DownedFiles, string DowingFileName)> process;
//    public PCL2Importer(IProgress<(DownProgress Title, int AllFiles, int DownedFiles, string DowingFileName)> process, CancellationToken? token = null)
//    {
//        this.token = token ?? CancellationToken.None;
//        this.process = process;
//    }

//    //public async Task ImportAsync(string pclVersionPath)
//    //{
//    //    string versionJsonPath = FindAuthoritativeJsonFile(pclVersionPath);
//    //    var info = await JsonSerializer.DeserializeAsync(File.OpenRead(versionJsonPath),PCL2VersionJsonContent.Default.PCL2VersionJsonModels);
//    //    ModEnum modLoaderType = Tools.MainClassToModEnum(info.MainClass);
//    //    GameData gameData = new GameData(info.UserCustomName,info.ClientVersionID,modLoaderType,null);
//    //    await Init.GameDataManger.AddGameDataAsync(gameData);
//    //    await InstallMinecraft(gameData,info.ClientVersionID,modLoaderType);
//    //    await MigrateUserDataAsync(pclVersionPath,gameData.InstancePath);
//    //}
//    public async Task ImportAsync(string pclVersionPath)
//    {
//        // 1. 识别路径和基本信息
//        string pclMinecraftRoot = Directory.GetParent(pclVersionPath)?.Parent?.FullName
//                                  ?? throw new OlanException("导入失败","无法确定 PCL2 的 .minecraft 根目录。");

        
//        string instanceName = Path.GetFileName(pclVersionPath);

//        // 2. 创建 OneLauncher 实例
//        var gameData = new GameData(instanceName, mcVersion, modLoader, null);

//        // 3. 调用重构后的 InstallMinecraft 方法，执行核心的文件同步和安装流程
//        await InstallMinecraft(gameData, pclMinecraftRoot);

//        // 4. 迁移用户数据
//        ProcessReporter?.Report((DownProgress.Done, _totalFilesToProcess, _totalFilesToProcess, "正在迁移用户数据..."));
//        await MigrateUserDataAsync(pclVersionPath, gameData.InstancePath);

//        await Init.GameDataManger.AddGameDataAsync(gameData);

//        ProcessReporter?.Report((DownProgress.Done, _totalFilesToProcess, _totalFilesToProcess, "导入完成！"));
//    }
//    #region 辅助方法
//    private async Task InstallMinecraft(GameData gameData, string pclMinecraftRoot)
//    {
//        ProcessReporter?.Report((DownProgress.Meta, 0, 0, "正在生成标准文件清单..."));

//        // 创建一个临时的 DownloadInfo 来生成标准文件清单
//        var downloadInfo = await DownloadInfo.Create(
//            gameData.VersionId,
//            new ModType { IsFabric = gameData.ModLoader == ModEnum.fabric, IsNeoForge = gameData.ModLoader == ModEnum.neoforge, IsForge = gameData.ModLoader == ModEnum.forge },
//            _downloader,
//            gameDataD: gameData
//        );

//        var downloadPlanner = new DownloadMinecraft(downloadInfo, null, Token);

//        // 手动模拟 CreateDownloadPlan 的逻辑来获取完整文件列表
//        var versionInfo = downloadInfo.VersionMojangInfo;
//        var libraries = versionInfo.GetLibraries();
//        var assetsIndexItem = versionInfo.GetAssets();

//        string assetsIndexPathInOlan = assetsIndexItem.path;
//        if (!File.Exists(assetsIndexPathInOlan))
//        {
//            string assetsIndexPathInPcl = Path.Combine(pclMinecraftRoot, "assets", "indexes", $"{assetsIndexItem.Id}.json");
//            if (File.Exists(assetsIndexPathInPcl))
//            {
//                Directory.CreateDirectory(Path.GetDirectoryName(assetsIndexPathInOlan)!);
//                File.Copy(assetsIndexPathInPcl, assetsIndexPathInOlan, true);
//            }
//            else
//            {
//                await _downloader.DownloadFile(assetsIndexItem.Url, assetsIndexPathInOlan, Token);
//            }
//        }
//        var assets = VersionAssetIndex.ParseAssetsIndex(await File.ReadAllTextAsync(assetsIndexPathInOlan, Token), Init.GameRootPath);

//        var allRequiredFiles = new List<NdDowItem>();
//        allRequiredFiles.AddRange(libraries);
//        allRequiredFiles.AddRange(assets);
//        allRequiredFiles.Add(versionInfo.GetMainFile());
//        if (versionInfo.GetLoggingConfig() is NdDowItem loggingConfig) allRequiredFiles.Add(loggingConfig);

//        _totalFilesToProcess = allRequiredFiles.Count;
//        var filesToDownload = new ConcurrentBag<NdDowItem>();

//        // 并行处理文件：优先从 PCL2 复制
//        ProcessReporter?.Report((DownProgress.Meta, _totalFilesToProcess, 0, "正在比对 PCL2 本地文件..."));
//        await Parallel.ForEachAsync(allRequiredFiles, new ParallelOptions { MaxDegreeOfParallelism = 16, CancellationToken = Token }, async (requiredFile, cancellationToken) =>
//        {
//            string relativePath = Path.GetRelativePath(Init.GameRootPath, requiredFile.path);
//            string pclSourcePath = Path.Combine(pclMinecraftRoot, relativePath);

//            if (!File.Exists(pclSourcePath) || (requiredFile.sha1 != null && !await IsFileValidAsync(pclSourcePath, requiredFile.sha1)))
//            {
//                filesToDownload.Add(requiredFile);
//            }
//            else
//            {
//                Directory.CreateDirectory(Path.GetDirectoryName(requiredFile.path)!);
//                File.Copy(pclSourcePath, requiredFile.path, true);
//            }

//            int currentCount = Interlocked.Increment(ref _processedFilesCount);
//            ProcessReporter?.Report((DownProgress.Meta, _totalFilesToProcess, currentCount, Path.GetFileName(requiredFile.path)));
//        });

//        // 下载所有缺失或损坏的文件
//        if (!filesToDownload.IsEmpty)
//        {
//            var downloadList = filesToDownload.ToList();
//            ProcessReporter?.Report((DownProgress.DownLibs, downloadList.Count, 0, "开始下载缺失的文件..."));
//            await _downloader.DownloadListAsync(new Progress<(int completed, string fileName)>(p =>
//            {
//                ProcessReporter?.Report((DownProgress.DownLibs, downloadList.Count, p.completed, p.fileName));
//            }), downloadList, Init.ConfigManager.config.OlanSettings.MaximumDownloadThreads, Token);
//        }

//        // 最后，完整地执行一次安装流程（主要为了运行处理器和生成最终的json）
//        ProcessReporter?.Report((DownProgress.DownAndInstModFiles, 0, 0, "正在配置 Mod 加载器..."));
//        await downloadPlanner.MinecraftBasic(
//            Init.ConfigManager.config.OlanSettings.MaximumDownloadThreads,
//            Init.ConfigManager.config.OlanSettings.MaximumSha1Threads,
//            Init.ConfigManager.config.OlanSettings.IsSha1Enabled,
//            Init.ConfigManager.config.OlanSettings.IsAllowToDownloadUseBMLCAPI
//        );
//    }
//    private string FindAuthoritativeJsonFile(string versionPath)
//    {
//        var jsonFiles = Directory.EnumerateFiles(versionPath, "*.json").ToList();
//        if (!jsonFiles.Any())
//            throw new OlanException("无法导入","无法在PCL的版本文件内");

//        // 优先寻找和文件夹同名的json
//        string expectedJsonName = $"{Path.GetDirectoryName(versionPath)}.json";
//        string? authoritativeJson = jsonFiles.FirstOrDefault(f => Path.GetFileName(f).Equals(expectedJsonName, StringComparison.OrdinalIgnoreCase));

//        // 如果找不到，就用第一个作为备选
//        return authoritativeJson ?? jsonFiles.First();
//    }
//    //private async Task InstallMinecraft(GameData gameData,string versionID,ModEnum modLoaderType)
//    //{
//    //    //using Download downTool = new Download();
//    //    //// 调用自己的方法把版本下了
//    //    //// 这里离开using会释放，所以要在这里等待
//    //    //await new DownloadMinecraft(downTool, new UserVersion()
//    //    //{
//    //    //    VersionID = versionID,
//    //    //    modType = new ModType()
//    //    //    {
//    //    //        IsFabric = modLoaderType == ModEnum.fabric,
//    //    //        IsNeoForge = modLoaderType == ModEnum.neoforge,
//    //    //    }
//    //    //}, Init.MojangVersionList.FirstOrDefault(x => x.ID == versionID),
//    //    //gameData, Init.GameRootPath,
//    //    //process, 
//    //    //token).MinecraftBasic(
//    //    //    Init.ConfigManager.config.OlanSettings.MaximumDownloadThreads,
//    //    //    Init.ConfigManager.config.OlanSettings.MaximumSha1Threads,
//    //    //    Init.ConfigManager.config.OlanSettings.IsSha1Enabled,
//    //    //    Init.ConfigManager.config.OlanSettings.IsAllowToDownloadUseBMLCAPI);
//    //}
//    private async Task MigrateUserDataAsync(string sourcePath, string destinationPath)
//    {
//        // 定义需要迁移的文件夹和文件列表
//        var foldersToMove = new[] { "saves", "mods", "resourcepacks", "shaderpacks", "config", "logs" };
//        var filesToMove = new[] { "options.txt" };

//        // --- 这是补全的部分 ---
//        foreach (var folderName in foldersToMove)
//        {
//            token.ThrowIfCancellationRequested(); // 在每个循环开始时检查是否已请求取消
//            string sourceFolder = Path.Combine(sourcePath, folderName);
//            if (Directory.Exists(sourceFolder))
//            {
//                string destFolder = Path.Combine(destinationPath, folderName);
//                // 使用你已有的 Tools.CopyDirectoryAsync 方法来递归复制文件夹
//                await Tools.CopyDirectoryAsync(sourceFolder, destFolder, token);
//            }
//        }
//        // --- 补全结束 ---

//        foreach (var fileName in filesToMove)
//        {
//            token.ThrowIfCancellationRequested();
//            string sourceFile = Path.Combine(sourcePath, fileName);
//            if (File.Exists(sourceFile))
//            {
//                string destFile = Path.Combine(destinationPath, fileName);
//                File.Copy(sourceFile, destFile, true);
//            }
//        }
//    }
//    #endregion
//}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/ImportPCL2Version/JsonModels.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace OneLauncher.Core.Compatible.ImportPCL2Version;
[JsonSerializable(typeof(PCL2VersionJsonModels))]
public partial class PCL2VersionJsonContent : JsonSerializerContext { }
public class PCL2VersionJsonModels
{
    [JsonPropertyName("clientVersion")]
    public string ClientVersionID { get; set; }
    [JsonPropertyName("mainClass")]
    public string MainClass {  get; set; }
    [JsonPropertyName("id")]
    public string UserCustomName { get; set; }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/ImportPCL2Version/SetupFucker.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper.ImportPCL2Version;

/// <summary>
/// 用于读取 PCL2 的 Setup.ini 文件来知道MC版本号、模组加载器。
/// </summary>
public class PCL2SetupFucker
{
    private readonly Dictionary<string, string> values;

    public PCL2SetupFucker(string filePath)
    {
        values = File.ReadAllLines(filePath)
            .Select(line => line.Split(new[] { ':' }, 2))
            .Where(parts => parts.Length == 2)
            .ToDictionary(parts => parts[0].Trim(), parts => parts[1].Trim(), StringComparer.OrdinalIgnoreCase); // 忽略键的大小写
    }
    public string GetValue(string key) => values.TryGetValue(key, out var value) ? value : string.Empty;
    public string GetMinecraftVersion() => GetValue("VersionOriginal");
    public ModEnum GetModLoader()
    {
        if (!string.IsNullOrEmpty(GetValue("VersionNeoForge"))) return ModEnum.neoforge;
        if (!string.IsNullOrEmpty(GetValue("VersionFabric"))) return ModEnum.fabric;
        if (!string.IsNullOrEmpty(GetValue("VersionForge"))) return ModEnum.forge;
        return ModEnum.none;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/Models/GameData.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper.Models;
/// <summary>
/// 游戏数据，基于版本（UserVersion）
/// </summary>
public class GameData
{
    public string Name { get; set; }
    public string VersionId { get; set; }
    public ModEnum ModLoader { get; set; }
    public DateTime CreationTime { get; set; }
    public Guid DefaultUserModelID { get; set; }
    public string InstanceId { get; set; }
    public string? CustomIconPath { get; set; } // 自定义图标路径，若为null则据模组加载器类型默认
    [JsonIgnore]
    public string InstancePath => Path.Combine(Init.GameRootPath, "instance", InstanceId);
    [JsonConstructor]
    // 修改这里的参数名以匹配属性名
    public GameData(string name, string versionId, ModEnum modLoader, Guid defaultUserModelID, DateTime creationTime, string instanceId, string? customIconPath)
    {
        Name = name;
        VersionId = versionId;
        ModLoader = modLoader; // 参数 modLoader 对应属性 ModLoader
        DefaultUserModelID = defaultUserModelID; 
        CreationTime = creationTime;
        InstanceId = instanceId;
        CustomIconPath = customIconPath;
    }
    public GameData(string name, string versionId, ModEnum loader, Guid userModel,string? customIconPath = null)
    {
        Name = name;
        VersionId = versionId;
        ModLoader = loader;
        CustomIconPath = customIconPath;
        DefaultUserModelID = userModel;
        CreationTime = DateTime.Now;
        InstanceId = Guid.NewGuid().ToString()[..8]; // 避免路径过长
    }
    public override string ToString()
        => VersionId;
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/Models/JvmArgument.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper.Models;

public enum OptimizationMode
{
    /// <summary>保守模式</summary>
    Conservative,
    /// <summary>标准模式</summary>
    Standard,
    /// <summary>激进模式</summary>
    Aggressive
}
/// <summary>
/// 存放所有可配置的JVM参数。
/// 设计为纯数据类（POCO），方便进行序列化/反序列化（如存为JSON配置文件）。
/// </summary>
public class JvmArguments
{
    public OptimizationMode mode { get; set; }
    #region 核心内存设置 (Core Memory Settings)
    public int MaxHeapSize { get; set; } = 0;
    public int InitialHeapSize { get; set; } = 0;
    #endregion

    #region 垃圾收集器选择 (Garbage Collector Selection)
    public bool UseG1GC { get; set; } = true;
    public bool UseZGC { get; set; } = false;
    public bool UseShenandoahGC { get; set; } = false;
    #endregion

    #region G1GC 专用参数 (G1GC Specifics)
    public int MaxGCPauseMillis { get; set; } = 50;
    public int G1HeapRegionSize { get; set; } = 0; // 0 = 自动
    public int G1NewSizePercent { get; set; } = 30;
    public int G1MaxNewSizePercent { get; set; } = 60;
    public int G1ReservePercent { get; set; } = 15;
    public bool G1UseStringDeduplication { get; set; } = true;
    #endregion

    #region ZGC/Shenandoah 专用参数
    public bool UseGenerationalGCForZOrShenandoah { get; set; } = true;
    #endregion

    #region 通用优化标志 (Common Optimization Flags)
    public bool DisableExplicitGC { get; set; } = true;
    public bool ParallelRefProcEnabled { get; set; } = true;
    public bool AlwaysPreTouch { get; set; } = false;
    public bool PerfDisableSharedMem { get; set; } = true;
    public bool UseAikarFlags { get; set; } = false;
    #endregion

    public JvmArguments() { }

    /// <summary>
    /// [硬件感知的预设工厂] 根据用户的硬件和选择的模式，生成一份智能的推荐配置。
    /// 这份配置可以被用户的自定义文件覆盖。
    /// </summary>
    public static JvmArguments CreateFromMode(OptimizationMode mode = OptimizationMode.Standard)
    {
        var args = new JvmArguments();
        args.mode = mode;
        // 使用Helper API获取硬件信息 ---
        long totalSystemMemoryBytes = GC.GetGCMemoryInfo().TotalAvailableMemoryBytes;
        long totalSystemMemoryGB = totalSystemMemoryBytes / 1024 / 1024 / 1024;

        // --- 2. 根据模式和硬件信息设置优化标志 ---
        switch (mode)
        {
            case OptimizationMode.Aggressive:
                // --- 激进模式 ---
                args.AlwaysPreTouch = true;
                args.UseAikarFlags = true;

                // 智能GC选择：内存充裕 (>=16GB) 的中高端机，默认推荐使用ZGC以获得更低的延迟
                // ZGC非常适合大内存下的MC客户端，可以显著减少卡顿
                if (totalSystemMemoryGB >= 16)
                {
                    args.UseZGC = true;
                    args.UseG1GC = false;
                    args.UseGenerationalGCForZOrShenandoah = true; // 为ZGC启用分代
                }
                else
                {
                    // 内存不足16GB，则使用高度优化的G1GC
                    args.UseG1GC = true;
                    args.MaxGCPauseMillis = 40;
                    args.G1HeapRegionSize = totalSystemMemoryGB >= 12 ? 32 : 16; // 内存稍大时，用32M的Region
                    args.G1NewSizePercent = 40;
                    args.G1ReservePercent = 10;
                }
                break;

            case OptimizationMode.Conservative:
                // --- 保守模式 ---
                args.UseG1GC = true; // 总是使用稳定可靠的G1GC
                args.MaxGCPauseMillis = 200; // 更宽松的停顿时间，注重吞吐
                args.G1HeapRegionSize = totalSystemMemoryGB < 8 ? 8 : 16; // 低内存系统使用更小的Region Size
                args.G1NewSizePercent = 20;
                args.G1MaxNewSizePercent = 50;
                args.AlwaysPreTouch = false;
                args.UseAikarFlags = false;
                break;

            // 默认 Standard 模式
            default:
                // --- 标准模式 ---
                args.UseG1GC = true;
                args.UseAikarFlags = true;
                args.MaxGCPauseMillis = 50;

                // 智能调整G1 Region Size：内存大于等于12GB时，使用32M可以提升性能
                args.G1HeapRegionSize = totalSystemMemoryGB >= 12 ? 32 : 16;
                args.G1NewSizePercent = 30;
                args.G1MaxNewSizePercent = 60;
                args.AlwaysPreTouch = false;
                break;
        }
        return args;
    }

    public string ToString(int jvmVersion)
    {
        var argsBuilder = new StringBuilder();

        #region 1. 真正的智能内存分配模型

        // 1.获取最真实的系统可用内存
        var memoryMetrics = SystemMemoryHelper.GetMemoryMetrics();
        long availableMemoryMB = (long)memoryMetrics.FreeMB;

        int finalMaxHeapSize;

        if (MaxHeapSize > 0) // Case 1: 用户手动指定了内存大小
        {
            finalMaxHeapSize = MaxHeapSize;
        }
        else // Case 2: 用户选择了“自动”模式
        {
            const long minMemoryMB = 1024; // 游戏能启动的最小内存

            // 2. 为系统和其他应用保留512MB的绝对安全底线
            long memoryForGame = availableMemoryMB - 512;

            if (memoryForGame <= minMemoryMB)
            {
                // 如果可用内存极低，只能分配最小值
                finalMaxHeapSize = (int)minMemoryMB;
            }
            else
            {
                // 3. 应用非线性智能算法
                const long thresholdMB = 8L * 1024; // 8GB 阈值
                const long hardCapMB = 16L * 1024;  // 16GB 硬上限
                long suggestedMB;

                if (memoryForGame <= thresholdMB)
                {
                    // 8GB以内，慷慨分配80%
                    suggestedMB = (long)(memoryForGame * 0.8);
                }
                else
                {
                    // 超过8GB的部分，只吝啬地分配20%
                    suggestedMB = (long)(thresholdMB * 0.8) + (long)((memoryForGame - thresholdMB) * 0.2);
                }

                // 4. 应用硬上限，并确保不低于我们设定的最小启动内存
                finalMaxHeapSize = (int)Math.Max(minMemoryMB, Math.Min(suggestedMB, hardCapMB));
            }
        }

        // 5. 计算初始堆大小 (-Xms)
        int finalInitialHeapSize;
        if (InitialHeapSize > 0) // 用户手动设置了初始值
        {
            finalInitialHeapSize = InitialHeapSize;
        }
        else // 自动计算初始值
        {
            // 激进模式下设为与最大值相同，其他模式为最大值一半（但不小于1024MB）
            finalInitialHeapSize = mode == OptimizationMode.Aggressive
                ? finalMaxHeapSize
                : Math.Clamp(finalMaxHeapSize / 2, 1024, finalMaxHeapSize);
        }

        // 最终校验，确保初始值不会大于最大值
        finalInitialHeapSize = Math.Min(finalInitialHeapSize, finalMaxHeapSize);

        argsBuilder.Append($" -Xms{finalInitialHeapSize}m -Xmx{finalMaxHeapSize}m");

        #endregion

        #region 2. GC 和其他参数组装

        argsBuilder.Append(" -XX:+UnlockExperimentalVMOptions");

        // --- GC 选择 ---
        if (UseG1GC)
        {
            argsBuilder.Append(" -XX:+UseG1GC");
            if (G1UseStringDeduplication && jvmVersion >= 8) argsBuilder.Append(" -XX:+UseStringDeduplication");
            argsBuilder.Append($" -XX:MaxGCPauseMillis={MaxGCPauseMillis}");
            argsBuilder.Append($" -XX:G1NewSizePercent={G1NewSizePercent}");
            argsBuilder.Append($" -XX:G1MaxNewSizePercent={G1MaxNewSizePercent}");
            if (G1HeapRegionSize > 0) argsBuilder.Append($" -XX:G1HeapRegionSize={G1HeapRegionSize}M");
            argsBuilder.Append($" -XX:G1ReservePercent={G1ReservePercent}");
        }
        else if (UseZGC)
        {
            argsBuilder.Append(" -XX:+UseZGC");
            // ZGC 分代在 JDK 21+ 成为正式特性
            if (UseGenerationalGCForZOrShenandoah && jvmVersion >= 21)
            {
                argsBuilder.Append(" -XX:+ZGenerational");
            }
        }
        else if (UseShenandoahGC)
        {
            argsBuilder.Append(" -XX:+UseShenandoahGC");
            // Shenandoah 分代支持情况类似, 需查阅具体JDK版本文档
        }

        // --- 通用优化 ---
        // 这些参数在较新版JVM(11+)上普遍适用
        if (jvmVersion >= 11)
        {
            if (DisableExplicitGC) argsBuilder.Append(" -XX:+DisableExplicitGC");
            if (ParallelRefProcEnabled) argsBuilder.Append(" -XX:+ParallelRefProcEnabled");
            if (AlwaysPreTouch) argsBuilder.Append(" -XX:+AlwaysPreTouch");
            // PerfDisableSharedMem 和 Aikar's flags 有重叠，为了清晰，在此处条件化
            if (PerfDisableSharedMem && !UseAikarFlags) argsBuilder.Append(" -XX:+PerfDisableSharedMem");
        }

        // --- Aikar's Flags (社区验证的高级优化) ---
        // 主要针对 G1GC, 适用于 Minecraft 这类负载
        if (UseG1GC && UseAikarFlags && jvmVersion >= 11)
        {
            argsBuilder.Append(" -XX:+UseNUMA") // 在支持NUMA的服务器硬件上有用
                       .Append(" -XX:G1MixedGCCountTarget=4")
                       .Append(" -XX:G1MixedGCLiveThresholdPercent=90")
                       .Append(" -XX:G1RSetUpdatingPauseTimePercent=5")
                       .Append(" -XX:SurvivorRatio=32")
                       .Append(" -XX:+PerfDisableSharedMem")
                       .Append(" -XX:MaxTenuringThreshold=1")
                       .Append(" -Dusing.aikars.flags=true");
        }

        #endregion

        return $" {argsBuilder.ToString().Trim()} ";
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/Models/SomeClasses.cs
【代码拼接器】文件内容开始
using Microsoft.Identity.Client;
using OneLauncher.Core.Net.msa;
using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

namespace OneLauncher.Core.Helper.Models;

public enum SortingType
{
    AnTime_OldFront,
    AnTime_NewFront,
    AnVersion_OldFront,
    AnVersion_NewFront,
}
public struct ServerInfo
{
    public string Ip;
    public string Port;
}
public struct ModType
{
    public bool IsFabric { get; set; }
    public bool IsNeoForge { get; set; }
    public bool IsForge { get; set; }
    public bool IsQuilt { get; set; }
    public ModEnum ToModEnum()
    {
        if (IsFabric)
            return ModEnum.fabric;
        if (IsNeoForge)
            return ModEnum.neoforge;
        if (IsForge)
            return ModEnum.forge;
        if (IsQuilt) 
            return ModEnum.quilt;

        return ModEnum.none;
    }
    public static bool operator ==(ModType left, ModEnum right)
    {
        if (left.IsFabric && right == ModEnum.fabric)
            return true;
        else if (left.IsNeoForge && right == ModEnum.neoforge)
            return true;
        else if (left.IsForge && right == ModEnum.forge)
            return true;
        else if (left.IsQuilt && right == ModEnum.quilt) 
            return true;
        else
            return false;
    }
    public static bool operator !=(ModType left, ModEnum right)
        => !(left == right);
}
public enum ModEnum
{
    none,
    fabric,
    neoforge,
    forge,
    quilt
}

/// <summary>
/// 描述单个下载项
/// </summary>
/// 
public struct NdDowItem
{
    /// <param ID="Url">下载地址</param>
    /// <param ID="Sha1">SHA1校验码</param>
    /// <param ID="Path">保存地址（含文件名）</param>
    /// <param Name="Size">文件大小（单位字节）</param>
    public NdDowItem(string Url, string Path, int Size, string? Sha1 = null)
    {
        url = Url;
        path = Path;
        if (Sha1 != null)
            sha1 = Sha1;
    }
    public string url;
    public string path;
    public int size;
    public string? sha1;
}
// 不要把他改成结构体，不然会出一些神奇的问题
public class VersionBasicInfo
{
    /// <param ID="Name">版本标识符</param>
    /// <param ID="type">版本类型</param>
    /// <param ID="url">版本文件下载地址</param>
    /// <param ID="time">版本发布时间</param>
    public VersionBasicInfo(string ID, string type, DateTime time, string url)
    {
        this.ID = ID;
        this.type = type;
        this.time = time;
        Url = url;
    }
    // 如果不重写该方法 AutoCompleteBox 会报错
    public override string ToString()
    {
        return ID.ToString();
    }
    public string ID { get; set; }
    public string type { get; set; }
    public DateTime time { get; set; }
    public string Url { get; set; }
}
public enum SystemType
{
    windows,
    osx,
    linux
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/Models/UserModel.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Net.msa;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper.Models;
public class UserModel
{
    public const string nullToken = "00000000-0000-0000-0000-000000000000";


    #region 构造函数
    /// <summary>
    /// 主要构造函数。
    /// </summary>
    public UserModel(
        Guid UserID,
        string name,
        Guid uuid,
        // 下面的仅限正版用户
        string? accessToken = null,
        string? accountID = null,
        int? accessTokenExpiration = null)
    {
        this.UserID = UserID;
        Name = name;
        this.uuid = uuid;

        if (string.IsNullOrEmpty(accessToken) || accessToken == nullToken)
        {
            AccessToken = nullToken;
            IsMsaUser = false;
            AccountID = null;
            AccessTokenExpiration = null;
        }
        else
        {
            IsMsaUser = true;
            AccessToken = accessToken;
            AccountID = accountID;
            AccessTokenExpiration = DateTimeOffset.UtcNow.AddSeconds(accessTokenExpiration ?? 86400);
        }
    }
    [JsonConstructor]
    public UserModel(
        Guid UserID,
        string Name,
        Guid uuid,
        string accessToken,
        bool IsMsaUser,
        string? AccountID,
        DateTimeOffset? AccessTokenExpiration
        )
    {
        this.UserID = UserID;
        this.Name = Name;
        this.uuid = uuid;
        AccessToken = accessToken;
        this.IsMsaUser = IsMsaUser;
        this.AccountID = AccountID;
        this.AccessTokenExpiration = AccessTokenExpiration;
    }

    #endregion

    /// <summary>
    /// 【新】智能登录方法。
    /// 检查自身令牌是否过期，如果过期则尝试刷新，并返回一个包含最新状态的新实例。
    /// </summary>
    /// <returns>
    /// 【警告】此方法返回一个新的实例，而不是修改我自己
    /// </returns>
    public async Task<UserModel> IntelligentLogin(MsalAuthenticator authenticator)
    {
        // 如果不是正版用户，或令牌未过期，则直接返回自身，无需任何操作。
        if (!IsMsaUser || AccessTokenExpiration.HasValue && AccessTokenExpiration.Value > DateTimeOffset.UtcNow)
        {
            return this;
        }

        // 令牌已过期，需要刷新。检查能否刷新。
        if (authenticator == null || string.IsNullOrEmpty(AccountID))
        {
            // 缺少刷新所需的工具或信息，返回自身。
            return this;
        }

        // 从认证器缓存中找到对应的微软账户
        var accountToRefresh = await Tools.UseAccountIDToFind(AccountID);
        if (accountToRefresh == null)
        {
            return this;
        }

        try
        {
            // 调用认证器执行刷新流程
            UserModel r = await authenticator.TryToGetMinecraftMojangAccessTokenForLoginedAccounts(accountToRefresh) ?? this;

            // 如果刷新成功，返回那个全新的 UserModel并更改自身；如果失败（返回null），则返回当前的（已过期的）实例。
            AccessToken = r.AccessToken;
            AccessTokenExpiration = r.AccessTokenExpiration;
            _=Init.AccountManager.Save();
            return r;
        }
        catch (Exception)
        {
            // 刷新过程中发生异常，返回当前实例。
            return this;
        }
    }

    public override string ToString()
    {
        return IsMsaUser ? "正版登入" : "离线登入";
    }

    // --- 属性 ---
    public Guid UserID { get; set; }
    public string Name { get; set; }
    public Guid uuid { get; set; }
    public string AccessToken { get; set; }
    public bool IsMsaUser { get; set; }
    public string? AccountID { get; set; }
    public DateTimeOffset? AccessTokenExpiration { get; set; }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Helper/Models/UserVersion.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

namespace OneLauncher.Core.Helper.Models;
public class UserVersion
{
    public string VersionID { get; set; }
    [JsonIgnore]
    public string VersionPath { get => Path.Combine(Init.GameRootPath,"versions",VersionID);}
    public ModType modType { get; set; }
    public DateTime AddTime { get; set; }
    public override string ToString()
    {
        return VersionID;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/GameLauncher.cs
【代码拼接器】文件内容开始
//using OneLauncher.Core.Global;
//using OneLauncher.Core.Helper.Models;
//using System.Diagnostics;
//using System.IO;
//using System.Text;
//using System.Threading;
//using System.Threading.Tasks;
//using System;

//namespace OneLauncher.Core.Launcher;
//public class GameLauncher : IGameLauncher, IDisposable
//{
//    public event Action? GameStartedEvent;
//    public event Action? GameClosedEvent;
//    public event Action<string>? GameOutputEvent;

//    private Process? _gameProcess;
//    public CancellationToken CancellationToken = CancellationToken.None; // 外部可以设置

//    /// <summary>
//    /// 根据提供的 GameData 启动游戏。
//    /// </summary>
//    public async Task Play(GameData gameData, ServerInfo? serverInfo = null)
//    {
//        try
//        {
//            // 刷新令牌
//            Task refreshTokenTask =  Init.AccountManager.GetUser(gameData.DefaultUserModelID).IntelligentLogin(Init.MMA);

//            var commandBuilder = new LaunchCommandBuilder(
//                Init.GameRootPath,
//                gameData,
//                serverInfo
//            );

//            // 写进文件
//            string launchArgumentsPath = Path.GetTempFileName();
//            string arguments = await commandBuilder.BuildCommand(
//                Init.ConfigManger.Data.OlanSettings.MinecraftJvmArguments.ToString(commandBuilder.versionInfo.GetJavaVersion()),
//                useRootLaunch: false // 根据你的需要调整
//            );

//            // 针对Windows平台的路径特殊处理
//#if WINDOWS
//            arguments = arguments.Replace("\\", @"\\");
//#endif
//            await File.WriteAllTextAsync(launchArgumentsPath, arguments, _cancellationTokenSource.Token);

//            // 4. 配置并启动游戏进程
//            _gameProcess = new Process
//            {
//                StartInfo = new ProcessStartInfo
//                {
//                    FileName = commandBuilder.GetJavaPath(),
//                    Arguments = $"@{launchArgumentsPath}", // 从文件读取参数
//                    WorkingDirectory = Init.GameRootPath,
//                    RedirectStandardOutput = true,
//                    RedirectStandardError = true,
//                    UseShellExecute = false,
//                    CreateNoWindow = true,
//                    StandardOutputEncoding = Encoding.UTF8,
//                    StandardErrorEncoding = Encoding.UTF8
//                },
//                EnableRaisingEvents = true 
//            };

//            _gameProcess.OutputDataReceived += OnOutputDataReceived;
//            _gameProcess.ErrorDataReceived += OnErrorDataReceived;
//            _gameProcess.Exited += OnGameProcessExited;

//            _gameProcess.Start();
//            _gameProcess.BeginOutputReadLine();
//            _gameProcess.BeginErrorReadLine();

//            await _gameProcess.WaitForExitAsync(_cancellationTokenSource.Token);
//        }
//        catch (OperationCanceledException)
//        {
//            GameOutputEvent?.Invoke("[INFO] Game launch was cancelled." + Environment.NewLine);
//        }
//        finally
//        {
//            // 确保资源得到释放
//            CleanupAfterGame();
//        }
//    }

//    // 实现接口中的其他 Play 方法
//    public Task Play(string InstanceOrVersionId, bool isVersionLauncherMode)
//    {
//        // 你需要在这里实现通过ID查找 GameData 或 UserVersion 的逻辑
//        // 然后调用 Play(gameData)
//        throw new NotImplementedException();
//    }

//    public Task Play(UserVersion userVersion, ServerInfo? serverInfo = null, bool useRootMode = false)
//    {
//        // 你需要在这里实现通过 UserVersion 查找或创建 GameData 的逻辑
//        // 然后调用 Play(gameData)
//        throw new NotImplementedException();
//    }

//    /// <summary>
//    /// 强制停止正在运行的游戏进程。
//    /// </summary>
//    public Task Stop()
//    {
//        if (_gameProcess != null && !_gameProcess.HasExited)
//        {
//            _cancellationTokenSource?.Cancel(); // 取消等待
//            _gameProcess.Kill(true); // 强制结束进程树
//            GameOutputEvent?.Invoke("[INFO] Game process has been terminated by the user." + Environment.NewLine);
//        }
//        return Task.CompletedTask;
//    }

//    #region 事件处理
//    private void OnOutputDataReceived(object sender, DataReceivedEventArgs e)
//    {
//        if (string.IsNullOrEmpty(e.Data)) return;
//        GameOutputEvent?.Invoke($"[STDOUT] {e.Data}{Environment.NewLine}");
//        // 在游戏启动后触发事件
//        if (e.Data.Contains("Backend library: LWJGL version"))
//        {
//            GameStartedEvent?.Invoke();
//        }
//    }

//    private void OnErrorDataReceived(object sender, DataReceivedEventArgs e)
//    {
//        if (string.IsNullOrEmpty(e.Data)) return;
//        GameOutputEvent?.Invoke($"[ERROR] {e.Data}{Environment.NewLine}");

//        // 可以在这里添加更复杂的错误识别和处理逻辑
//    }

//    private void OnGameProcessExited(object? sender, EventArgs e)
//    {
//        if (_gameProcess != null)
//        {
//            GameOutputEvent?.Invoke($"[INFO] Game process exited with code: {_gameProcess.ExitCode}{Environment.NewLine}");
//        }

//        GameClosedEvent?.Invoke();
//    }
//    #endregion

//    /// <summary>
//    /// 清理游戏进程相关的资源。
//    /// </summary>
//    private void CleanupAfterGame()
//    {
//        if (_gameProcess != null)
//        {
//            _gameProcess.OutputDataReceived -= OnOutputDataReceived;
//            _gameProcess.ErrorDataReceived -= OnErrorDataReceived;
//            _gameProcess.Exited -= OnGameProcessExited;
//            _gameProcess.Dispose();
//            _gameProcess = null;
//        }

//        if (_cancellationTokenSource != null)
//        {
//            _cancellationTokenSource.Dispose();
//            _cancellationTokenSource = null;
//        }
//    }

//    public void Dispose()
//    {
//        Stop().Wait(); // 等待停止操作完成
//        CleanupAfterGame();
//    }
//}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/IGameLauncher.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher;
/* 开发中重构 */
internal interface IGameLauncher
{
    // 最简单，通过实例ID或版本ID启动游戏，可以选择根启动；通过传参标识
    Task Play(string InstanceOrVersionId,bool isVersionLauncherMode);
    // 通过游戏数据实例启动游戏
    Task Play(GameData gameData, ServerInfo? serverInfo = null); // 调试窗口的显示是UI层的事情
    // 通过用户版本实例启动游戏
    Task Play(UserVersion userVersion, ServerInfo? serverInfo = null,bool useRootMode = false);
    Task Stop();
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/LaunchCommandBuilder.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Launcher.Strategys;
using OneLauncher.Core.Minecraft;
using OneLauncher.Core.Mod.ModLoader.fabric;
using OneLauncher.Core.Mod.ModLoader.fabric.quilt;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace OneLauncher.Core.Launcher;
public partial class LaunchCommandBuilder
{
    public VersionInfomations versionInfo;
    private readonly GameData gameData;
    private readonly string version;
    private readonly string basePath;
    private readonly ModEnum modType;
    private readonly string separator;
    private readonly string VersionPath;
    private readonly ServerInfo? serverInfo;

    // 构造函数保持不变
    public LaunchCommandBuilder(
        string basePath,
        GameData gameData,
        ServerInfo? serverInfo = null)
    {
        this.basePath = basePath;
        this.version = gameData.VersionId;
        this.modType = gameData.ModLoader;
        this.serverInfo = serverInfo;
        this.gameData = gameData;
        this.VersionPath = Path.Combine(this.basePath, "versions", this.version);
        this.separator = Path.PathSeparator.ToString();

        versionInfo = new VersionInfomations(
            File.ReadAllText(Path.Combine(VersionPath, "version.json")),
            this.basePath
        );
    }

    public string GetJavaPath() =>
        Tools.IsUseOlansJreOrOssJdk(versionInfo.GetJavaVersion());

    public async Task<IEnumerable<string>> BuildCommand(string OtherArgs = "", bool useRootLaunch = false)
    {
        // 等启动器重写完了再把这个逻辑丢过去
        await Init.AccountManager.GetUser(gameData.DefaultUserModelID).IntelligentLogin(Init.MsalAuthenticator);
        IModStrategy? strategy = null; // 策略可以是null，代表原版
        if (modType != ModEnum.none)
            strategy = await CreateAndInitStrategy();
        

        // 确定主类：如果策略提供了覆盖，则使用策略的；否则用原版的
        string mainClass = strategy?.GetMainClassOverride() ?? versionInfo.GetMainClass();

        // 将策略传递给各个构建器
        List<string> rargs = new List<string>();
        rargs.AddRange(BuildJvmArgs(strategy));
        rargs.Add(strategy?.GetMainClassOverride() ?? versionInfo.GetMainClass()); // 别把主类忘了
        rargs.AddRange(BuildGameArgs(useRootLaunch ? basePath : gameData.InstancePath ,strategy));
        return rargs;
    }

    // 策略方法
    private async Task<IModStrategy?> CreateAndInitStrategy()
    {
        IModStrategy strategy = modType switch
        {
            ModEnum.fabric => new FabricStrategy(VersionPath, basePath),
            ModEnum.quilt => new QuiltStrategy(VersionPath, basePath),
            ModEnum.neoforge => await NeoForgeStrategy.CreateAsync(VersionPath, basePath, version),
            ModEnum.forge => await ForgeStrategy.CreateAsync(VersionPath, basePath, version),
            _ => throw new OlanException("内部异常",$"不支持的模组加载器 {modType}")
        };
        return strategy;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Builders/ClassPathBuilder.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Launcher.Strategys;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher;

public partial class LaunchCommandBuilder
{
    /// <summary>
    /// 拼接类路径，不包含-p参数
    /// </summary>
    private string BuildClassPath(IModStrategy? strategy) 
    {
        var libraryMap = new Dictionary<string, string>();

        // 如果是Mod，优先添加Mod的库
        if (strategy != null)
            strategy.GetModLibraries()
                .ToList()
                .ForEach(lib => libraryMap[lib.key] = lib.path);

        // 添加原版库（如果不存在于map中）
        foreach (var lib in versionInfo.GetLibraryiesForUsing())
        {
            var parts = lib.name.Split(':');
            if (parts.Length >= 2)
            {
                var libKey = $"{parts[0]}:{parts[1]}";
                libraryMap.TryAdd(libKey, lib.path); // TryAdd 简洁高效
            }
        }

        var finalClassPathLibs = libraryMap.Values.ToList();
        finalClassPathLibs.Add(versionInfo.GetMainFile().path);

        return string.Join(separator, finalClassPathLibs.Where(p => !string.IsNullOrEmpty(p)).Distinct());
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Builders/GameArgsBuilder.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Launcher.Strategys;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher;
public partial class LaunchCommandBuilder
{
    private IEnumerable<string> BuildGameArgs(string gamePath,IModStrategy? strategy)
    {
        var userModel = Init.AccountManager.GetUser(gameData.DefaultUserModelID);
        List<string> Args = new List<string>();
        if (serverInfo != null)
        {
            Args.Add($"--server");
            Args.Add($"\"{((ServerInfo)serverInfo).Ip}\"");
            Args.Add($"--port");
            Args.Add($"\"{((ServerInfo)serverInfo).Port}\"");
            if (new Version(version) > new Version("1.20"))
            {
                Args.Add($"--quickPlayMultiplayer");
                Args.Add($"\"{serverInfo.Value.Ip}:{serverInfo.Value.Port}\"");
            }
        }
        // 添加基本的
        Args.AddRange([
            $"--username \"{userModel.Name}\"",
            $"--version \"{version}\"",
            $"--gameDir \"{gamePath}\"",
            $"--assetsDir \"{(Path.Combine(basePath, "assets"))}\""
            ]);
        if(new Version(version) > new Version("1.7"))
            Args.AddRange([
                $"--assetIndex \"{versionInfo.GetAssetIndexVersion()}\"",
                $"--uuid \"{userModel.uuid}\"",
                $"--accessToken \"{userModel.AccessToken.ToString()}\"",
                $"--userType \"{(userModel.IsMsaUser ? "msa" : "legacy")}\"",
                $"--versionType \"OneLauncher\"",
                "--userProperties {}"
            ]);
        else
            Args.Add($"--session \"{userModel.AccessToken}\"");
        if(strategy != null)
            Args.AddRange(strategy.GetAdditionalGameArgs());

        return Args;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Builders/Helper.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher;
public partial class  LaunchCommandBuilder
{
    internal static string ReplacePlaceholders(string input, Dictionary<string, string> placeholders)
    {
        foreach (var kvp in placeholders)
        {
            input = input.Replace("${" + kvp.Key + "}", kvp.Value);
        }
        return input;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Builders/JvmArgsBuilder.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Launcher.Strategys;
using OneLauncher.Core.Minecraft.JsonModels;
using OneLauncher.Core.Mod.ModLoader.fabric.quilt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher;

public partial class LaunchCommandBuilder
{
    private IEnumerable<string> BuildJvmArgs(IModStrategy? strategy)
    {
        string osName;
#if WINDOWS
        osName = "windows";
#elif MACOS
        osName = "osx";
#else
        osName = "linux"; 
#endif  
        // AI 写的，干什么用的我也不知道
        string arch = RuntimeInformation.OSArchitecture.ToString().ToLower();
        var placeholders = new Dictionary<string, string>
        {
            // 创建占位符映射表 
            // 参考1.21.5.json
            // 手动加上引号
            { "natives_directory", Path.Combine(basePath,"versions",version,"natives") },
            { "launcher_name", "OneLauncher" },
            { "launcher_version", Init.OneLauncherVersoin },
            { "classpath","\""+BuildClassPath(strategy)+"\"" },
            // 一些仅限NeoForge的
            { "version_name" , version},
            { "library_directory" ,"\""+Path.Combine(basePath, "libraries")+"\""},
            { "classpath_separator" , separator}
        };
        // 处理1.13以前版本没有Arguments的情况
        if (versionInfo.info.Arguments == null)
        {
            return
                // 针对 1.6.x 版本不存在log4j2的情况
                [(versionInfo.GetLoggingConfigPath() != null ?
                $"-Dlog4j.configurationFile=\"{versionInfo.GetLoggingConfigPath()}\"" : ""),
                // 处理特定平台要求的参数
                (osName == "windows" ? "-XX:HeapDumpPath=MojangTricksIntelDriversForPerformance_javaw.exe_minecraft.exe.heapdump"
                : osName == "osx" ? "-XstartOnFirstThread" : "") ,
                // 标准JVM参数
                $"-Djava.library.path={placeholders["natives_directory"]}" ,
                $"-Djna.tmpdir={placeholders["natives_directory"]}" ,
                $"-Dorg.lwjgl.system.SharedLibraryExtractPath={placeholders["natives_directory"]}" ,
                $"-Dio.netty.native.workdir={placeholders["natives_directory"]}" ,
                $"-Dminecraft.launcher.brand={placeholders["launcher_name"]}" ,
                $"-Dminecraft.launcher.version={placeholders["launcher_version"]}" ,
                $"-cp {placeholders["classpath"]}"];
        }
        else
        {
            var jvmArgs = new List<string>();
            if (strategy != null)
                jvmArgs.AddRange(strategy.GetAdditionalJvmArgs());
            foreach (var item in versionInfo.info.Arguments.Jvm)
            {
                // 判断是规则套字符串还是简单字符串
                if (item is string str)
                {
                    string replaced = ReplacePlaceholders(str, placeholders);
                    jvmArgs.Add(replaced);
                }
                else if (item is MinecraftArgument arg)
                {
                    if (EvaluateRules(arg.Rules, osName, arch))
                    {
                        if (arg.Value is string valStr)
                        {
                            string replaced = ReplacePlaceholders(valStr, placeholders);
                            jvmArgs.Add(replaced);
                        }
                        else if (arg.Value is List<string> valList)
                        {
                            foreach (var val in valList)
                            {
                                string replaced = ReplacePlaceholders(val, placeholders);
                                jvmArgs.Add($"\"{replaced}\"");
                            }
                        }
                    }
                }
            }
            jvmArgs.Add($"-Dlog4j.configurationFile=\"{versionInfo.GetLoggingConfigPath()}\"");
            return jvmArgs;
        }
    }
    private bool EvaluateRules(List<MinecraftRule> rules, string osName, string arch)
    {
        if (rules == null || rules.Count == 0) return true;
        bool allowed = false;
        foreach (var rule in rules)
        {
            bool matches = true;
            if (rule.Os != null)
            {
                if (rule.Os.Name != null && rule.Os.Name != osName) matches = false;
            }
            if (matches)
            {
                allowed = rule.Action == "allow";
            }
        }
        return allowed;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Strategys/FabricStrategy.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Mod.ModLoader.fabric;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher.Strategys;

internal class FabricStrategy : IModStrategy
{
    private readonly FabricVJParser _fabricParser;

    public FabricStrategy(string versionPath, string basePath)
    {
        string fabricJsonPath = Path.Combine(versionPath, "version.fabric.json");
        using var fs = File.OpenRead(fabricJsonPath);
        _fabricParser = FabricVJParser.ParserAuto(fs, basePath);
    }

    public string? GetMainClassOverride() => _fabricParser.GetMainClass();

    // Fabric需要优先加载自己的库
    //public IEnumerable<(string key, string path)> GetModLibraries()=> _fabricParser.GetLibrariesForUsing().Select(x => (string.Join(string.Empty, x.name.Split(':')[..^1]), x.path));
    public IEnumerable<(string key, string path)> GetModLibraries()
       => _fabricParser.GetLibrariesForUsing().Select(lib =>
          {
              var parts = lib.name.Split(':');
              var key = string.Join(":", parts[..^1]);
              return (key, lib.path);
          });
    

    // Fabric本身不添加额外的JVM和游戏参数
    public IEnumerable<string> GetAdditionalJvmArgs() => Enumerable.Empty<string>();
    public IEnumerable<string> GetAdditionalGameArgs() => Enumerable.Empty<string>();
}


【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Strategys/ForgeStrategy.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.NetworkInformation;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher.Strategys;

internal class ForgeStrategy : IModStrategy
{
    private readonly ForgeSeriesUsing _parser;
    private readonly string _basePath;
    private readonly string _versionID;
    private ForgeStrategy(string basePath,string versionID)
    {
        _parser = new ForgeSeriesUsing();
        _basePath = basePath;
        _versionID = versionID;
    }
    public static async Task<ForgeStrategy> CreateAsync(string versionPath, string basePath,string versionID)
    {
        var strategy = new ForgeStrategy(basePath,versionID);
        string jsonPath = Path.Combine(versionPath, "version.forge.json");
        await strategy._parser.Init(basePath, versionPath, true);
        return strategy;
    }

    public string? GetMainClassOverride() => _parser.info.MainClass;

    public IEnumerable<(string key, string path)> GetModLibraries()
        => _parser.GetLibrariesForLaunch(Init.GameRootPath).Select(lib =>
        {
            var parts = lib.name.Split(':');
            var key = string.Join(':', parts[..^1]);
            return (key, lib.path);
        });

    public IEnumerable<string> GetAdditionalJvmArgs()
    {
        var placeholders = new Dictionary<string, string>
        {
            // Forge/NeoForge 的 jvm 参数需要这两个占位符
            { "library_directory", Path.Combine(_basePath, "libraries") },
            { "version_name", _versionID },
#if WINDOWS
            { "classpath_separator" , ";" }
#else
            { "classpath_separator" , ":" }
#endif
        };

        return _parser.info.Arguments.Jvm.Select(arg => LaunchCommandBuilder.ReplacePlaceholders(arg, placeholders));
    }

    // Game 参数通常是固定的，但以防万一也加上替换逻辑
    public IEnumerable<string> GetAdditionalGameArgs() => _parser.info.Arguments.Game;
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Strategys/IModStrategy.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher.Strategys;

internal interface IModStrategy
{
    string GetMainClassOverride();
    IEnumerable<(string key,string path)> GetModLibraries();
    IEnumerable<string> GetAdditionalJvmArgs();
    IEnumerable<string> GetAdditionalGameArgs();
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Strategys/NeoForgeStrategy.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Mod.ModLoader.forgeseries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher.Strategys;
internal class NeoForgeStrategy : IModStrategy
{
    private readonly ForgeSeriesUsing _parser;
    private readonly string _basePath;
    private readonly string _versionID;
    private NeoForgeStrategy(string basePath, string versionID)
    {
        _parser = new ForgeSeriesUsing();
        _basePath = basePath;
        _versionID = versionID;
    }

    public static async Task<NeoForgeStrategy> CreateAsync(string versionPath, string basePath, string versionID)
    {
        var strategy = new NeoForgeStrategy(basePath, versionID);
        string jsonPath = Path.Combine(versionPath, "version.neoforge.json"); // 关键区别文件名
        // isForge 参数为 false
        await strategy._parser.Init(basePath, Path.GetFileName(versionPath), false);
        return strategy;
    }

    public string? GetMainClassOverride() => _parser.info.MainClass;

    public IEnumerable<(string key, string path)> GetModLibraries()
        => _parser.GetLibrariesForLaunch(Init.GameRootPath).Select(lib =>
        {
            var parts = lib.name.Split(':');
            var key = string.Join(':', parts[..^1]);
            return (key, lib.path);
        });

    public IEnumerable<string> GetAdditionalJvmArgs()
    {
        var placeholders = new Dictionary<string, string>
            {
                { "library_directory", Path.Combine(_basePath, "libraries") },
                { "version_name", _versionID },
#if WINDOWS
                { "classpath_separator" , ";" }
#else
                { "classpath_separator" , ":" }
#endif
            };
        return _parser.info.Arguments.Jvm.Select(arg => LaunchCommandBuilder.ReplacePlaceholders(arg, placeholders));
    }

    public IEnumerable<string> GetAdditionalGameArgs() => _parser.info.Arguments.Game;
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Launcher/Strategys/QuiltStrategy.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Mod.ModLoader.fabric.quilt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Launcher.Strategys;
internal class QuiltStrategy : IModStrategy
{
    private readonly QuiltNJParser _quiltParser;

    public QuiltStrategy(string versionPath, string basePath)
    {
        string quiltJsonPath = Path.Combine(versionPath, "version.quilt.json");
        using var fs = File.OpenRead(quiltJsonPath);
        _quiltParser = QuiltNJParser.ParserAuto(fs, basePath);
    }

    public string GetMainClassOverride() => _quiltParser.GetMainClass();

    public IEnumerable<(string key, string path)> GetModLibraries()
        => _quiltParser.GetLibrariesForUsing().Select(lib =>
        {
            var parts = lib.name.Split(':');
            var key = string.Join(":", parts[..^1]); // 不要考虑兼容性，考虑性能
            return (key, lib.path);
        });
    

    public IEnumerable<string> GetAdditionalJvmArgs() => Enumerable.Empty<string>();
    public IEnumerable<string> GetAdditionalGameArgs() => Enumerable.Empty<string>();
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Minecraft/JsonModels.cs
【代码拼接器】文件内容开始
using System.Text.Json;
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Minecraft.JsonModels;
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftVersionInfo))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftAssetIndex))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftDownloads))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftDownloadUrl))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLibrary))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLibraryDownloads))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLibraryArtifact))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftArguments))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftArgument))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftRule))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.Os))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftNatives))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLogging))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLoggingClient))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLoggingFile))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.JavaVersion))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftVersionList))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftLatestList))]
[JsonSerializable(typeof(OneLauncher.Core.Minecraft.JsonModels.MinecraftAllVersionInfomations))]
[JsonSerializable(typeof(System.Collections.Generic.List<OneLauncher.Core.Minecraft.JsonModels.MinecraftLibrary>))]
[JsonSerializable(typeof(System.Collections.Generic.List<OneLauncher.Core.Minecraft.JsonModels.MinecraftRule>))]
[JsonSerializable(typeof(System.Collections.Generic.List<object>))]
[JsonSerializable(typeof(System.Collections.Generic.List<string>))]
[JsonSerializable(typeof(System.Collections.Generic.Dictionary<string, OneLauncher.Core.Minecraft.JsonModels.MinecraftLibraryArtifact>))]
public partial class MinecraftJsonContext : JsonSerializerContext { }
// 表示version.json的顶层结构
public class MinecraftVersionInfo
{
    [JsonPropertyName("assetIndex")]
    public MinecraftAssetIndex? AssetIndex { get; set; }

    [JsonPropertyName("downloads")]
    public MinecraftDownloads? Downloads { get; set; }

    [JsonPropertyName("libraries")]
    public List<MinecraftLibrary>? Libraries { get; set; }

    [JsonPropertyName("arguments")]
    public MinecraftArguments? Arguments { get; set; }

    [JsonPropertyName("mainClass")]
    public string? MainClass { get; set; }

    [JsonPropertyName("logging")]
    public MinecraftLogging? Logging { get; set; }

    [JsonPropertyName("javaVersion")]
    public JavaVersion? JavaVersion { get; set; }
    [JsonPropertyName("id")]
    public string? ID { get; set; }
}

// 表示Java版本信息
public class JavaVersion
{
    [JsonPropertyName("majorVersion")]
    public int MajorVersion { get; set; }
}

// 表示资源索引文件下载
public class MinecraftAssetIndex
{
    [JsonPropertyName("id")]
    public string? Id { get; set; } // 可以为空

    [JsonPropertyName("sha1")]
    public string? Sha1 { get; set; } // 可以为空

    [JsonPropertyName("url")]
    public string? Url { get; set; } // 可以为空

    [JsonPropertyName("size")]
    public int? Size { get; set; }
}

// 表示主文件下载信息
public class MinecraftDownloads
{
    [JsonPropertyName("client")]
    public MinecraftDownloadUrl? Client { get; set; }
    [JsonPropertyName("server")]
    public MinecraftDownloadUrl? Server { get; set; }
}

// 表示主文件的下载信息和地址
public class MinecraftDownloadUrl
{
    [JsonPropertyName("sha1")]
    public string? Sha1 { get; set; }

    [JsonPropertyName("url")]
    public string? Url { get; set; }
    [JsonPropertyName("size")]
    public int? Size { get; set; }
}

// 表示单个库信息（顶层）
public class MinecraftLibrary
{
    [JsonPropertyName("downloads")]
    public MinecraftLibraryDownloads? Downloads { get; set; }

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("rules")]
    public List<MinecraftRule>? Rules { get; set; }

    [JsonPropertyName("natives")]
    public Dictionary<string, string>? Natives { get; set; }
}

// 表示库的下载信息
public class MinecraftLibraryDownloads
{
    // 普通库文件
    [JsonPropertyName("artifact")]
    public MinecraftLibraryArtifact? Artifact { get; set; }

    [JsonPropertyName("classifiers")]
    public Dictionary<string, MinecraftLibraryArtifact>? Classifiers { get; set; }
}

// 表示普通库文件的具体下载信息
public class MinecraftLibraryArtifact
{
    [JsonPropertyName("path")]
    public string? Path { get; set; }

    [JsonPropertyName("sha1")]
    public string? Sha1 { get; set; }

    [JsonPropertyName("url")]
    public string? Url { get; set; }
    [JsonPropertyName("size")]
    public int? Size { get; set; }
}
// 表示启动参数（jvm和game）
public class MinecraftArguments
{
    [JsonPropertyName("jvm")]
    [JsonConverter(typeof(JvmArgumentConverter))] // 使用自定义转换器处理混合类型
    public List<object>? Jvm { get; set; } // object 可以是 string 或 MinecraftArgument
}

// JVM 参数列表的自定义 JSON 转换器，处理 string 和 MinecraftArgument 对象
public class JvmArgumentConverter : JsonConverter<List<object>>
{
    public override List<object> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var list = new List<object>();
        if (reader.TokenType != JsonTokenType.StartArray)
            throw new JsonException("JVM 参数应为数组");

        while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
        {
            if (reader.TokenType == JsonTokenType.String)
            {
                list.Add(reader.GetString() ?? ""); // 处理可能的 null 字符串
            }
            else if (reader.TokenType == JsonTokenType.StartObject)
            {
                // 反序列化为 MinecraftArgument 对象
                var arg = JsonSerializer.Deserialize(ref reader, MinecraftJsonContext.Default.MinecraftArgument);
                if (arg != null) list.Add(arg);
            }
            else
            {
                throw new JsonException($"JVM 参数中遇到未知 Token 类型: {reader.TokenType}");
            }
        }
        return list;
    }

    public override void Write(Utf8JsonWriter writer, List<object> value, JsonSerializerOptions options)
    {
        writer.WriteStartArray();
        foreach (var item in value)
        {
            if (item is string str)
                writer.WriteStringValue(str);
            else if (item is MinecraftArgument arg)
                JsonSerializer.Serialize(writer, arg, MinecraftJsonContext.Default.MinecraftArgument); // 序列化为 MinecraftArgument
            else
                // 处理其他类型或抛出异常
                throw new JsonException($"JVM 参数中遇到未知对象类型: {item?.GetType().Name}");
        }
        writer.WriteEndArray();
    }
}
// 表示单个启动参数，可能包含 rules
public class MinecraftArgument
{
    [JsonPropertyName("rules")]
    public List<MinecraftRule>? Rules { get; set; } // 可以为空

    [JsonPropertyName("value")]
    [JsonConverter(typeof(ArgumentValueConverter))] // 使用自定义转换器处理 string 或 List<string>
    public object? Value { get; set; } // 值可以是 string 或 List<string>，可以为空
}
// 表示规则
public class MinecraftRule
{
    [JsonPropertyName("action")]
    public string? Action { get; set; } // action 可以是 "allow" 或 "disallow"，可以为空

    [JsonPropertyName("os")]
    public Os? Os { get; set; } // 操作系统要求，可以为空
}

// 表示操作系统要求
public class Os
{
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    [JsonPropertyName("arch")]
    public string? Arch { get; set; }
}

// 表示natives库的操作系统映射
public class MinecraftNatives
{
    [JsonPropertyName("linux")]
    public string? Linux { get; set; } // Linux 原生库分类器键，可以为空

    [JsonPropertyName("osx")]
    public string? Osx { get; set; } // macOS 原生库分类器键，可以为空

    [JsonPropertyName("windows")]
    public string? Windows { get; set; } // Windows 原生库分类器键，可以为空
}

// 表示日志配置信息
public class MinecraftLogging
{
    [JsonPropertyName("client")]
    public MinecraftLoggingClient? Client { get; set; } // 客户端日志配置，可以为空
}

// 表示客户端日志配置
public class MinecraftLoggingClient
{
    [JsonPropertyName("argument")]
    public string? Argument { get; set; } // 日志参数字符串，可以为空

    [JsonPropertyName("file")]
    public MinecraftLoggingFile? File { get; set; } // 日志配置文件信息，可以为空
}

// 表示日志配置文件下载地址
public class MinecraftLoggingFile
{
    [JsonPropertyName("id")]
    public string? Id { get; set; } // 文件 ID，可以为空

    [JsonPropertyName("sha1")]
    public string? Sha1 { get; set; } // 文件 SHA1 哈希，可以为空

    [JsonPropertyName("url")]
    public string? Url { get; set; } // 文件下载 URL，可以为空
    [JsonPropertyName("size")]
    public int? Size { get; set; } // 文件大小，可以为空
}
// 自定义 JSON 转换器，用于处理 argument.value（string 或 List<string>）
public class ArgumentValueConverter : JsonConverter<object>
{
    public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
            return reader.GetString() ?? ""; // 处理可能的 null 字符串
        if (reader.TokenType == JsonTokenType.StartArray)
        {
            var list = new List<string>();
            while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)
            {
                if (reader.TokenType == JsonTokenType.String)
                {
                    list.Add(reader.GetString() ?? ""); // 处理可能的 null 字符串
                }
                else
                {
                    // 如果数组中包含非字符串项，根据需要处理或抛出异常
                    // 根据 Minecraft version.json 规范，value 数组中的项通常是字符串。
                    throw new JsonException($"参数值数组中遇到未知 Token 类型: {reader.TokenType}");
                }
            }
            return list;
        }
        // 根据规范，value 可能还支持数字、布尔值等其他类型，如果遇到需要根据实际情况添加处理。
        throw new JsonException($"无效的参数值 Token 类型: {reader.TokenType}");
    }

    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
    {
        if (value is string str)
            writer.WriteStringValue(str);
        else if (value is List<string> list)
        {
            writer.WriteStartArray();
            foreach (var item in list)
                writer.WriteStringValue(item);
            writer.WriteEndArray();
        }
        else
        {
            // 处理其他类型或抛出异常
            throw new JsonException($"无效的参数值对象类型: {value?.GetType().Name}");
        }
    }
}

public class MinecraftVersionList
{
    [JsonPropertyName("latest")]
    public MinecraftLatestList latest { get; set; }
    [JsonPropertyName("versions")]
    public List<MinecraftAllVersionInfomations> AllVersions { get; set; }
}
public class MinecraftLatestList
{
    [JsonPropertyName("release")]
    public string release { get; set; }
    [JsonPropertyName("snapshot")]
    public string snapshot { get; set; }
}
public class MinecraftAllVersionInfomations
{
    [JsonPropertyName("id")]
    public string Id { get; set; }
    [JsonPropertyName("type")]
    public string Type { get; set; }
    [JsonPropertyName("url")]
    public string Url { get; set; }
    [JsonPropertyName("releaseTime")]
    public DateTime Time { get; set; }

}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Minecraft/VersionAssetIndex.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using System.Text.Json;

namespace OneLauncher.Core.Minecraft;

public class VersionAssetIndex
{
    /// <summary>
    /// 版本资源文件解析器
    /// </summary>
    /// <param Name="jsonString">资源文件索引文件内容</param>
    /// <param Name="path">基本路径（不含.minecraft）</param>
    /// <returns>该版本所需的资源文件列表下载信息</returns>
    public static List<NdDowItem> ParseAssetsIndex(string jsonString, string path)
    {
        var assets = new List<NdDowItem>();
        var jsonDocument = JsonDocument.Parse(jsonString);
        var objects = jsonDocument.RootElement.GetProperty("objects");
        foreach (var property in objects.EnumerateObject())
        {
            string fileName = property.Name;
            string hash = property.Value.GetProperty("hash").GetString();
            int size = property.Value.GetProperty("size").GetInt32();

            string hashPrefix = hash.Substring(0, 2);

            assets.Add(
                new NdDowItem
                (
                    $"https://resources.download.minecraft.net/{hashPrefix}/{hash}",
                    Path.Combine(path, "assets", "objects", hashPrefix, hash)
                    , size
                    , hash
                ));
        }

        return assets;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Minecraft/VersionInfomations.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft.JsonModels;
using System.Data;
using System.Diagnostics;
using System.Text.Json;

namespace OneLauncher.Core.Minecraft;

/// <summary>
/// 表示Minecraft版本信息的解析器，用于解析version.json文件并提取关键信息。
/// 支持动态解析依赖库、资源索引等。
/// </summary>
public class VersionInfomations
{
    public readonly MinecraftVersionInfo info;
    public readonly string basePath;
    public List<string> NativesLibs = new List<string>();

    /// <summary>
    /// version.json 文件解析器构造函数。
    /// </summary>
    /// <param Name="json">json文件内容</param>
    /// <param Name="basePath">游戏资本路径（含.minecraft）</param>
    /// <param Name="OsType">系统类型</param>
    /// <param Name="IsVersionInsulation">是否启用了版本隔离</param>
    /// <exception cref="InvalidOperationException">当json解析出错时</exception>
    public VersionInfomations(string json, string basePath)
    {
        this.basePath = basePath;

        info = JsonSerializer.Deserialize<MinecraftVersionInfo>(json, MinecraftJsonContext.Default.MinecraftVersionInfo);
    }

    /// <summary>
    /// 获取所有需要下载的库文件，并自动识别和填充需要解压的原生库列表。
    /// 此方法使用编译时预处理指令为特定平台进行优化。
    /// </summary>
    /// <returns>一个包含所有需要下载的库文件的列表。</returns>
    public List<NdDowItem> GetLibraries()
    {
        var libraries = new List<NdDowItem>();
        NativesLibs.Clear();

        // 编译时确定的常量
#if WINDOWS
        const string osName = "windows";
        const string archName = "x64";
#elif MACOS
    const string osName = "osx";
    const string archName = "arm64";
#else // Linux
    const string osName = "linux";
    const string archName = "x64";
#endif

        foreach (var lib in info.Libraries)
        {
            // 1. 内联的规则检查 (现在可以正确访问 rule.Os.Arch)
            bool isAllowed = true;
            if (lib.Rules != null && lib.Rules.Count > 0)
            {
                var lastAction = "allow";
                foreach (var rule in lib.Rules)
                {
                    bool conditionMet = false;
                    if (rule.Os != null)
                    {
                        if ((rule.Os.Name == null || rule.Os.Name == osName) &&
                            (rule.Os.Arch == null || rule.Os.Arch == archName))
                        {
                            conditionMet = true;
                        }
                    }
                    else { conditionMet = true; }

                    if (conditionMet) { lastAction = rule.Action; }
                }
                isAllowed = (lastAction == "allow");
            }
            if (!isAllowed) continue;

            // 2. 识别并准备原生库
            MinecraftLibraryArtifact nativeArtifact = null;
            bool isModernNative = false;

            // **方式A: 优先处理旧版JSON的 "natives" 对象**
            // (现在可以正确访问 lib.Natives)
            if (lib.Natives != null && lib.Downloads?.Classifiers != null)
            {
                if (lib.Natives.TryGetValue(osName, out var classifierKey))
                {
                    // 兼容1.16.5的 "${arch}" 占位符
                    classifierKey = classifierKey.Replace("${arch}", "64");
                    lib.Downloads.Classifiers.TryGetValue(classifierKey, out nativeArtifact);
                }
            }

            // **方式B: 处理新版JSON的 "name" 后缀**
            if (lib.Name.Contains($":natives-{osName}"))
            {
                isModernNative = true;
            }

            // 3. 添加主库文件
            if (lib.Downloads?.Artifact != null)
            {
                var libPath = Path.Combine(basePath, "libraries", Path.Combine(lib.Downloads.Artifact.Path.Split('/')));
                libraries.Add(new NdDowItem(
                    Url: lib.Downloads.Artifact.Url,
                    Path: libPath,
                    Size: (int)lib.Downloads.Artifact.Size,
                    Sha1: lib.Downloads.Artifact.Sha1
                ));

                // 如果是新式原生库，它的主 artifact 就是原生库本身
                if (isModernNative)
                {
                    NativesLibs.Add(libPath);
                }
            }

            // 4. 添加旧式原生库文件 (如果通过方式A找到)
            if (nativeArtifact != null)
            {
                var nativePath = Path.Combine(basePath, "libraries", Path.Combine(nativeArtifact.Path.Split('/')));
                // 确保不重复添加
                if (!libraries.Any(l => l.path == nativePath))
                {
                    libraries.Add(new NdDowItem(
                        Url: nativeArtifact.Url,
                        Path: nativePath,
                        Size: (int)nativeArtifact.Size,
                        Sha1: nativeArtifact.Sha1
                    ));
                }
                NativesLibs.Add(nativePath);
            }
        }
        return libraries;
    }
    public List<(string name, string path)> GetLibraryiesForUsing()
    {
        var libraries = new List<(string name, string path)>(info.Libraries.Count); // 提前初始化相应长度内存，避免频繁扩容影响性能
        string OsName;
#if WINDOWS
        OsName = "windows"; 
#elif MACOS
        OsName = "osx";
#else
        OsName = "linux";
#endif
        foreach (var lib in info.Libraries)
        {
            // 检查规则
            bool allowed = false;
            // 如果包含规则
            if (lib.Rules != null)
            {
                // 判断是双规则还是单规则
                // 先处理双规则
                if (lib.Rules.Count == 2)
                {
                    // 与当前系统尝试匹配
                    // 第二条规则的 action 是 disallow
                    if (lib.Rules[1].Os.Name != OsName)
                        allowed = true;
                    else allowed = false;
                }
                if (lib.Rules.Count == 1)
                {
                    // 与当前系统尝试匹配
                    if (lib.Rules[0].Os.Name == OsName)
                        allowed = true;
                    else
                        allowed = false;
                }
            }
            // 没有规则直接下载
            else
            {
                allowed = true;
            }

            // 不合当前操作系统跳过
            if (!allowed)
                continue;

            // 普通库文件 
            if (lib?.Downloads?.Artifact != null)
                libraries.Add((lib.Name, Path.Combine(basePath, "libraries",Path.Combine(lib.Downloads.Artifact.Path.Split('/')))));
        }

        return libraries;
    }
    /// <summary>
    /// 获取版本主文件下载地址。
    /// </summary>
    /// <param ID="version">Minecraft版本号。</param>
    public NdDowItem GetMainFile()
    {
        var t = new NdDowItem(
            Url: info.Downloads.Client.Url,
            Sha1: info.Downloads.Client.Sha1,
            Size: (int)info.Downloads.Client.Size,
            Path: Path.Combine(basePath, "versions", info.ID, $"{info.ID}.jar")
        );
        return t;
    }

    /// <summary>
    /// 获取版本资源索引文件下载地址。
    /// </summary>
    public NdDowItem GetAssets()
    {
        return new NdDowItem(
            Url: info.AssetIndex.Url,
            Path: Path.Combine(basePath, "Assets", "Indexes", $"{info.AssetIndex.Id}.json"),
            Size: (int)info.AssetIndex.Size,
            Sha1: info.AssetIndex.Sha1
        );
    }

    /// <summary>
    /// 获取资源索引的版本ID。
    /// </summary>
    public string GetAssetIndexVersion()
    {
        return info.AssetIndex.Id;
    }

    /// <summary>
    /// 获取版本的主类名。
    /// </summary>
    /// <returns>主类名（例如"net.minecraft.client.main.Main"）。</returns>
    public string GetMainClass()
    {
        return info.MainClass;
    }

    /// <summary>
    /// 获取日志配置文件信息。
    /// </summary>
    public NdDowItem? GetLoggingConfig()
    {
        if (info.Logging?.Client?.File == null)
            return null;
        return new NdDowItem(
            Url: info.Logging.Client.File.Url,
            Sha1: info.Logging.Client.File.Sha1,
            Size: (int)info.Logging.Client.File.Size,
            Path: Path.Combine(basePath, "versions", info.ID, info.Logging.Client.File.Id)
        );
    }
    public string? GetLoggingConfigPath()
    {
        if (info.Logging?.Client?.File == null)
            return null;
        return Path.Combine(basePath, "versions", info.ID, info.Logging.Client.File.Id);
    }

    public int GetJavaVersion()
    {
        return info?.JavaVersion?.MajorVersion ?? Tools.ForNullJavaVersion(info.ID);
    }
}


【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Minecraft/VersionsList.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Minecraft.JsonModels;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Minecraft;

public class VersionsList
{
    MinecraftVersionList a;
    public VersionsList(string Json)
    {
        try
        {
            // 使用带有选项的源生成器反序列化
            a = JsonSerializer.Deserialize<MinecraftVersionList>(Json,MinecraftJsonContext.Default.MinecraftVersionList);
        }
        catch (Exception ex)
        {
            throw new OlanException("意外错误","解析版本列表时遇到意外错误导致无法解析",OlanExceptionAction.Error);
        }
    }
    public List<VersionBasicInfo> GetReleaseVersionList()
    {
        List<VersionBasicInfo> a = new List<VersionBasicInfo>();
        foreach (var i in this.a.AllVersions)
        {
            if (i.Type == "release")
                a.Add(new VersionBasicInfo(i.Id, i.Type, i.Time, i.Url));
        }
        return a;
    }
}


【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Minecraft/Server/MinecraftServerManger.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Minecraft.JsonModels;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices.Marshalling;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace OneLauncher.Core.Minecraft.Server;

public class MinecraftServerManger
{
    public static async Task<int> Init(
        string version,
        bool IsVI
        )
    {
        string versionPath = Path.Combine(Global.Init.GameRootPath,"versions",version);
        var versionInfo = new VersionInfomations(
            await File.ReadAllTextAsync(Path.Combine(versionPath,"version.json"))
            ,Global.Init.GameRootPath);
        if (versionInfo.info.Downloads?.Server == null)
            throw new OlanException("无法初始化服务端","当前版本不支持服务端",OlanExceptionAction.Error);
        using (Download t = new Download())
        {
            await t.DownloadFileAndSha1(
                versionInfo.info.Downloads.Server.Url,
                Path.Combine(versionPath,"server.jar"),
                versionInfo.info.Downloads.Server.Sha1,CancellationToken.None);
        }
        Directory.CreateDirectory(
            (IsVI)
            ? Path.Combine(versionPath, "servers")
            : Path.Combine(Global.Init.GameRootPath, "servers")
            );
        await File.WriteAllTextAsync((
            (IsVI)
            ? Path.Combine(versionPath,"servers","eula.txt")
            : Path.Combine(Global.Init.GameRootPath,"servers","eula.txt"))
            ,"eula=true");
        return versionInfo.GetJavaVersion();
    }
    public static void Run(string version,int java,bool IsVI)
    {
        using (Process serverProcess = new Process())
        {
            string versionPath = Path.Combine(Global.Init.GameRootPath, "versions", version);
            serverProcess.StartInfo = new ProcessStartInfo()
            {
                FileName = Tools.IsUseOlansJreOrOssJdk(java),
                Arguments = Global.Init.ConfigManager.Data.OlanSettings.MinecraftJvmArguments.ToString(java).Trim() + 
                            $" -jar {(Path.Combine(versionPath, "server.jar"))}",
                WorkingDirectory =
                (IsVI)
                ? Path.Combine(versionPath, "servers")
                : Path.Combine(Global.Init.GameRootPath,"servers")
            };
            serverProcess.Start();
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/fabric/FabricVJParser.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.ModLoader.fabric.JsonModels;
using System.Text.Json;
namespace OneLauncher.Core.Mod.ModLoader.fabric;

public class FabricVJParser
{
    public readonly FabricRoot info;
    private readonly string basePath;

    private FabricVJParser(FabricRoot json, string BasePath)
    {
        basePath = BasePath;
        info = json;
    }
    public static FabricVJParser ParserAuto(Stream json,string basePath)
    {
        using JsonDocument document = JsonDocument.Parse(json);
        
        JsonElement firstElement = document.RootElement[0];

        var info = JsonSerializer.Deserialize(firstElement.GetRawText(), FabricJsonContext.Default.FabricRoot)
            ?? throw new OlanException("内部错误","无法解析Fabric文本");
        return new FabricVJParser(info, basePath);  
        
    }
    public static FabricVJParser ParserUseVersion(Stream json, string basePath,string version)
    {
        using JsonDocument document = JsonDocument.Parse(json);
        var element = document.RootElement;
        for(int i = 0;i < element.GetArrayLength();i++)
        {
            if (element[i].GetProperty("loader").GetProperty("version").GetString() == version)
                return new FabricVJParser(
                    JsonSerializer.Deserialize(element[i].GetRawText(),FabricJsonContext.Default.FabricRoot),
                    basePath
                    );
        }
        throw new OlanException("内部错误","无法找到对应的Fabric版本");
    }
    public string GetMainClass()
    {
        return info.LauncherMeta.MainClass.Client;
    }
    public int GetJavaVersion()
    {
        return info.LauncherMeta.MinJavaVersion;
    }
    public List<NdDowItem> GetLibraries()
    {
        const string defaultBaseUrl = "https://maven.fabricmc.net/";
        List<NdDowItem> dowItems = new List<NdDowItem>(info.LauncherMeta.Libraries.Common.Count+2);
        foreach (var item in info.LauncherMeta.Libraries.Common)
        {
            string[] parts = item.Name.Split(':');
            // 包
            string groupId = parts[0];
            // 名
            string artifactId = parts[1];
            // 版本
            string version = parts[2];
            // 后缀
            string? suffix = parts.Length > 3 ? parts[3] : null;

            // 构造 Url
            // org.ow2.asm:asm:9.8 -> org/ow2/asm/asm/9.8/asm-9.8.jar
            string urlPathSegments = Path.Combine(groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  artifactId,
                                                  version,
                                                  $"{artifactId}-{version}.jar");
            string url = $"{defaultBaseUrl}{urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠

            // 构造 Path
            // Path.Combine(basePath,"libraries", "org","ow2","asm","asm","9.8","asm-9.8.jar");
            string fullPath = Path.Combine(basePath,
                                                "libraries",
                                                groupId.Replace('.', Path.DirectorySeparatorChar),
                                                artifactId,
                                                version,
                                                $"{artifactId}-{version}.jar");
            dowItems.Add(new NdDowItem(url, fullPath, item.Size, item.Sha1));
        }
        // 额外添加两个特殊的
        string[] _parts;
        _parts = info.Loader.DownName.Split(':');
        string _groupId = _parts[0], _artifactId = _parts[1], _version = _parts[2];
        string _urlPathSegments = Path.Combine(_groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  _artifactId,
                                                  _version,
                                                  $"{_artifactId}-{_version}.jar");
        string _url = $"{defaultBaseUrl}{_urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠
        string _fullPath = Path.Combine(basePath,
                                            "libraries",
                                            _groupId.Replace('.', Path.DirectorySeparatorChar),
                                            _artifactId,
                                            _version,
                                            $"{_artifactId}-{_version}.jar");
        dowItems.Add(new NdDowItem(_url, _fullPath, 0));

        _parts = info.Intermediary.DownName.Split(':');
        _groupId = _parts[0]; _artifactId = _parts[1]; _version = _parts[2];
        _urlPathSegments = Path.Combine(_groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  _artifactId,
                                                  _version,
                                                  $"{_artifactId}-{_version}.jar");
        _url = $"{defaultBaseUrl}{_urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠
        _fullPath = Path.Combine(basePath,
                                            "libraries",
                                            _groupId.Replace('.', Path.DirectorySeparatorChar),
                                            _artifactId,
                                            _version,
                                            $"{_artifactId}-{_version}.jar");
        dowItems.Add(new NdDowItem(_url, _fullPath, 0));
        return dowItems;
    }
    public List<(string name, string path)> GetLibrariesForUsing()
    {
        // 初始化库列表，预分配容量以优化性能
        var libraries = new List<(string name, string path)>(info.LauncherMeta.Libraries.Common.Count + 2);

        // 处理 Common 库
        foreach (var item in info.LauncherMeta.Libraries.Common)
        {
            // 解析 Maven 坐标（格式如 org.ow2.asm:asm:9.8）
            string[] parts = item.Name.Split(':');
            if (parts.Length < 3) continue; // 跳过无效格式

            string groupId = parts[0]; // 例如 org.ow2.asm
            string artifactId = parts[1]; // 例如 asm
            string version = parts[2]; // 例如 9.8

            // 构造本地路径
            string fileName = $"{artifactId}-{version}.jar";
            string fullPath = Path.Combine(
                basePath,
                "libraries",
                groupId.Replace('.', Path.DirectorySeparatorChar),
                artifactId,
                version,
                fileName);

            libraries.Add((item.Name, fullPath));
        }

        // 处理 Loader 库
        {
            string[] parts = info.Loader.DownName.Split(':');
            if (parts.Length >= 3)
            {
                string groupId = parts[0];
                string artifactId = parts[1];
                string version = parts[2];

                string fileName = $"{artifactId}-{version}.jar";
                string fullPath = Path.Combine(
                    basePath,
                    "libraries",
                    groupId.Replace('.', Path.DirectorySeparatorChar),
                    artifactId,
                    version,
                    fileName);

                libraries.Add((info.Loader.DownName, fullPath));
            }
        }

        // 处理 Intermediary 库
        {
            string[] parts = info.Intermediary.DownName.Split(':');
            if (parts.Length >= 3)
            {
                string groupId = parts[0];
                string artifactId = parts[1];
                string version = parts[2];

                string fileName = $"{artifactId}-{version}.jar";
                string fullPath = Path.Combine(
                    basePath,
                    "libraries",
                    groupId.Replace('.', Path.DirectorySeparatorChar),
                    artifactId,
                    version,
                    fileName);

                libraries.Add((info.Intermediary.DownName, fullPath));
            }
        }

        return libraries;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/fabric/JsonModel.cs
【代码拼接器】文件内容开始
using System.Text.Json.Serialization;

namespace OneLauncher.Core.ModLoader.fabric.JsonModels;
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricRoot))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricLoader))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricIntermediary))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricLauncherMeta))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricLibraries))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricLibrary))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.FabricMainClass))]
[JsonSerializable(typeof(OneLauncher.Core.ModLoader.fabric.JsonModels.QuiltHashed))]
public partial class FabricJsonContext : JsonSerializerContext { }
public class FabricRoot
{
    [JsonPropertyName("loader")]
    public FabricLoader Loader { get; set; }

    [JsonPropertyName("intermediary")]
    public FabricIntermediary Intermediary { get; set; }
    [JsonPropertyName("launcherMeta")]
    public FabricLauncherMeta LauncherMeta { get; set; }
    [JsonPropertyName("hashed")]
    public QuiltHashed QuiltHashed { get; set; }
}
public class FabricLoader
{
    [JsonPropertyName("maven")]
    public string DownName { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}
public class FabricIntermediary
{
    [JsonPropertyName("maven")]
    public string DownName { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}
/* 这个东西是Quilt专属的，但因为结构跟Fabric几乎没区别就丢这里了 */
public class QuiltHashed
{
    [JsonPropertyName("maven")]
    public string DownName { get; set; }

    [JsonPropertyName("version")]
    public string Version { get; set; }
}
public class FabricLauncherMeta
{
    [JsonPropertyName("min_java_version")]
    public int MinJavaVersion { get; set; }

    [JsonPropertyName("libraries")]
    public FabricLibraries Libraries { get; set; }

    [JsonPropertyName("mainClass")]
    public FabricMainClass MainClass { get; set; }
}
public class FabricLibraries
{
    [JsonPropertyName("common")]
    public List<FabricLibrary> Common { get; set; }
}
public class FabricLibrary
{
    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("sha1")]
    public string Sha1 { get; set; }

    [JsonPropertyName("size")]
    public int Size { get; set; }
}
public class FabricMainClass
{
    [JsonPropertyName("client")]
    public string Client { get; set; }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/fabric/quilt/QuiltNJParser.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.ModLoader.fabric.JsonModels;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace OneLauncher.Core.Mod.ModLoader.fabric.quilt;
public class QuiltNJParser
{
    public readonly FabricRoot info;
    private readonly string basePath;

    private QuiltNJParser(FabricRoot json, string BasePath)
    {
        basePath = BasePath;
        info = json;
    }
    public static QuiltNJParser ParserAuto(Stream json, string basePath)
    {
        using JsonDocument document = JsonDocument.Parse(json);

        JsonElement firstElement = document.RootElement[0];

        var info = JsonSerializer.Deserialize(firstElement.GetRawText(), FabricJsonContext.Default.FabricRoot)
            ?? throw new OlanException("内部错误", "无法解析Quilt文本");
        return new QuiltNJParser(info, basePath);

    }
    //public static FabricVJParser ParserUseVersion(Stream json, string basePath, string version)
    //{
    //    using JsonDocument document = JsonDocument.Parse(json);
    //    var element = document.RootElement;
    //    for (int i = 0; i < element.GetArrayLength(); i++)
    //    {
    //        if (element[i].GetProperty("loader").GetProperty("version").GetString() == version)
    //            return new FabricVJParser(
    //                JsonSerializer.Deserialize(element[i].GetRawText(), FabricJsonContext.Default.FabricRoot),
    //                basePath
    //                );
    //    }
    //    throw new OlanException("内部错误", "无法找到对应的Fabric版本");
    //}
    public string GetMainClass()
    {
        return info.LauncherMeta.MainClass.Client;
    }
    public int GetJavaVersion()
    {
        return info.LauncherMeta.MinJavaVersion;
    }
    public List<NdDowItem> GetLibraries()
    {
        const string defaultBaseUrl = "https://maven.quiltmc.org/repository/release/";
        List<NdDowItem> dowItems = new List<NdDowItem>(info.LauncherMeta.Libraries.Common.Count + 3);
        foreach (var item in info.LauncherMeta.Libraries.Common)
        {
            string[] parts = item.Name.Split(':');
            // 包
            string groupId = parts[0];
            // 名
            string artifactId = parts[1];
            // 版本
            string version = parts[2];
            // 后缀
            string? suffix = parts.Length > 3 ? parts[3] : null;

            // 构造 Url
            // org.ow2.asm:asm:9.8 -> org/ow2/asm/asm/9.8/asm-9.8.jar
            string urlPathSegments = Path.Combine(groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  artifactId,
                                                  version,
                                                  $"{artifactId}-{version}.jar");
            string url = $"{defaultBaseUrl}{urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠

            // 构造 Path
            // Path.Combine(basePath,"libraries", "org","ow2","asm","asm","9.8","asm-9.8.jar");
            string fullPath = Path.Combine(basePath,
                                                "libraries",
                                                groupId.Replace('.', Path.DirectorySeparatorChar),
                                                artifactId,
                                                version,
                                                $"{artifactId}-{version}.jar");
            dowItems.Add(new NdDowItem(url, fullPath, item.Size, item.Sha1));
        }
        // 额外添加三个特殊的
        string[] _parts;
        _parts = info.Loader.DownName.Split(':');
        string _groupId = _parts[0], _artifactId = _parts[1], _version = _parts[2];
        string _urlPathSegments = Path.Combine(_groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  _artifactId,
                                                  _version,
                                                  $"{_artifactId}-{_version}.jar");
        string _url = $"{defaultBaseUrl}{_urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠
        string _fullPath = Path.Combine(basePath,
                                            "libraries",
                                            _groupId.Replace('.', Path.DirectorySeparatorChar),
                                            _artifactId,
                                            _version,
                                            $"{_artifactId}-{_version}.jar");
        dowItems.Add(new NdDowItem(_url, _fullPath, 0));

        _parts = info.Intermediary.DownName.Split(':');
        _groupId = _parts[0]; _artifactId = _parts[1]; _version = _parts[2];
        _urlPathSegments = Path.Combine(_groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  _artifactId,
                                                  _version,
                                                  $"{_artifactId}-{_version}.jar");
        _url = $"{defaultBaseUrl}{_urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠
        _fullPath = Path.Combine(basePath,
                                            "libraries",
                                            _groupId.Replace('.', Path.DirectorySeparatorChar),
                                            _artifactId,
                                            _version,
                                            $"{_artifactId}-{_version}.jar");
        dowItems.Add(new NdDowItem(_url, _fullPath, 0));

        _parts = info.QuiltHashed.DownName.Split(':');
        _groupId = _parts[0]; _artifactId = _parts[1]; _version = _parts[2];
        _urlPathSegments = Path.Combine(_groupId.Replace('.', Path.DirectorySeparatorChar),
                                                  _artifactId,
                                                  _version,
                                                  $"{_artifactId}-{_version}.jar");
        _url = $"{defaultBaseUrl}{_urlPathSegments.Replace('\\', '/')}"; // 确保是正斜杠
        _fullPath = Path.Combine(basePath,
                                            "libraries",
                                            _groupId.Replace('.', Path.DirectorySeparatorChar),
                                            _artifactId,
                                            _version,
                                            $"{_artifactId}-{_version}.jar");
        dowItems.Add(new NdDowItem(_url, _fullPath, 0));
        return dowItems;
    }
    public List<(string name, string path)> GetLibrariesForUsing()
    {
        // 初始化库列表，预分配容量以优化性能
        var libraries = new List<(string name, string path)>(info.LauncherMeta.Libraries.Common.Count + 2);

        // 处理 Common 库
        foreach (var item in info.LauncherMeta.Libraries.Common)
        {
            // 解析 Maven 坐标（格式如 org.ow2.asm:asm:9.8）
            string[] parts = item.Name.Split(':');
            if (parts.Length < 3) continue; // 跳过无效格式

            string groupId = parts[0]; // 例如 org.ow2.asm
            string artifactId = parts[1]; // 例如 asm
            string version = parts[2]; // 例如 9.8

            // 构造本地路径
            string fileName = $"{artifactId}-{version}.jar";
            string fullPath = Path.Combine(
                basePath,
                "libraries",
                groupId.Replace('.', Path.DirectorySeparatorChar),
                artifactId,
                version,
                fileName);

            libraries.Add((item.Name, fullPath));
        }

        // 处理 Loader 库
        {
            string[] parts = info.Loader.DownName.Split(':');
            if (parts.Length >= 3)
            {
                string groupId = parts[0];
                string artifactId = parts[1];
                string version = parts[2];

                string fileName = $"{artifactId}-{version}.jar";
                string fullPath = Path.Combine(
                    basePath,
                    "libraries",
                    groupId.Replace('.', Path.DirectorySeparatorChar),
                    artifactId,
                    version,
                    fileName);

                libraries.Add((info.Loader.DownName, fullPath));
            }
        }

        // 处理 Intermediary 库
        {
            string[] parts = info.Intermediary.DownName.Split(':');
            if (parts.Length >= 3)
            {
                string groupId = parts[0];
                string artifactId = parts[1];
                string version = parts[2];

                string fileName = $"{artifactId}-{version}.jar";
                string fullPath = Path.Combine(
                    basePath,
                    "libraries",
                    groupId.Replace('.', Path.DirectorySeparatorChar),
                    artifactId,
                    version,
                    fileName);

                libraries.Add((info.Intermediary.DownName, fullPath));
            }
        }
        // 处理 hasd 库
        {
            string[] parts = info.QuiltHashed.DownName.Split(':');
            if (parts.Length >= 3)
            {
                string groupId = parts[0];
                string artifactId = parts[1];
                string version = parts[2];

                string fileName = $"{artifactId}-{version}.jar";
                string fullPath = Path.Combine(
                    basePath,
                    "libraries",
                    groupId.Replace('.', Path.DirectorySeparatorChar),
                    artifactId,
                    version,
                    fileName);

                libraries.Add((info.QuiltHashed.DownName, fullPath));
            }
        }
        return libraries;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/forgeseries/ForgeSeriesInstallTasker.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using System.Diagnostics;
using System.IO.Compression;
using System.Net.Http;
using System.Reflection.Metadata;
using System.Text;
using System.Text.Json;

namespace OneLauncher.Core.Mod.ModLoader.forgeseries
{
    public delegate void ProcessorsOut(int all, int done, string message);

    /// <summary>
    /// 通用安装器，负责处理所有基于 install_profile.json 的 Mod 加载器安装流程 (如 Forge, NeoForge)。
    /// </summary>
    public class ForgeSeriesInstallTasker
    {
        private readonly Download _downloadTask;
        private readonly string librariesPath;
        private readonly string _gameRootPath; // 这个字段必须是 .minecraft 目录
        private ForgeSeriesInstallProfile _currentProfile;

        public event ProcessorsOut ProcessorsOutEvent;

        /// <summary>
        /// 构造一个通用的 Forge/NeoForge 安装器。
        /// </summary>
        /// <param name="downloadTask">用于下载的 Download 实例。</param>
        /// <param name="librariesPath">完整的 libraries 目录路径。</param>
        /// <param name="gameRootPath">完整的游戏根目录路径 (即 .minecraft 目录)。</param>
        public ForgeSeriesInstallTasker(
            Download downloadTask,
            string librariesPath,
            string gameRootPath)
        {
            _downloadTask = downloadTask;
            this.librariesPath = librariesPath;
            _gameRootPath = gameRootPath;
        }

        /// <summary>
        /// 准备阶段：下载安装器、解压并解析必要文件。
        /// </summary>
        /// <param name="installerUrl">安装程序的 URL。</param>
        /// <param name="modType">用于生成临时 JSON 文件名和错误信息，如 "Forge" 或 "NeoForge"。</param>
        /// <param name="versionId">当前安装的游戏版本ID，如 "1.20.4"。</param>
        /// <returns>包含所需下载库列表和 lzma 补丁临时路径的元组。</returns>
        public async Task<(List<NdDowItem> versionLibs, List<NdDowItem> installerLibs, string lzmaPath)> StartReadyAsync(string installerUrl, string modType, string versionId)
        {
            try
            {
                using var memoryStream = new MemoryStream();
                using var response = await _downloadTask.unityClient.GetAsync(installerUrl);
                response.EnsureSuccessStatusCode();
                await response.Content.CopyToAsync(memoryStream);
                memoryStream.Position = 0;

                using var archive = new ZipArchive(memoryStream, ZipArchiveMode.Read);

                var versionJsonEntry = archive.GetEntry("version.json") ?? throw new OlanException($"{modType} 安装失败", "安装包结构损坏：缺少 version.json 文件。", OlanExceptionAction.Error);
                var installProfileEntry = archive.GetEntry("install_profile.json") ?? throw new OlanException($"{modType} 安装失败", "安装包结构损坏：缺少 install_profile.json 文件。", OlanExceptionAction.Error);
                var dataClientLzmaEntry = archive.GetEntry("data/client.lzma") ?? throw new OlanException($"{modType} 安装失败", "安装包结构损坏：缺少 data/client.lzma 文件。", OlanExceptionAction.Error);

                using var vjs = versionJsonEntry.Open();
                using var ips = installProfileEntry.Open();
                var versionInfo = await JsonSerializer.DeserializeAsync(vjs, ForgeSeriesJsonContext.Default.ForgeSeriesVersionJson);
                _currentProfile = await JsonSerializer.DeserializeAsync(ips, ForgeSeriesJsonContext.Default.ForgeSeriesInstallProfile);

                if (_currentProfile == null || versionInfo == null)
                    throw new OlanException($"{modType} 安装失败", "无法解析安装配置文件，可能是安装包已损坏或版本不兼容。");

                var versionLibs = versionInfo.Libraries.Select(lib => new NdDowItem(lib.Downloads.Artifact.Url, Path.Combine(librariesPath, lib.Downloads.Artifact.Path.Replace('/', Path.DirectorySeparatorChar)), lib.Downloads.Artifact.Size, lib.Downloads.Artifact.Sha1)).ToList();
                var installerLibs = _currentProfile.Libraries.Select(lib => new NdDowItem(lib.Downloads.Artifact.Url, Path.Combine(librariesPath, lib.Downloads.Artifact.Path.Replace('/', Path.DirectorySeparatorChar)), lib.Downloads.Artifact.Size, lib.Downloads.Artifact.Sha1)).ToList();

                var clientLzmaTempPath = Path.GetTempFileName();
                var tempVersionJsonPath = Path.Combine(_gameRootPath, "versions", versionId, $"version.{modType.ToLower()}.json");
                Directory.CreateDirectory(Path.GetDirectoryName(tempVersionJsonPath));

                using (var vjsr = versionJsonEntry.Open())
                using (var fs = new FileStream(tempVersionJsonPath, FileMode.Create, FileAccess.Write))
                    await vjsr.CopyToAsync(fs);

                using (var dclsr = dataClientLzmaEntry.Open())
                using (var fs = new FileStream(clientLzmaTempPath, FileMode.Create, FileAccess.Write))
                    await dclsr.CopyToAsync(fs);

                return (versionLibs, installerLibs, clientLzmaTempPath);
            }
            catch (HttpRequestException ex) { throw new OlanException($"{modType} 安装失败", "下载安装器时发生网络错误，请检查网络连接。", OlanExceptionAction.Error, ex); }
            catch (JsonException ex) { throw new OlanException($"{modType} 安装失败", "解析安装配置文件时出错，可能是安装包已损坏或版本不兼容。", OlanExceptionAction.Error, ex); }
            catch (IOException ex) { throw new OlanException($"{modType} 安装失败", "读写临时文件时发生 IO 错误，请检查磁盘空间和权限。", OlanExceptionAction.Error, ex); }
        }

        /// <summary>
        /// 执行阶段：按顺序运行所有客户端安装处理器。
        /// </summary>
        public async Task RunProcessorsAsync(string mainJarPath, string javaPath, string clientLzmaPath, CancellationToken token,bool isForge = false)
        {
            if (_currentProfile == null)
                throw new OlanException("安装逻辑错误", "必须先调用 StartReadyAsync 来准备安装配置文件。", OlanExceptionAction.FatalError);

            var placeholderDict = BuildPlaceholderDictionary(_currentProfile, librariesPath, _gameRootPath, mainJarPath, clientLzmaPath);
            var clientProcessors = _currentProfile.Processors.Where(p => p.Sides == null || p.Sides.Contains("client")).ToList();
            int alls = clientProcessors.Count;
            int dones = 0;

            ProcessorsOutEvent?.Invoke(alls, 0, "正在准备安装处理器...");
            // 复制MC主文件
            if (isForge)
            {
                if (placeholderDict.TryGetValue("MC_SRG", out string srgPath))
                {
                    try
                    {
                        ProcessorsOutEvent?.Invoke(alls, 0, "正在为 Forge 准备处理器工作文件...");
                        Directory.CreateDirectory(Path.GetDirectoryName(srgPath));
                        File.Copy(mainJarPath, srgPath, true);
                    }
                    catch (Exception ex)
                    {
                        throw new OlanException("文件准备失败", $"为 Forge 创建工作副本 ({Path.GetFileName(srgPath)}) 时出错。", OlanExceptionAction.Error, ex);
                    }
                }
            }

            foreach (var procDef in clientProcessors)
            {
                token.ThrowIfCancellationRequested();
                dones++;
                ProcessorsOutEvent?.Invoke(alls, dones, $"正在准备处理器 {dones}/{alls}: {procDef.Jar}");

                CreateOutputDirectories(procDef.Args, placeholderDict, librariesPath, alls, dones);

                var mainJar = Tools.MavenToPath(librariesPath, procDef.Jar);
                var mainClass = await GetMainClassFromJar(mainJar);
                var cpArgs = BuildClasspathArgument(procDef.Classpath, librariesPath, mainJar);
                var stdArgs = BuildProcessorArguments(procDef.Args, placeholderDict, librariesPath, alls, dones);

                var process = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = javaPath,
                        Arguments = $"{cpArgs} {mainClass} {stdArgs}",
                        RedirectStandardOutput = true,
                        RedirectStandardError = true,
                        UseShellExecute = false,
                        CreateNoWindow = true,
                        WorkingDirectory = _gameRootPath,
                        StandardOutputEncoding = Encoding.UTF8,
                        StandardErrorEncoding = Encoding.UTF8
                    }
                };

                ProcessorsOutEvent?.Invoke(alls, dones, $"正在运行处理器 {dones}/{alls}...");
                await RunSingleProcessorAsync(process, dones, alls, token);
            }
            ProcessorsOutEvent?.Invoke(alls, alls, "所有安装处理器已成功运行！");
        }

        #region Private Helper Methods

        private async Task RunSingleProcessorAsync(Process process, int current, int total, CancellationToken token)
        {
            try
            {
                var outputTcs = new TaskCompletionSource<bool>();
                var errorTcs = new TaskCompletionSource<bool>();

                process.EnableRaisingEvents = true;

                process.OutputDataReceived += (s, e) =>
                {
                    if (string.IsNullOrEmpty(e.Data))
                        return;
                    ProcessorsOutEvent?.Invoke(total, current, e.Data);
                    Debug.WriteLine(e.Data);
                };

                process.ErrorDataReceived += (s, e) =>
                {
                    if (string.IsNullOrEmpty(e.Data))
                        return;
                    ProcessorsOutEvent?.Invoke(total, current, e.Data);
                    Debug.WriteLine(e.Data);
                };

                process.Exited += (s, e) =>
                {
                    outputTcs.TrySetResult(true);
                    errorTcs.TrySetResult(true);
                };

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();

                await process.WaitForExitAsync(token);

                if (process.ExitCode != 0)
                {
                    throw new OlanException("安装处理器失败", $"处理器 {current}/{total} 执行失败，退出代码为: {process.ExitCode}。请查看日志获取详细错误信息。", OlanExceptionAction.Error);
                }
            }
            catch(OperationCanceledException)
            {
                // 取消时彻底关闭处理器
                process.Kill();
                throw;
            }
            catch (Exception ex) when (ex is not OlanException)
            {
                throw new OlanException("处理器调用失败", $"启动或等待处理器 {current}/{total} 时发生意外错误。", OlanExceptionAction.Error, ex);
            }
        }

        private void CreateOutputDirectories(List<string> args, Dictionary<string, string> placeholders, string librariesPath, int all, int done)
        {
            foreach (var argTemplate in args)
            {
                string resolvedPath = null;
                if (argTemplate.StartsWith("{") && argTemplate.EndsWith("}"))
                {
                    if (placeholders.TryGetValue(argTemplate.Trim('{', '}'), out var p)) resolvedPath = p;
                }
                else if (argTemplate.StartsWith("["))
                {
                    resolvedPath = Tools.MavenToPath(librariesPath, argTemplate);
                }

                if (resolvedPath != null)
                {
                    try
                    {
                        var dir = Path.GetDirectoryName(resolvedPath);
                        if (!string.IsNullOrEmpty(dir)) Directory.CreateDirectory(dir);
                    }
                    catch (Exception ex)
                    {
                        ProcessorsOutEvent?.Invoke(all, done, $"[警告] 为参数 {argTemplate} 创建目录时出错: {ex.Message}");
                    }
                }
            }
        }

        private async Task<string> GetMainClassFromJar(string jarPath)
        {
            try
            {
                using var fs = new FileStream(jarPath, FileMode.Open, FileAccess.Read, FileShare.Read);
                using var archive = new ZipArchive(fs, ZipArchiveMode.Read);
                var manifestEntry = archive.GetEntry("META-INF/MANIFEST.MF");
                if (manifestEntry != null)
                {
                    using var reader = new StreamReader(manifestEntry.Open());
                    string line;
                    while ((line = await reader.ReadLineAsync()) != null)
                    {
                        if (line.StartsWith("Main-Class: "))
                        {
                            var mainClass = line.Substring("Main-Class: ".Length).Trim();
                            if (!string.IsNullOrEmpty(mainClass)) return mainClass;
                        }
                    }
                }
            }
            catch (IOException ex) { throw new OlanException("文件读取错误", $"无法读取处理器 JAR 文件。文件可能已损坏或被占用。", OlanExceptionAction.Error, ex); }

            throw new OlanException("安装配置错误", $"在处理器的 MANIFEST.MF 文件中未找到有效的 'Main-Class' 定义。", OlanExceptionAction.Error);
        }

        private string BuildClasspathArgument(List<string> classpath, string librariesPath,string mainPath)
        {
            var cpBuilder = new StringBuilder();
            char sep = Path.PathSeparator;

            foreach (var cpEntry in classpath)
            {
                cpBuilder.Append(Tools.MavenToPath(librariesPath, cpEntry));
                cpBuilder.Append(sep);
            }
            return $"-cp \"{cpBuilder.ToString()}{mainPath}\"";
        }

        private string BuildProcessorArguments(List<string> argsTemplate, Dictionary<string, string> placeholders, string librariesPath, int all, int done)
        {
            var stdArgsBuilder = new StringBuilder();
            foreach (var arg in argsTemplate)
            {
                if (arg.StartsWith("{") && arg.EndsWith("}"))
                {
                    if (placeholders.TryGetValue(arg.Trim('{', '}'), out var value)) stdArgsBuilder.Append($"\"{value}\" ");
                    else ProcessorsOutEvent?.Invoke(all, done, $"[警告] 未找到占位符 {arg}，将忽略此参数。");
                }
                else if (arg.StartsWith("["))
                {
                    stdArgsBuilder.Append($"\"{Tools.MavenToPath(librariesPath, arg)}\" ");
                }
                else
                {
                    stdArgsBuilder.Append($"{arg} ");
                }
            }
            return stdArgsBuilder.ToString().Trim();
        }

        private Dictionary<string, string> BuildPlaceholderDictionary(ForgeSeriesInstallProfile profile, string librariesPath, string gameRootPath, string minecraftJarPath, string clientLzmaPath)
        {
            var placeholders = new Dictionary<string, string>
            {
                { "SIDE", "client" }, { "MINECRAFT_JAR", minecraftJarPath },
                { "LIBRARY_DIR", librariesPath }, { "ROOT", gameRootPath },
            };

            if (profile.Data?.Placeholders == null) return placeholders;

            foreach (var entry in profile.Data.Placeholders)
            {
                if (entry.Value is not JsonElement element) continue;
                string rawValue = "";
                if (element.ValueKind == JsonValueKind.Object && element.TryGetProperty("client", out var clientElement))
                    rawValue = clientElement.GetString() ?? "";
                else if (element.ValueKind == JsonValueKind.String)
                    rawValue = element.GetString() ?? "";

                if (string.IsNullOrEmpty(rawValue)) continue;

                string processedValue;
                if (rawValue.StartsWith("[") && rawValue.EndsWith("]"))
                    processedValue = Tools.MavenToPath(librariesPath, rawValue);
                else if (rawValue.StartsWith("'") && rawValue.EndsWith("'"))
                    processedValue = rawValue.Trim('\'');
                else
                    processedValue = rawValue;

                placeholders[entry.Key] = processedValue;
            }
            if (placeholders.ContainsKey("BINPATCH"))
                placeholders["BINPATCH"] = clientLzmaPath;

            return placeholders;
        }

        #endregion
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/forgeseries/ForgeSeriesUsing.cs
【代码拼接器】文件内容开始
using System.Text;
using System.Text.Json;
namespace OneLauncher.Core.Mod.ModLoader.forgeseries;
public class ForgeSeriesUsing
{
    public ForgeSeriesVersionJson info;
    public async Task Init(string basePath, string version,bool isForge)
    {
        string jsonPath = Path.Combine(basePath, "versions", version, $"version.{(isForge ? "forge" : "neoforge")}.json");
        info = await JsonSerializer.DeserializeAsync(File.OpenRead(jsonPath), ForgeSeriesJsonContext.Default.ForgeSeriesVersionJson);
    }
    /// <summary>
    /// 获取当前NeoForge的依赖库列表
    /// </summary>
    public List<(string name, string path)> GetLibrariesForLaunch(string LibBasePath)
    {
        return info.Libraries.Select(
            item => (
                item.Name,
                Path.Combine(LibBasePath, "libraries",
                             Path.Combine(item.Downloads.Artifact.Path.Split('/')))
            )
        ).ToList();
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/forgeseries/ForgeVersionListGetter.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Xml.Linq;

namespace OneLauncher.Core.Mod.ModLoader.forgeseries;

/// <summary>
/// 一个统一的工具类，用于获取 Forge 和 NeoForge 的最新版本和安装器 URL。
/// </summary>
public class ForgeVersionListGetter
{
    private readonly HttpClient _httpClient;

    // API URL 常量
    private const string ForgeMetadataUrl = "https://maven.minecraftforge.net/net/minecraftforge/forge/maven-metadata.xml";
    private const string ForgePromotionsUrl = "https://files.minecraftforge.net/net/minecraftforge/forge/promotions_slim.json";
    private const string NeoForgeMetadataUrl = "https://maven.neoforged.net/releases/net/neoforged/neoforge/maven-metadata.xml";

    public ForgeVersionListGetter(HttpClient httpClient)
    {
        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
    }

    /// <summary>
    /// 根据类型和条件，获取最新的安装器下载 URL。
    /// </summary>
    /// <param name="isForge">为 true 时获取 Forge，为 false 时获取 NeoForge。</param>
    /// <param name="mcVersion">Minecraft 版本号，例如 "1.20.1"。</param>
    /// <param name="allowBeta">【仅用于 NeoForge】是否允许选择 Beta 版本。</param>
    /// <param name="useRecommended">【仅用于 Forge】是否优先使用官方推荐版。</param>
    /// <returns>安装器的完整下载 URL。</returns>
    public async Task<string> GetInstallerUrlAsync(bool isForge, string mcVersion, bool allowBeta = true, bool useRecommended = true)
    {
        string fullVersion = isForge
            ? await GetLatestForgeVersionAsync(mcVersion, useRecommended)
            : await GetLatestNeoForgeVersionAsync(mcVersion, allowBeta);

        if (string.IsNullOrEmpty(fullVersion))
        {
            string modType = isForge ? "Forge" : "NeoForge";
            throw new OlanException("版本获取失败", $"未能确定最新的 {modType} 版本。", OlanExceptionAction.Error);
        }

        return isForge
            ? $"https://maven.minecraftforge.net/net/minecraftforge/forge/{fullVersion}/forge-{fullVersion}-installer.jar"
            : $"https://maven.neoforged.net/releases/net/neoforged/neoforge/{fullVersion}/neoforge-{fullVersion}-installer.jar";
    }

    #region Private Implementation Details

    private async Task<string> GetLatestForgeVersionAsync(string mcVersion, bool useRecommended)
    {
        try
        {
            var promotions = await FetchForgePromotionsAsync();
            string key = useRecommended ? $"{mcVersion}-recommended" : $"{mcVersion}-latest";
            if (promotions.TryGetValue(key, out var forgeNum)) return $"{mcVersion}-{forgeNum}";
            if (useRecommended && promotions.TryGetValue($"{mcVersion}-latest", out forgeNum)) return $"{mcVersion}-{forgeNum}";
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[ForgeVersionGetter] 获取 Forge promotions 失败: {ex.Message}。将从完整列表查找。");
        }

        var allVersions = await FetchAndParseAllForgeVersionsAsync();
        var suitableVersion = allVersions.Where(v => v.MinecraftVersion == mcVersion).Max();

        return suitableVersion?.FullVersionString;
    }

    private async Task<string> GetLatestNeoForgeVersionAsync(string mcVersion, bool allowBeta)
    {
        string prefix = ConvertMcVersionToNeoForgePrefix(mcVersion);
        if (prefix == null) throw new OlanException("无效的 Minecraft 版本", $"无法为 '{mcVersion}' 生成有效的 NeoForge 版本前缀。", OlanExceptionAction.Warning);

        var allVersions = await FetchAndParseAllNeoForgeVersionsAsync();
        var suitableVersion = allVersions.Where(v => v.FullVersionString.StartsWith(prefix) && (allowBeta || !v.IsBeta)).Max();

        return suitableVersion?.FullVersionString;
    }

    private async Task<Dictionary<string, string>> FetchForgePromotionsAsync()
    {
        try
        {
            var promoData = 
                await JsonSerializer.DeserializeAsync<ForgePromotionData>(
                    await _httpClient.GetStreamAsync(ForgePromotionsUrl),ForgeSeriesJsonContext.Default.ForgePromotionData);
            return promoData?.Promos ?? new Dictionary<string, string>();
        }
        catch (Exception ex)
        {
            throw new OlanException("获取Forge推荐版本失败", "无法从Forge官方源获取推荐版本列表。", OlanExceptionAction.Warning, ex);
        }
    }

    private async Task<List<ForgeVersionInfo>> FetchAndParseAllForgeVersionsAsync()
    {
        string xmlContent;
        try { xmlContent = await _httpClient.GetStringAsync(ForgeMetadataUrl); }
        catch (HttpRequestException ex) { throw new OlanException("网络错误", "无法从 Forge 官方源获取版本列表。", OlanExceptionAction.Error, ex); }

        try
        {
            return XDocument.Parse(xmlContent).Descendants("version")
                .Select(v => { try { return new ForgeVersionInfo(v.Value); } catch { return null; } })
                .Where(v => v != null).ToList();
        }
        catch (System.Xml.XmlException ex) { throw new OlanException("元数据格式错误", "Forge 版本列表的 XML 元数据格式无效。", OlanExceptionAction.Error, ex); }
    }

    private string ConvertMcVersionToNeoForgePrefix(string mcVersion)
    {
        if (string.IsNullOrWhiteSpace(mcVersion) || !mcVersion.StartsWith("1.")) return null;
        var versionPart = mcVersion.Substring(2).Split('.');
        if (versionPart.Length >= 2 && int.TryParse(versionPart[0], out _) && int.TryParse(versionPart[1], out _))
            return $"{versionPart[0]}.{versionPart[1]}.";
        return null;
    }

    private async Task<List<NeoForgeVersionInfo>> FetchAndParseAllNeoForgeVersionsAsync()
    {
        string xmlContent;
        try { xmlContent = await _httpClient.GetStringAsync(NeoForgeMetadataUrl); }
        catch (HttpRequestException ex) { throw new OlanException("网络错误", "无法从 NeoForge 官方源获取版本列表。", OlanExceptionAction.Error, ex); }

        try
        {
            return XDocument.Parse(xmlContent).Descendants("version")
                .Select(v => { try { return new NeoForgeVersionInfo(v.Value); } catch { return null; } })
                .Where(v => v != null).ToList();
        }
        catch (System.Xml.XmlException ex) { throw new OlanException("元数据格式错误", "NeoForge 版本列表的 XML 元数据格式无效。", OlanExceptionAction.Error, ex); }
    }

    #endregion
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModLoader/forgeseries/JsonModel.cs
【代码拼接器】文件内容开始
using System.Text.Json.Serialization;
using static OneLauncher.Core.Mod.ModLoader.forgeseries.ForgeVersionListGetter;

[JsonSerializable(typeof(ForgeSeriesVersionJson))]
[JsonSerializable(typeof(ForgeSeriesArguments))]
[JsonSerializable(typeof(ForgeSeriesLibrary))]
[JsonSerializable(typeof(ForgeSeriesDownloads))]
[JsonSerializable(typeof(ForgeSeriesArtifact))]
[JsonSerializable(typeof(ForgeSeriesProcessor))]
[JsonSerializable(typeof(ForgeSeriesInstallProfile))] 
[JsonSerializable(typeof(ForgeSeriesData))]
[JsonSerializable(typeof(ForgePromotionData))]
[JsonSerializable(typeof(ForgeVersionInfo))]
[JsonSerializable(typeof(NeoForgeVersionInfo))]
public partial class ForgeSeriesJsonContext : JsonSerializerContext { }

public class ForgePromotionData
{
    [JsonPropertyName("promos")]
    public Dictionary<string, string> Promos { get; set; }
}

public class ForgeVersionInfo : IComparable<ForgeVersionInfo>
{
    public string FullVersionString { get; }
    public string MinecraftVersion { get; }
    public Version ForgeVersion { get; }

    public ForgeVersionInfo(string versionStr)
    {
        FullVersionString = versionStr ?? throw new ArgumentNullException(nameof(versionStr));
        int separatorIndex = versionStr.IndexOf('-');
        if (separatorIndex <= 0) throw new ArgumentException($"Invalid Forge version format: {versionStr}");

        MinecraftVersion = versionStr.Substring(0, separatorIndex);
        string forgePart = versionStr.Substring(separatorIndex + 1);

        if (!Version.TryParse(forgePart.Split('-')[0], out var parsedVersion))
            throw new ArgumentException($"Cannot parse Forge version part: {forgePart}");
        ForgeVersion = parsedVersion;
    }

    public int CompareTo(ForgeVersionInfo other) => other == null ? 1 : ForgeVersion.CompareTo(other.ForgeVersion);
    public override string ToString() => FullVersionString;
}
public class NeoForgeVersionInfo : IComparable<NeoForgeVersionInfo>
{
    public string FullVersionString { get; }
    public Version ParsedNumericVersion { get; }
    public bool IsBeta { get; }

    public NeoForgeVersionInfo(string versionStr)
    {
        FullVersionString = versionStr ?? throw new ArgumentNullException(nameof(versionStr));
        string numericPart = versionStr;
        if (versionStr.Contains("-"))
        {
            numericPart = versionStr.Split('-')[0];
            IsBeta = versionStr.ToLowerInvariant().Contains("beta");
        }
        if (!Version.TryParse(numericPart, out var parsedVersion))
            throw new ArgumentException($"Cannot parse NeoForge version part: {numericPart}");
        ParsedNumericVersion = parsedVersion;
    }

    public int CompareTo(NeoForgeVersionInfo other)
    {
        if (other == null) return 1;
        int numericCompare = ParsedNumericVersion.CompareTo(other.ParsedNumericVersion);
        if (numericCompare != 0) return numericCompare;
        return IsBeta == other.IsBeta ? 0 : (IsBeta ? -1 : 1); // 稳定版 (非Beta) 优先
    }
    public override string ToString() => FullVersionString;
}
// --- version.json 的模型 ---
public class ForgeSeriesVersionJson
{
    [JsonPropertyName("mainClass")]
    public string MainClass { get; set; }
    [JsonPropertyName("arguments")]
    public ForgeSeriesArguments Arguments { get; set; }
    [JsonPropertyName("libraries")]
    public List<ForgeSeriesLibrary> Libraries { get; set; }
}

public class ForgeSeriesArguments
{
    [JsonPropertyName("game")]
    public List<string> Game { get; set; }
    [JsonPropertyName("jvm")]
    public List<string> Jvm { get; set; }
}

// --- install_profile.json 的模型 ---

public class ForgeSeriesInstallProfile
{
    [JsonPropertyName("data")]
    public ForgeSeriesData Data { get; set; } 
    [JsonPropertyName("processors")]
    public List<ForgeSeriesProcessor> Processors { get; set; }
    [JsonPropertyName("libraries")]
    public List<ForgeSeriesLibrary> Libraries { get; set; }
}

// ✨ 最关键的部分：使用 JsonExtensionData 来处理所有占位符 ✨
public class ForgeSeriesData
{
    [JsonExtensionData]
    public Dictionary<string, object> Placeholders { get; set; }
}

// --- 通用子模型 ---
public class ForgeSeriesProcessor
{
    [JsonPropertyName("sides")]
    public List<string> Sides { get; set; }
    [JsonPropertyName("jar")]
    public string Jar { get; set; }
    [JsonPropertyName("classpath")]
    public List<string> Classpath { get; set; }
    [JsonPropertyName("args")]
    public List<string> Args { get; set; }
}

public class ForgeSeriesLibrary
{
    [JsonPropertyName("name")]
    public string Name { get; set; }
    [JsonPropertyName("downloads")]
    public ForgeSeriesDownloads Downloads { get; set; }
}

public class ForgeSeriesDownloads
{
    [JsonPropertyName("artifact")]
    public ForgeSeriesArtifact Artifact { get; set; }
}

public class ForgeSeriesArtifact
{
    [JsonPropertyName("sha1")]
    public string Sha1 { get; set; }
    [JsonPropertyName("size")]
    public int Size { get; set; }
    [JsonPropertyName("url")]
    public string Url { get; set; }
    [JsonPropertyName("path")]
    public string Path { get; set; }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModPack/JsonModes.cs
【代码拼接器】文件内容开始
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Mod.ModPack.JsonModels
{

    [JsonSerializable(typeof(ModrinthManifest))]
    [JsonSerializable(typeof(FinalVersionInfo))]
    public partial class MrpackJsonContext : JsonSerializerContext
    {
    }

    public class ModrinthManifest
    {
        [JsonPropertyName("formatVersion")]
        public int FormatVersion { get; set; }

        [JsonPropertyName("game")]
        public string Game { get; set; }

        [JsonPropertyName("versionId")]
        public string VersionId { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("dependencies")]
        public Dictionary<string, string> Dependencies { get; set; }

        [JsonPropertyName("files")]
        public List<ModrinthFile> Files { get; set; }
    }

    public class ModrinthFile
    {
        [JsonPropertyName("path")]
        public string Path { get; set; }

        [JsonPropertyName("hashes")]
        public Dictionary<string, string> Hashes { get; set; }

        [JsonPropertyName("downloads")]
        public List<string> Downloads { get; set; }

        [JsonPropertyName("fileSize")]
        public int FileSize { get; set; }
    }
    public class FinalVersionInfo
    {
        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonPropertyName("inheritsFrom")]
        public string InheritsFrom { get; set; }

        [JsonPropertyName("type")]
        public string Type { get; set; } = "release"; 
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModPack/ModpackImporter.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Downloader.DownloadMinecraftProviders;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using System.Diagnostics;
using System.IO.Compression;
using System.Threading;
using System.Threading.Tasks;

namespace OneLauncher.Core.Mod.ModPack;
public class ModpackImporter : IDisposable
{
    private readonly Download downloadTool;
    private readonly string gameRootPath;
    private string tempWorkDir;

    private ModpackImporter(Download download, string gameRootPath)
    {
        this.downloadTool = download;
        this.gameRootPath = gameRootPath;
    }

    public static async Task ImportFromMrpackAsync(
        string packPath,
        string gameRoot,
        CancellationToken token = default)
    {
        //using var downloader = new Download();
        //using var importer = new ModpackImporter(downloader, gameRoot);
        //await importer.RunImportAsync(packPath, token);
    }

    //private async Task RunImportAsync(string packPath, CancellationToken token)
    //{
    //    // 解压与解析
    //    tempWorkDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
    //    Directory.CreateDirectory(tempWorkDir);
    //    Download.ExtractFile(packPath, tempWorkDir);
    //    token.ThrowIfCancellationRequested();

    //    string manifestPath = Path.Combine(tempWorkDir, "modrinth.index.json");
    //    if (!File.Exists(manifestPath))
    //        throw new OlanException("整合包无效", "压缩包内未找到 modrinth.index.json 文件。", OlanExceptionAction.Error); //

    //    await using var manifestStream = new FileStream(manifestPath, FileMode.Open, FileAccess.Read);
    //    var parser = new MrpackParser(manifestStream);

    //    // 获取整合包信息
    //    string mcVersion = parser.GetMinecraftVersion();
    //    (ModEnum loaderType, string loaderVersion) = parser.GetLoaderInfo();

    //    var packGameData = new GameData(
    //        parser.GetName(),
    //        mcVersion,
    //        loaderType,
    //        null // 默认
    //    );

    //    Directory.CreateDirectory(packGameData.InstancePath);

    //    await InstallBaseGameAsync(packGameData, token);
    //    token.ThrowIfCancellationRequested();

    //    await InstallModpackFilesAsync(parser, packGameData, token);
    //    token.ThrowIfCancellationRequested();

    //    await Init.GameDataManger.AddGameDataAsync(packGameData);
    //}

    //private async Task InstallBaseGameAsync(GameData gameData, CancellationToken token)
    //{
    //    using var downTool = new Download();
    //    var loaderType = gameData.ModLoader;
    //    var mcVersion = gameData.VersionId;

    //    var downInfo = await DownloadInfo.Create(
    //            mcVersion, new ModType()
    //            {
    //                IsFabric = loaderType == ModEnum.fabric,
    //                IsNeoForge = loaderType == ModEnum.neoforge,
    //                IsForge = loaderType == ModEnum.forge
    //            }, downTool, false, true, true, true, null, gameData
    //        );

    //    var mcDownloader = new DownloadMinecraft(
    //        downInfo,
    //        null,
    //        token
    //    );

    //    await mcDownloader.MinecraftBasic(
    //        maxDownloadThreads: Init.ConfigManager.config.OlanSettings.MaximumDownloadThreads,
    //        maxSha1Threads: Init.ConfigManager.config.OlanSettings.MaximumSha1Threads,
    //        IsSha1: Init.ConfigManager.config.OlanSettings.IsSha1Enabled,
    //        useBMLCAPI: Init.ConfigManager.config.OlanSettings.IsAllowToDownloadUseBMLCAPI
    //    );
    //    await Init.ConfigManager.Save();
    //}

    //private async Task InstallModpackFilesAsync(MrpackParser parser, GameData gameData, CancellationToken token)
    //{
    //    string modsDir = Path.Combine(gameData.InstancePath, "mods");
    //    Directory.CreateDirectory(modsDir);
    //    var filesToDownload = parser.GetLibraries(gameData.Name, modsDir);

    //    if (filesToDownload.Any())
    //    {
    //        await downloadTool.DownloadListAsync(null, filesToDownload, Init.ConfigManager.config.OlanSettings.MaximumDownloadThreads, token); //
    //    }

    //    string overridesSourceDir = Path.Combine(tempWorkDir, "overrides");
    //    if (Directory.Exists(overridesSourceDir))
    //    {
    //        await Tools.CopyDirectoryAsync(overridesSourceDir, gameData.InstancePath, token); //
    //    }
    //}

    public void Dispose()
    {
        //if (!string.IsNullOrEmpty(tempWorkDir) && Directory.Exists(tempWorkDir))
        //{
        //    try
        //    {
        //        Directory.Delete(tempWorkDir, true);
        //    }
        //    catch (Exception ex)
        //    {
        //        Debug.WriteLine($"清理整合包临时目录 '{tempWorkDir}' 失败: {ex.Message}");
        //    }
        //}
        //downloadTool?.Dispose();
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core/Mod/ModPack/MrpackParser.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Mod.ModPack.JsonModels;
using System.Text.Json;

namespace OneLauncher.Core.Mod.ModPack;
public class MrpackParser
{
    private readonly ModrinthManifest manifest;

    public MrpackParser(Stream manifest)
    {
        try
        {
            this.manifest = JsonSerializer.Deserialize(manifest, MrpackJsonContext.Default.ModrinthManifest)
                       ?? throw new JsonException("反序列化返回 null。");
        }
        catch (JsonException ex)
        {
            throw new OlanException("解析失败", "无法解析 modrinth.index.json。文件可能已损坏或格式不正确。", OlanExceptionAction.Error,ex);
        }
    }

    public string GetName() => manifest.Name;
    public string GetMinecraftVersion()
    {
        if (manifest.Dependencies.TryGetValue("minecraft", out var version))
            return version;

        throw new OlanException("清单格式错误", "在 dependencies 中找不到指定的 'minecraft' 版本。", OlanExceptionAction.Error);
    }
    public (ModEnum Type, string Version) GetLoaderInfo()
    {
        if (manifest.Dependencies.TryGetValue("fabric-loader", out var fabricVersion))
            return (ModEnum.fabric, fabricVersion);

        if (manifest.Dependencies.TryGetValue("neoforge", out var neoForgeVersion))
            return (ModEnum.neoforge, neoForgeVersion);

        var unsupportedLoader = manifest.Dependencies.Keys.FirstOrDefault(k => k.Contains("forge") || k.Contains("quilt"));
        if (unsupportedLoader != null)
            throw new OlanException("加载器不兼容", $"该整合包需要 '{unsupportedLoader}' 加载器，当前启动器不支持。", OlanExceptionAction.Error);

        throw new OlanException("加载器不兼容", "未在整合包中找到受支持的加载器 (Fabric 或 NeoForge)。", OlanExceptionAction.Error);
    }
    public List<NdDowItem> GetLibraries(string instanceName, string modPath)
    {
        var items = new List<NdDowItem>(manifest.Files.Count);

        foreach (var file in manifest.Files)
        {
            items.Add(new NdDowItem(
                Url: file.Downloads.FirstOrDefault(),
                Path:Path.Combine(modPath,Path.Combine(file.Path.Split('/'))),
                Size:file.FileSize,
                Sha1:file.Hashes["sha1"]));
        }

        return items;
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/AdoptiumAPI.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Helper.Models;
using System.Diagnostics;
using System.Formats.Tar;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Nodes;

namespace OneLauncher.Core.Net;

public class AdoptiumAPI
{
    // https://api.adoptium.net/v3/assets/feature_releases/21/ga?architecture=x64&os=mac&image_type=jre
    public static async Task JavaReleaser(string javaVersion, string savePath, SystemType OsType) 
    {
        var javaDownloadPath = Path.Combine(savePath, javaVersion, $"{javaVersion}.zip");
        var os = OsType switch
        {
            SystemType.windows => "windows",
            SystemType.linux => "linux",
            SystemType.osx => "mac"
        };
        var arch = RuntimeInformation.OSArchitecture switch
        {
            Architecture.X64 => "x64",
            Architecture.Arm64 => "aarch64"
        };
        using (var a = new Download())
        {
            await a.DownloadFileBig(
                url: await GetBinaryPackageLinkAsync(
                    $"https://api.adoptium.net/v3/assets/feature_releases/{javaVersion}/ga?architecture={arch}&os={os}&image_type=jre"
                    , a.unityClient),
                savePath: javaDownloadPath,
                knownSize:null,
                maxSegments: 6);
        }
        // 对于windows，api返回的是zip，对于mac或者linux，api返回的是tag.gz
        if (OsType == SystemType.windows)
            Download.ExtractFile(javaDownloadPath, Path.Combine(savePath, javaVersion));
        else if (OsType == SystemType.osx || OsType == SystemType.linux)
        {
            var tempTarPath = Path.Combine(savePath, javaVersion, $"{javaVersion}.tar");

            using (FileStream sourceFileStream = new FileStream(javaDownloadPath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                using (GZipStream gzipStream = new GZipStream(sourceFileStream, CompressionMode.Decompress))
                {
                    using (FileStream tempTarFileStream = new FileStream(tempTarPath, FileMode.Create, FileAccess.Write, FileShare.None))
                    {
                        await gzipStream.CopyToAsync(tempTarFileStream);
                    }
                }
            }

            // 步骤 2: 异步解压临时 .tar 文件到目标目录
            using (FileStream tarFileStream = new FileStream(tempTarPath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                // TarFile.ExtractToDirectoryAsync 接受一个 Stream 参数
                await TarFile.ExtractToDirectoryAsync(tarFileStream, Path.Combine(savePath, javaVersion), overwriteFiles: true);
            }
            File.Delete(tempTarPath);
        }
        File.Delete(javaDownloadPath);
    }

    public static async Task<string> GetBinaryPackageLinkAsync(string apiUrl, HttpClient client)
    {
        try
        {
            using (Stream responseStream = await client.GetStreamAsync(apiUrl))
            {

                JsonNode rootNode = await JsonNode.ParseAsync(responseStream);

                string? link = rootNode?             // 根节点
                                .AsArray()?         // 尝试将其视为数组
                                [0]?  // 获取数组的第一个元素
                                ["binaries"]?       // 访问名为 "binaries" 的属性
                                .AsArray()?         // 尝试将其视为数组
                                [0]?  // 获取 "binaries" 数组的第一个元素
                                ["package"]?        // 访问名为 "package" 的属性
                                ["link"]?           // 访问名为 "link" 的属性
                                .GetValue<string>(); // 获取其字符串值

                // 我造密码的编译器报错了就是返回null
                return link;
            }
        }
        catch (HttpRequestException ex)
        {
            Debug.WriteLine($"网络请求错误: {ex.Message}");
            return null;
        }
        catch (JsonException ex)
        {
            Debug.WriteLine($"JSON 解析错误: {ex.Message}");
            return null;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"发生未知错误: {ex.Message}");
            return null;
        }
    }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ConnectToolPower/IConnectService.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Text;

namespace OneLauncher.Core.Net.ConnectToolPower;

public interface IConnectService
{
    void StartAsHost(
        string? nodeName, 
        string? token
        );
    void Join(
        string? nodeName, 
        string peerNodeName, 
        int? sourcePort,
        int destPort, 
        string? destIp, 
        string? appName, 
        string? token);
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ConnectToolPower/MCTPower.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using System;
using System.Diagnostics;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace OneLauncher.Core.Net.ConnectToolPower;

/// <summary>
/// 负责与 Minecraft Connect Tool 的核心文件交互
/// </summary>
public class MCTPower : IDisposable
{
    private const string CoreExecutableName = "main.exe";
    private const string CoreUrl = "https://gitee.com/linfon18/minecraft-connect-tool-api/raw/master/mainnew.exe";
    private const string CoreMd5 = "08160296509deac13e7d12c8754de9ef";

    private readonly string coreDirectory;
    private readonly string coreFilePath;
    private Process? coreProcess;

    public event Action<string>? CoreLog;
    public event Action? ConnectionEstablished;

    private MCTPower(string coreDirectory,string coreFileName)
    {
        this.coreDirectory = coreDirectory;
        coreFilePath = coreFileName;
    }
    public static async Task<MCTPower> InitializationAsync(HttpClient? client = null)
    {
        var httpClient = client ?? new HttpClient();
        string coreDirectory = Path.Combine(Init.BasePath,"installed");
        string coreFileName = Path.Combine(coreDirectory, CoreExecutableName);
        Directory.CreateDirectory(coreDirectory);
        // 下载核心组件
        if (!File.Exists(coreFileName))
        {
            using (var dt = new Download(client))
                await dt.DownloadFile(CoreUrl,coreFileName);
            // 校验
            string? currentMd5 = await Tools.GetFileMD5Async(coreFileName);
            if (currentMd5 == null)
                throw new OlanException("无法初始化联机模块", "在对核心程序校验时发生意外错误", OlanExceptionAction.Error);
            if (currentMd5 != CoreMd5)
                throw new OlanException("无法初始化联机模块", $"【无法校验核心组件MD5】{Environment.NewLine}警告：您当前的网络环境可能不安全", OlanExceptionAction.FatalError);
        }
        if (client == null)
            httpClient.Dispose();
        return new MCTPower(coreDirectory,coreFileName);
    }

    /// <summary>
    /// 启动核心进程。
    /// </summary>
    /// <param name="arguments">启动参数。</param>
    public void LaunchCore(string arguments)
    {
        if (coreProcess != null && !coreProcess.HasExited)
        {
            throw new InvalidOperationException("P2P核心已经在运行中。");
        }

        coreProcess = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = coreFilePath,
                Arguments = arguments,
                WorkingDirectory = coreDirectory,
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true,
                StandardOutputEncoding = Encoding.UTF8,
                StandardErrorEncoding = Encoding.UTF8
            },
            EnableRaisingEvents = true
        };
        // 他又让我改回第一版注释了，那就只能再次注释注释注释的注释了
        // 这里原本是// 他让我把注释删了，为了避免误人子弟，我这里把注释给注释掉
        // 这里原本是// 这里原来是// 解决作者写的屎山代码认配置文件不认命令行的问题
        var coreConfigPath = Path.Combine(coreDirectory, "config.json");
        if (File.Exists(coreConfigPath)) File.Delete(coreConfigPath);
        bool IsConnectionOk = false;
        coreProcess.OutputDataReceived += (s, e) => 
        {
            if (string.IsNullOrEmpty(e.Data))
                return;
            Debug.WriteLine(e.Data);
            CoreLog?.Invoke(e.Data);
            if ((e.Data.Contains("connection ok") || e.Data.Contains("handshakeC2C ok")) && !IsConnectionOk)
            {
                IsConnectionOk = true;
                ConnectionEstablished?.Invoke();
            }
        };
        coreProcess.ErrorDataReceived += (s, e) => 
        {
            if (string.IsNullOrEmpty(e.Data))
                return;
            Debug.WriteLine(e.Data);
            CoreLog?.Invoke(e.Data);
        };

        coreProcess.Start();
        coreProcess.BeginOutputReadLine();
        coreProcess.BeginErrorReadLine();
        //await coreProcess.WaitForExitAsync();
    }

    /// <summary>
    /// 停止核心进程。
    /// </summary>
    public void StopCore()
    {
        if (coreProcess != null && !coreProcess.HasExited)
        {
            try
            {
                coreProcess.Kill(true); 
                coreProcess.WaitForExit();
            }
            finally
            {
                coreProcess.Dispose();
                coreProcess = null;
            }
        }
    }

    public void Dispose() => StopCore();
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ConnectToolPower/P2PMode.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper;
using OneLauncher.Core.Helper.Models;
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace OneLauncher.Core.Net.ConnectToolPower;

public class P2PMode : IConnectService
{
    // 这里就不搞什么花招了，防君子不防小人反编译一样看得到
    const string defaultToken = "17073157824633806511";
    const string defaultAppName = "OneLauncherConnentService";
    const string defaultDestIP = "127.0.0.1";
    private MCTPower mainPower;
    public P2PMode(MCTPower mainPower)
    {
        if (Init.SystemType != SystemType.windows)
            throw new OlanException("无法初始化联机模块","你的操作系统不受支持");
        this.mainPower = mainPower;
    }

    public void Join(string? nodeName, string peerNodeName, int? sourcePort, int destPort, string? destIp, string? appName, string? token)
    {
        // 获取可用端口
        int localPort = sourcePort ?? Tools.GetFreeTcpPort();

        string localNodeName = nodeName ?? "OLANNODE" + RandomNumberGenerator.GetInt32(100000, 1000000000).ToString();
        string finalAppName = (appName ?? defaultAppName) + localPort;

        var args = new StringBuilder();
        args.Append($"-node \"{localNodeName}\" ");
        args.Append($"-appname \"{finalAppName}\" ");
        args.Append($"-peernode \"{peerNodeName}\" ");
        args.Append($"-dstip \"{destIp ?? defaultDestIP}\" ");
        args.Append($"-dstport {destPort} ");
        args.Append($"-srcport {localPort} ");
        args.Append($"-token \"{token ?? defaultToken}\" ");

        mainPower.LaunchCore(args.ToString());
    }

    public void StartAsHost(string? nodeName, string? token)
    {
        string? node = nodeName;
        if (nodeName == null)
                node = "OLANNODE" + RandomNumberGenerator.GetInt32(100000,1000000000).ToString();
        mainPower.LaunchCore($"-node \"{node}\" -token \"{token ?? defaultToken}\"");
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/Microsoft/JsonModels.cs
【代码拼接器】文件内容开始
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Net.msa.JsonModels;

// --- 请求体模型 ---

public class XboxLiveAuthRequest
{
    [JsonPropertyName("Properties")]
    public XboxLiveAuthRequestProperties Properties { get; set; } = new();

    [JsonPropertyName("RelyingParty")]
    public string RelyingParty { get; set; } = string.Empty;

    [JsonPropertyName("TokenType")]
    public string TokenType { get; set; } = string.Empty;
}

public class XboxLiveAuthRequestProperties
{
    [JsonPropertyName("AuthMethod")]
    public string AuthMethod { get; set; } = string.Empty;

    [JsonPropertyName("SiteName")]
    public string SiteName { get; set; } = string.Empty;

    [JsonPropertyName("RpsTicket")]
    public string RpsTicket { get; set; } = string.Empty;
}

public class XSTSAuthRequest
{
    [JsonPropertyName("Properties")]
    public XSTSAuthRequestProperties Properties { get; set; } = new();

    [JsonPropertyName("RelyingParty")]
    public string RelyingParty { get; set; } = string.Empty;

    [JsonPropertyName("TokenType")]
    public string TokenType { get; set; } = string.Empty;
}

public class XSTSAuthRequestProperties
{
    [JsonPropertyName("SandboxId")]
    public string SandboxId { get; set; } = string.Empty;

    [JsonPropertyName("UserTokens")]
    public string[] UserTokens { get; set; } = Array.Empty<string>();
}

public class MinecraftLoginRequest
{
    [JsonPropertyName("identityToken")]
    public string IdentityToken { get; set; } = string.Empty;
}

// --- 响应体模型 (原有的保持不变，只是添加了JsonPropertyName特性以确保与AOT兼容性更好) ---

public class DeviceCodeResponse
{
    [JsonPropertyName("device_code")]
    public string DeviceCode { get; set; } = string.Empty;

    [JsonPropertyName("user_code")]
    public string UserCode { get; set; } = string.Empty;

    [JsonPropertyName("verification_uri")]
    public string VerificationUri { get; set; } = string.Empty;

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("interval")]
    public int Interval { get; set; }
}

public class TokenResponse
{
    [JsonPropertyName("token_type")]
    public string TokenType { get; set; } = string.Empty;

    [JsonPropertyName("scope")]
    public string Scope { get; set; } = string.Empty;

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }

    [JsonPropertyName("access_token")]
    public string AccessToken { get; set; } = string.Empty;

    [JsonPropertyName("refresh_token")]
    public string RefreshToken { get; set; } = string.Empty;

    [JsonPropertyName("id_token")]
    public string? IdToken { get; set; }
}

public class ErrorResponse
{
    [JsonPropertyName("error")]
    public string Error { get; set; } = string.Empty;

    [JsonPropertyName("error_description")]
    public string ErrorDescription { get; set; } = string.Empty;
}

public class XboxLiveAuthResponse
{
    [JsonPropertyName("Token")]
    public string Token { get; set; } = string.Empty;

    [JsonPropertyName("DisplayClaims")]
    public XUIDisplayClaims DisplayClaims { get; set; } = new XUIDisplayClaims();
}

public class XUIDisplayClaims
{
    [JsonPropertyName("xui")]
    public XUI[] Xui { get; set; } = Array.Empty<XUI>();
}

public class XUI
{
    [JsonPropertyName("uhs")]
    public string Uhs { get; set; } = string.Empty;
}

public class XSTSAuthResponse
{
    [JsonPropertyName("Token")]
    public string Token { get; set; } = string.Empty;

    [JsonPropertyName("DisplayClaims")]
    public XUIDisplayClaims DisplayClaims { get; set; } = new XUIDisplayClaims();
}

public class XSTSErrorResponse
{
    [JsonPropertyName("XErr")]
    public string? XErr { get; set; }

    [JsonPropertyName("Message")]
    public string? Message { get; set; }
}

public class MinecraftLoginResponse
{
    [JsonPropertyName("access_token")]
    public string AccessToken { get; set; } = string.Empty;
    [JsonPropertyName("expires_in")]
    public int expires_in { get; set; } = 86400;
}

public class EntitlementsResponse
{
    [JsonPropertyName("items")]
    public EntitlementItem[] Items { get; set; } = Array.Empty<EntitlementItem>();
}

public class EntitlementItem { }

public class MinecraftProfileResponse
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = string.Empty;

    [JsonPropertyName("name")]
    public string Name { get; set; } = string.Empty;
}



[JsonSerializable(typeof(DeviceCodeResponse))]
[JsonSerializable(typeof(TokenResponse))]
[JsonSerializable(typeof(ErrorResponse))]
[JsonSerializable(typeof(XboxLiveAuthResponse))]
[JsonSerializable(typeof(XUIDisplayClaims))]
[JsonSerializable(typeof(XUI))]
[JsonSerializable(typeof(XSTSAuthResponse))]
[JsonSerializable(typeof(XSTSErrorResponse))]
[JsonSerializable(typeof(MinecraftLoginResponse))]
[JsonSerializable(typeof(EntitlementsResponse))]
[JsonSerializable(typeof(EntitlementItem))]
[JsonSerializable(typeof(MinecraftProfileResponse))]
[JsonSerializable(typeof(XboxLiveAuthRequest))]
[JsonSerializable(typeof(XboxLiveAuthRequestProperties))]
[JsonSerializable(typeof(XSTSAuthRequest))]
[JsonSerializable(typeof(XSTSAuthRequestProperties))]
[JsonSerializable(typeof(MinecraftLoginRequest))]
public partial class MsaJsonContext : JsonSerializerContext
{
}

public class TextureData
{
    [JsonPropertyName("profileName")]
    public string ProfileName { get; set; }

    [JsonPropertyName("textures")]
    public Textures Textures { get; set; }
}
public class Textures
{
    [JsonPropertyName("SKIN")]
    public TextureInfo Skin { get; set; }

    [JsonPropertyName("CAPE")]
    public TextureInfo Cape { get; set; }
}
public class TextureInfo
{
    [JsonPropertyName("url")]
    public string Url { get; set; }
    [JsonPropertyName("metadata")]
    public Metadata Metadata { get; set; }
}
public class Metadata
{
    [JsonPropertyName("model")]
    public string Model { get; set; }
}

[JsonSerializable(typeof(TextureData))]
[JsonSerializable(typeof(Textures))]
[JsonSerializable(typeof(TextureInfo))]
[JsonSerializable(typeof(Metadata))]
public partial class MojangProfileJsonContext : JsonSerializerContext { }
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/Microsoft/MojangProfile.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Downloader;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.msa.JsonModels;
using System.Buffers.Binary;
using System.Diagnostics;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Net.msa;
public struct MojangSkin
{
    public string Skin;
    public bool IsSlimModel;
}
public class MojangProfile : IDisposable
{
    public readonly string uuid;
    public readonly string accessToken;
    public readonly HttpClient httpClient;
    public MojangProfile(UserModel userModel)
    {
        this.uuid = userModel.uuid.ToString();
        this.accessToken = userModel.AccessToken;
        httpClient = new HttpClient();
        // 设置一些请求头
        httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);
        httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36");
        httpClient.DefaultRequestHeaders.Add("Connection", "keep-alive");
    }
    public async Task<MojangSkin> Get()
    {
        string url = $"https://sessionserver.mojang.com/session/minecraft/profile/{uuid}";
        using (var response = await httpClient.GetStreamAsync(url))
        {
            string SkinUrls = (
                // 解码Json并解码Base64
                Encoding.UTF8.GetString(
                    Convert.FromBase64String(
                         (await JsonNode.ParseAsync(response))
                         !["properties"]
                         !.AsArray()
                         ![0]
                         !["value"]
                         !.GetValue<string>()
                        )
                    )
                );
            var texture = JsonSerializer.Deserialize<TextureData>(SkinUrls,MojangProfileJsonContext.Default.TextureData);
            // 不加这行代码就会报错，报错内容是null我也不知道为什么
            bool isSlimModel = texture!.Textures.Skin.Metadata?.Model == "slim";
            return new MojangSkin
            {
                Skin = texture!.Textures.Skin.Url,
                IsSlimModel = isSlimModel
            };
        }
    }
    public async Task SetUseLocalFile(MojangSkin skin)
    {
        const string requestUrl = "https://api.minecraftservices.com/minecraft/profile/skins";
        HttpResponseMessage response = null; // 声明 response，以便在 catch 块中访问

        try
        {
            using (var formData = new MultipartFormDataContent())
            {
                // 添加模型参数
                formData.Add(new StringContent(skin.IsSlimModel ? "slim" : "classic"), "variant");
                var imageFilePath = skin.Skin.ToString();
                var fileStream = File.OpenRead(imageFilePath);
                var streamContent = new StreamContent(fileStream);
                streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/png");

                formData.Add(streamContent, "file", Path.GetFileName(imageFilePath));

                response = await httpClient.PostAsync(requestUrl, formData);
                response.EnsureSuccessStatusCode();

                Debug.WriteLine($"成功上传本地皮肤文件: {imageFilePath}");
                string successResponseContent = await response.Content.ReadAsStringAsync();
                Debug.WriteLine($"API 成功响应: {successResponseContent}");
            }
        }
        catch (HttpRequestException e)
        {
            Debug.WriteLine($"请求失败: {e.Message}");
            if (response != null) // 尝试读取错误响应内容
            {
                try
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                    Debug.WriteLine($"API 错误响应内容: {errorContent}");
                }
                catch (Exception contentEx)
                {
                    Debug.WriteLine($"读取错误响应内容失败: {contentEx.Message}");
                }
            }
            throw; // 重新抛出异常，让上层处理
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"上传皮肤时发生未知错误: {ex.Message}");
            throw; // 重新抛出异常
        }
    }
    public async Task SetUseUrl(MojangSkin skin)
    {
        const string requestUrl = "https://api.minecraftservices.com/minecraft/profile/skins";
        try
        {
            /*
            var payload = new
            {
                url = skin.Skin.ToString(),
                variant = skin.IsSlimModel ? "slim" : "classic"
            };
            string jsonPayload = JsonSerializer.Serialize(payload);
            */
            string jsonPayload = "{"+$"\"url\":\"{skin.Skin.ToString()}\",\"variant\":\"{(skin.IsSlimModel ? "slim" : "classic")}\""+"}";
            var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

            // 发送 POST 请求
            var response = await httpClient.PostAsync(requestUrl, content);
            // 这可能代表麻将服务器无法连接到url，这里尝试下载并手动上传
            if (response.StatusCode == System.Net.HttpStatusCode.BadRequest)
            {
                try
                {
                    var tempSavePath = Path.GetTempPath();
                    using (var downTask = new Download(httpClient))
                        await downTask.DownloadFile(skin.Skin, tempSavePath,CancellationToken.None);
                    await SetUseLocalFile(new MojangSkin() { Skin = tempSavePath, IsSlimModel = skin.IsSlimModel });
                }
                catch (HttpRequestException e)
                {
                    throw new OlanException("无法上传皮肤", "在再次尝试后依旧捕获到网络错误", OlanExceptionAction.Error, e);
                }
            }
            response.EnsureSuccessStatusCode();

            Debug.WriteLine($"成功通过 URL 更改皮肤: {skin.Skin.ToString()}");
        }
        catch (HttpRequestException e)
        {
            Debug.WriteLine($"请求失败: {e.Message}");
            throw;
        }
    }
    public async Task GetSkinHeadImage()
    {
        // 确保输出目录存在
        var outputPath = Path.Combine(Init.BasePath, "playerdata", "body");
        Directory.CreateDirectory(outputPath);

        // 1. 获取皮肤
        string sessionUrl = $"https://crafatar.com/renders/body/{uuid}";

        // 2. 调用第三方API下载完整的皮肤图片
        byte[] skinImageBytes;
        try
        {
            skinImageBytes = await httpClient.GetByteArrayAsync(sessionUrl);
            await File.WriteAllBytesAsync(Path.Combine(outputPath, $"{uuid}.png"), skinImageBytes);
        }
        catch (HttpRequestException ex)
        {
            throw new HttpRequestException($"下载皮肤图片失败，URL: {sessionUrl}，错误: {ex.Message}", ex);
        }
    }
    public void Dispose() => httpClient.Dispose();
    public static async Task<bool> IsValidSkinFile(string skinFile)
    {
        try
        {
            const int widthOffset = 16;
            const int heightOffset = 20;

            // 我们只需要读取文件的前 24 个字节就足够了
            byte[] buffer = new byte[24];

            await using (var stream = new FileStream(skinFile, FileMode.Open, FileAccess.Read))
            {
                int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);
                if (bytesRead < 24)
                {
                    // 文件太小，肯定不是有效的皮肤文件
                    return false;
                }
            }

            // PNG 格式使用大端序（Big-Endian）存储整数
            // 从 buffer 的第 16 位开始读取 4 字节作为宽度
            int width = BinaryPrimitives.ReadInt32BigEndian(buffer.AsSpan(widthOffset));
            // 从 buffer 的第 20 位开始读取 4 字节作为高度
            int height = BinaryPrimitives.ReadInt32BigEndian(buffer.AsSpan(heightOffset));

            // 现在进行和你原来完全一样的尺寸校验
            bool isValidDimension = (width == 64 && (height == 32 || height == 64));

            // 注意：高清皮肤(128x128) 和老式布局(32x64) 的支持可以根据需要添加，
            // 但 64x64 是最标准的。Mojang API 可能对更大尺寸有更严格的要求。
            // 为了安全起见，可以先只允许最常见的尺寸。
            // bool isValidDimension = (width == 64 && (height == 32 || height == 64));

            // 如果你需要支持更多尺寸，可以恢复原来的逻辑：
            // bool isValidDimension = (width == 64 && (height == 32 || height == 64)) ||
            //                         (width == 128 && height == 128) ||
            //                         (width == 32 && height == 64);

            return isValidDimension;
        }
        catch (Exception ex)
        {
            // 任何异常（如文件不是有效的PNG，读取失败等）都意味着文件无效
            Debug.WriteLine($"Skin validation failed: {ex.Message}");
            return false;
        }
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/Microsoft/MsalAuthenticator.cs
【代码拼接器】文件内容开始
using Duende.IdentityModel.OidcClient;
using Microsoft.Identity.Client;
using Microsoft.Identity.Client.Extensions.Msal;
using OneLauncher.Core.Net.msa.JsonModels;
using System.Diagnostics;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using OneLauncher.Core.Global;
using OneLauncher.Core.Helper.Models;


#if WINDOWS
using Microsoft.Identity.Client.Broker;
#endif
namespace OneLauncher.Core.Net.msa;

public class MsalAuthenticator : IDisposable
{
    private readonly IPublicClientApplication msalClient;
    private MsalCacheHelper cacheHelper; 
    private readonly HttpClient httpClient;

    private static readonly string[] Scopes = { "XboxLive.signin", "offline_access" };
    public Task<IEnumerable<IAccount>> GetCachedAccounts()
        =>msalClient.GetAccountsAsync();
    
    public Task<AuthenticationResult> AcquireTokenSilentc(IAccount account)
        => msalClient.AcquireTokenSilent(Scopes, account).ExecuteAsync();
#if WINDOWS
    /// <summary>
    /// 作为新账号弹出使用仅限微软视窗操作系统的系统内置级窗口以高安全性的形式以弹出交互式获取微软到麻将访问令牌并返回
    /// </summary>
    public async Task<UserModel?> LoginNewAccountToGetMinecraftMojangAccessTokenUseWindowsWebAccountManger(IntPtr windowHandle)
    {
        try
        {
            var brokerOptions = new BrokerOptions(BrokerOptions.OperatingSystems.Windows);
            AuthenticationResult authResult;
            authResult = await msalClient.AcquireTokenInteractive(Scopes)
                .WithParentActivityOrWindow(windowHandle) // 传入从UI层获取的句柄
                .ExecuteAsync();
            return await ToLoandauth(authResult.AccessToken, authResult.Account);
        }
        catch (MsalClientException ex) when (ex.ErrorCode == MsalError.AuthenticationCanceledError)
        {
            Debug.WriteLine("用户取消了授权");
            return null;
        }
    }
#endif
    /// <summary>
    /// 作为新账号弹出使用系统默认浏览器以弹出交互式获取微软到麻将访问令牌并返回
    /// </summary>
    public async Task<UserModel?> LoginNewAccountToGetMinecraftMojangAccessTokenOnSystemBrowser()
    {
        try
        {
            var authResult = await msalClient.AcquireTokenInteractive(Scopes)
                .ExecuteAsync();

            return await ToLoandauth(authResult.AccessToken, authResult.Account);
        }
        catch (MsalClientException ex) when (ex.ErrorCode == MsalError.AuthenticationCanceledError)
        {
            return null;
        }
    }
    public Task RemoveAccount(IAccount account)
        =>msalClient.RemoveAsync(account);

    private MsalAuthenticator(string clientId)
    {
        var clientBuilder = PublicClientApplicationBuilder.Create(clientId)
            .WithAuthority("https://login.microsoftonline.com/consumers")
            .WithDefaultRedirectUri();

#if WINDOWS
        // 仅在 Windows 平台上编译时，才添加 Broker 配置
        var brokerOptions = new BrokerOptions(BrokerOptions.OperatingSystems.Windows);
        clientBuilder.WithBroker(brokerOptions);
#endif

        msalClient = clientBuilder.Build();
        httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
    }
    public static async Task<MsalAuthenticator> CreateAsync(string clientId)
    {
        var authenticator = new MsalAuthenticator(clientId);

        var storageProperties =
         new StorageCreationPropertiesBuilder("onelauncher.msal.cache.dat", Path.Combine( Init.BasePath,"playerdata"))
         .Build();
        authenticator.cacheHelper = await MsalCacheHelper.CreateAsync(storageProperties);
        authenticator.cacheHelper.RegisterCache(authenticator.msalClient.UserTokenCache);
        return authenticator;
    }
    public async Task<UserModel?> TryToGetMinecraftMojangAccessTokenForLoginedAccounts(IAccount account)
    {
        try
        {
            AuthenticationResult msalResult = await TryToGetMicrosoftAccessToken(account);
            return await ToLoandauth(msalResult.AccessToken,account);
        }
        catch (MsalClientException ex) when (ex.ErrorCode == "access_denied")
        {
            // 当用户在浏览器中明确取消登录时，MSAL会抛出此异常
            throw new OlanException(
                "操作已取消",
                "用户取消了 Microsoft 账户的授权操作。",
                OlanExceptionAction.Warning,
                ex);
        }
        catch (Exception ex)
        {
            // 捕获所有其他来自 MSAL 或后续流程的未知异常
            throw new OlanException(
                "认证流程异常",
                $"在认证流程中发生未知错误: {ex.Message}",
                OlanExceptionAction.Error,
                ex);
        }
    }
    private async Task<AuthenticationResult> TryToGetMicrosoftAccessToken(IAccount account)
    {
        try
        {
            return await msalClient.AcquireTokenSilent(Scopes, account).ExecuteAsync();
        }
        catch (MsalUiRequiredException)
        {
            return await msalClient.AcquireTokenInteractive(Scopes).ExecuteAsync();
        }
    }
    #region 实现了从微软令牌到麻将令牌
    private async Task<UserModel?> ToLoandauth(string microsoftAccessToken,IAccount account)
    {
        try
        {
            var xblAuthResponse = await AuthInXboxLive(microsoftAccessToken);
            var xstsAuthResponse = await AuthInXSTS(xblAuthResponse.Token, xblAuthResponse.DisplayClaims.Xui[0].Uhs);
            if (xstsAuthResponse == null)
            {
                throw new OlanException(
                    "Xbox Live 认证失败",
                    "无法通过XSTS验证Xbox Live令牌。这通常表示您的Xbox档案有问题，例如需要家长同意或未完成资料设置。",
                    OlanExceptionAction.Error
                );
            }

            var mcLoginResponse = await LoginWithXboxAsync(xstsAuthResponse.Token, xstsAuthResponse.DisplayClaims.Xui[0].Uhs);
            if (mcLoginResponse == null)
            {
                throw new OlanException(
                    "Minecraft 登录失败",
                    "无法使用Xbox凭据登录Minecraft服务。",
                    OlanExceptionAction.Error
                );
            }

            var entitlementsResponse = await CheckGameEntitlementsAsync(mcLoginResponse.AccessToken);
            if (entitlementsResponse?.Items == null || entitlementsResponse.Items.Length == 0)
            {
                throw new OlanException(
                    "未拥有Minecraft",
                    "该Microsoft账号未拥有Minecraft游戏。请确保您已购买游戏。",
                    OlanExceptionAction.Error
                );
            }

            var profileResponse = await GetMinecraftProfileAsync(mcLoginResponse.AccessToken);
            if (profileResponse == null)
            {
                throw new OlanException(
                    "获取Minecraft档案失败",
                    "无法获取Minecraft玩家档案。这可能意味着您的Minecraft账号未设置玩家名称或UUID。",
                    OlanExceptionAction.Error
                );
            }

            return new UserModel(
                Guid.NewGuid(),
                profileResponse.Name,
                Guid.Parse(profileResponse.Id),
                mcLoginResponse.AccessToken,
                account.HomeAccountId.Identifier,
                mcLoginResponse.expires_in
            );
        }
        catch (OlanException)
        {
            throw; // 直接抛出已知的 OlanException
        }
        catch (Exception ex)
        {
            throw new OlanException(
                "Minecraft认证流程异常",
                $"在Minecraft认证流程中发生未知错误: {ex.Message}",
                OlanExceptionAction.Error,
                ex);
        }
    }
    private async Task<XboxLiveAuthResponse?> AuthInXboxLive(string accessToken)
    {
        // 1. 构建请求体 (Request Body)
        var requestBody = new XboxLiveAuthRequest
        {
            Properties = new XboxLiveAuthRequestProperties
            {
                AuthMethod = "RPS",
                SiteName = "user.auth.xboxlive.com",
                RpsTicket = $"d={accessToken}" // "RPS Ticket" 是微软对 Access Token 的一种称呼
            },
            RelyingParty = "http://auth.xboxlive.com",
            TokenType = "JWT"
        };

        // 2. 将请求体序列化为 JSON 并创建 StringContent
        var content = new StringContent(
            JsonSerializer.Serialize(requestBody, MsaJsonContext.Default.XboxLiveAuthRequest),
            Encoding.UTF8,
            "application/json"
        );

        var response = await httpClient.PostAsync("https://user.auth.xboxlive.com/user/authenticate", content);

        // 4. 确保请求成功，否则会抛出 HttpRequestException
        response.EnsureSuccessStatusCode();
        // 5. 读取响应内容并反序列化为目标对象
        return await JsonSerializer.DeserializeAsync(await response.Content.ReadAsStreamAsync(), MsaJsonContext.Default.XboxLiveAuthResponse);
    }
    private async Task<XSTSAuthResponse?> AuthInXSTS(string xblToken, string uhs)
    {
        var requestBody = new XSTSAuthRequest
        {
            Properties = new XSTSAuthRequestProperties
            {
                SandboxId = "RETAIL",
                UserTokens = new[] { xblToken }
            },
            RelyingParty = "rp://api.minecraftservices.com/",
            TokenType = "JWT"
        };
        var content = new StringContent(JsonSerializer.Serialize(requestBody, MsaJsonContext.Default.XSTSAuthRequest), Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync("https://xsts.auth.xboxlive.com/xsts/authorize", content);

        if (!response.IsSuccessStatusCode)
        {
            var errorResponse = await JsonSerializer.DeserializeAsync(response.Content.ReadAsStream(), MsaJsonContext.Default.XSTSErrorResponse);
            if (errorResponse?.XErr == "214891605")
            {
                Debug.WriteLine("XSTS 认证失败: 该 Xbox Live 账号需要完成资料设置或家长同意。");
                // 返回 null，让上层统一抛 OlanException
            }
            else if (errorResponse?.XErr == "214891606")
            {
                Debug.WriteLine("XSTS 认证失败: 该微软账号未关联 Xbox Live 档案。请确保您已登录过 Xbox.com。");
                // 返回 null，让上层统一抛 OlanException
            }
            else
            {
                Debug.WriteLine($"XSTS 认证失败: {errorResponse?.Message} (XErr: {errorResponse?.XErr})");
                // 返回 null，让上层统一抛 OlanException
            }
            return null; // 返回 null，表示认证失败，上层会统一抛出 OlanException
        }
        return await JsonSerializer.DeserializeAsync(await response.Content.ReadAsStreamAsync(), MsaJsonContext.Default.XSTSAuthResponse);
    }
    private async Task<MinecraftLoginResponse?> LoginWithXboxAsync(string xstsToken, string uhs)
    {
        var requestBody = new MinecraftLoginRequest
        {
            IdentityToken = $"XBL3.0 x={uhs};{xstsToken}"
        };
        var content = new StringContent(JsonSerializer.Serialize(requestBody, MsaJsonContext.Default.MinecraftLoginRequest), Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync("https://api.minecraftservices.com/authentication/login_with_xbox", content);
        response.EnsureSuccessStatusCode();
        return await JsonSerializer.DeserializeAsync(await response.Content.ReadAsStreamAsync(), MsaJsonContext.Default.MinecraftLoginResponse);
    }
    private async Task<EntitlementsResponse?> CheckGameEntitlementsAsync(string minecraftAccessToken)
    {
        httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", minecraftAccessToken);
        var response = await httpClient.GetAsync("https://api.minecraftservices.com/entitlements/mcstore");
        response.EnsureSuccessStatusCode();
        return await JsonSerializer.DeserializeAsync(await response.Content.ReadAsStreamAsync(), MsaJsonContext.Default.EntitlementsResponse);
    }
    private async Task<MinecraftProfileResponse?> GetMinecraftProfileAsync(string minecraftAccessToken)
    {
        httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", minecraftAccessToken);
        var response = await httpClient.GetAsync("https://api.minecraftservices.com/minecraft/profile");

        if (!response.IsSuccessStatusCode)
        {
            Debug.WriteLine("获取 Minecraft 档案失败。可能此账号没有设置 Minecraft 档案（例如首次启动游戏时）。");
            return null; // 返回 null，让上层统一抛 OlanException
        }
        Debug.WriteLine(await response.Content.ReadAsStringAsync());
        return await JsonSerializer.DeserializeAsync(await response.Content.ReadAsStreamAsync(), MsaJsonContext.Default.MinecraftProfileResponse);
    }
    #endregion
    public void Dispose()
    {
        httpClient?.Dispose();
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ModService/Modrinth/GetModrinth.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Helper.Models;
using OneLauncher.Core.Net.ModService.Modrinth.JsonModelGet;
using System.Diagnostics;
using System.Text.Json;

namespace OneLauncher.Core.Net.ModService.Modrinth;

public class GetModrinth
{
    public ModrinthProjects info;
    public List<ModrinthProjects> dependencies;
    private readonly string modPath;
    private readonly string ModID;
    private readonly string version;
    public GetModrinth(string ModID, string version, string modPath)
    {
        this.modPath = modPath;
        this.ModID = ModID;
        this.version = version;
    }
    public async Task Init()
    {
        using (HttpClient client = new HttpClient())
        {
            var Url = $"https://api.modrinth.com/v2/project/{ModID}/version?game_versions=[\"{version}\"]&loaders=[\"fabric\"]";
            Debug.WriteLine(Url);
            HttpResponseMessage response = await client.GetAsync(Url);
            response.EnsureSuccessStatusCode();

            try
            {
                using (JsonDocument document = JsonDocument.Parse(await response.Content.ReadAsStringAsync()))
                {
                    JsonElement firstElement = document.RootElement[0];
                    info = JsonSerializer.Deserialize<ModrinthProjects>(firstElement.GetRawText(),ModrinthGetJsonContext.Default.ModrinthProjects);
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"加载或解析 Modrinth 主模组版本时出错: {ex.Message}");
                info = null;
                return;
            }

            if (info == null || info.Dependencies == null || info.Dependencies.Count == 0)
                return;

            this.dependencies = new List<ModrinthProjects>();
            foreach (var item in info.Dependencies)
            {
                var DUrl = $"https://api.modrinth.com/v2/project/{item.ProjectId}/version?game_versions=[\"{version}\"]&loaders=[\"fabric\"]";
                Debug.WriteLine(DUrl);
                HttpResponseMessage Dresponse = await client.GetAsync(DUrl);
                Dresponse.EnsureSuccessStatusCode();

                try
                {
                    // **依赖模组版本处理：只获取第一个**
                    using (JsonDocument dDocument = JsonDocument.Parse(await Dresponse.Content.ReadAsStringAsync()))
                    {
                        JsonElement firstDependencyElement = dDocument.RootElement[0];
                        ModrinthProjects dependencyProject = JsonSerializer.Deserialize<ModrinthProjects>(firstDependencyElement.GetRawText(),ModrinthGetJsonContext.Default.ModrinthProjects)
                            ?? throw new InvalidOperationException("解析 Modrinth 依赖模组第一个版本失败。");
                        this.dependencies.Add(dependencyProject);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"加载或解析 Modrinth 依赖模组版本时出错 (ID: {item.ProjectId}): {ex.Message}");
                }
            }
        }
    }
    public NdDowItem? GetDownloadInfos()
    {
        if (info == null)
            return null;
        return new NdDowItem(
            Url: info.Files[0].Url,
            Path: Path.Combine(modPath, info.Files[0].Filename),
            Size: info.Files[0].Size,
            Sha1: info.Files[0].Hashes.Sha1);
    }
    public List<NdDowItem> GetDependenciesInfos()
    {
        List<NdDowItem> items = new List<NdDowItem>();
        if (dependencies == null)
            return null;
        foreach (var item in dependencies)
        {
            items.Add(new NdDowItem(
                Url: item.Files[0].Url,
                Path: Path.Combine(modPath, item.Files[0].Filename),
                Size: item.Files[0].Size,
                Sha1: item.Files[0].Hashes.Sha1));
        }
        return items;
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ModService/Modrinth/JsonModelGet.cs
【代码拼接器】文件内容开始
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Net.ModService.Modrinth.JsonModelGet;
[JsonSerializable(typeof(ModrinthProjects))]
[JsonSerializable(typeof(ModrinthDependency))]
[JsonSerializable(typeof(ModJarDownload))]
[JsonSerializable(typeof(ModJarHashes))]
public partial class ModrinthGetJsonContext : JsonSerializerContext { }
public class ModrinthProjects
{

    [JsonPropertyName("name")]
    public string Name { get; set; }

    [JsonPropertyName("version_type")]
    public string VersionType { get; set; }

    [JsonPropertyName("files")]
    public List<ModJarDownload> Files { get; set; }
    [JsonPropertyName("dependencies")]
    public List<ModrinthDependency> Dependencies { get; set; }
}
public class ModrinthDependency
{
    [JsonPropertyName("project_id")]
    public string ProjectId { get; set; }
}
public class ModJarDownload
{
    [JsonPropertyName("hashes")]
    public ModJarHashes Hashes { get; set; }

    [JsonPropertyName("url")]
    public string Url { get; set; }

    [JsonPropertyName("filename")]
    public string Filename { get; set; }

    [JsonPropertyName("size")]
    public int Size { get; set; }
}

public class ModJarHashes
{
    [JsonPropertyName("sha1")]
    public string Sha1 { get; set; }
}
【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ModService/Modrinth/jsonModelSearch.cs
【代码拼接器】文件内容开始
using System.Text.Json.Serialization;

namespace OneLauncher.Core.Net.ModService.Modrinth.JsonModelSearch;
[JsonSerializable(typeof(ModrinthSearch))]
[JsonSerializable(typeof(ModrinthProjectHit))]
public partial class ModrinthSearchJsonContext : JsonSerializerContext { }
public class ModrinthSearch
{
    [JsonPropertyName("hits")]
    public List<ModrinthProjectHit> Hits { get; set; }
}
public class ModrinthProjectHit
{
    [JsonPropertyName("project_id")]
    public string ProjectId { get; set; }

    [JsonPropertyName("slug")]
    public string Slug { get; set; }

    [JsonPropertyName("title")]
    public string Title { get; set; }

    [JsonPropertyName("description")]
    public string Description { get; set; }

    [JsonPropertyName("versions")]
    public List<string> Versions { get; set; }

    [JsonPropertyName("icon_url")]
    public string IconUrl { get; set; }

    [JsonPropertyName("date_created")]
    public DateTime DateCreated { get; set; }
    [JsonPropertyName("display_categories")]
    public List<string> Categories { get; set; }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Core.Net/ModService/Modrinth/SearchModrinth.cs
【代码拼接器】文件内容开始
using OneLauncher.Core.Net.ModService.Modrinth.JsonModelSearch;
using System.Diagnostics;
using System.Text.Json;

namespace OneLauncher.Core.Net.ModService.Modrinth;
public class SearchModrinth : IDisposable
{
    public ModrinthSearch info;
    private readonly HttpClient httpClient;
    public SearchModrinth()
    {
        this.httpClient = new HttpClient();
    }
    public async Task<ModrinthSearch> ToSearch(string Key)
    {
        // 搜索仅限支持fabric或支持neoforge的模组
        string SearchUrl = $"https://api.modrinth.com/v2/search?query=\"{Key}\"&facets=[[\"categories:neoforge\",\"categories:fabric\"]]";
        Debug.WriteLine(SearchUrl);

        HttpResponseMessage response = await httpClient.GetAsync(SearchUrl);
        response.EnsureSuccessStatusCode();

        Stream jsonResponse = await response.Content.ReadAsStreamAsync();

        // 使用带有选项的源生成器反序列化
        info = await JsonSerializer.DeserializeAsync<ModrinthSearch>(jsonResponse,ModrinthSearchJsonContext.Default.ModrinthSearch);

        return info;
    }
    public void Dispose()
    {
        httpClient.Dispose();
    }
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Desktop/Program.cs
【代码拼接器】文件内容开始
using Avalonia;
using Microsoft.Extensions.DependencyInjection;
using OneLauncher.Core.Global;
using System;
using System.IO;
using System.Threading.Tasks;
namespace OneLauncher.Desktop;

class Program
{
    [STAThread]
    public static void Main(string[] args)
    {
        try
        {
            if (args.Length != 0)
                Console.boot.RunBoot(args).GetAwaiter().GetResult();
            else
            {
                Init.InitTask = Init.Initialize();
                BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
            }
        }
        catch (Exception ex) 
        {
            string crashLogPath = Path.Combine(AppContext.BaseDirectory, "crash_log.txt");
            string errorMessage = $"程序启动时发生致命错误:{ex}";
            System.Console.WriteLine(errorMessage);
            File.WriteAllText(crashLogPath, errorMessage);
            // 抛出，方便调试器看到
            throw;
        }
    } 
    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .With(new Win32PlatformOptions()
            {
                RenderingMode = [Win32RenderingMode.AngleEgl, Win32RenderingMode.Vulkan,Win32RenderingMode.Software]
            })
            .With(new X11PlatformOptions()
            { 
                RenderingMode = [X11RenderingMode.Vulkan,X11RenderingMode.Egl,X11RenderingMode.Glx,X11RenderingMode.Software]
            })
            .LogToTrace();
}

【代码拼接器】文件内容结束

【代码拼接器】文件路径: /Code/OneLauncher-master/OneLauncher.Desktop/_db_.cs
【代码拼接器】文件内容开始
/*
 *                        _oo0oo_
 *                       o8888888o
 *                       88" . "88
 *                       (| -_- |)
 *                       0\  =  /0
 *                     ___/`---'\___
 *                   .' \\|     |// '.
 *                  / \\|||  :  |||// \
 *                 / _||||| -:- |||||- \
 *                |   | \\\  - /// |   |
 *                | \_|  ''\---/''  |_/ |
 *                \  .-\__  '-'  ___/-. /
 *              ___'. .'  /--.--\  `. .'___
 *           ."" '<  `.___\_<|>_/___.' >' "".
 *          | | :  `- \`.;`\ _ /`;.`/ - ` : | |
 *          \  \ `_.   \_ __\ /__ _/   .-` /  /
 *      =====`-.____`.___ \_____/___.-`___.-'=====
 *                        `=---='
 * 
 * 
 *      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 
 *            佛祖保佑       永不宕机     永无BUG
 * 
 *        佛曰:  
 *                写字楼里写字间，写字间里程序员；  
 *                程序人员写程序，又拿程序换酒钱。  
 *                酒醒只在网上坐，酒醉还来网下眠；  
 *                酒醉酒醒日复日，网上网下年复年。  
 *                但愿老死电脑间，不愿鞠躬老板前；  
 *                奔驰宝马贵者趣，公交自行程序员。  
 *                别人笑我忒疯癫，我笑自己命太贱；  
 *                不见满街漂亮妹，哪个归得程序员？
 */
【代码拼接器】文件内容结束

